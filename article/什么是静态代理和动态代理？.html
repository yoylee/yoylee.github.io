<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="google-site-verification" content="n148olMBZDZJMyBPHjiiPTrf-4xuA3Nawz6-sbWEtfM"><meta><title>什么是静态代理和动态代理？ - Java小站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Java小站"><meta name="msapplication-TileImage" content="/img/gzh-ewm.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Java小站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解  首先，要明确为什么要存在代理呢？ 存在一个常见的需求：怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？"><meta property="og:type" content="blog"><meta property="og:title" content="什么是静态代理和动态代理？"><meta property="og:url" content="http://coderstudy.vip/article/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F.html"><meta property="og:site_name" content="Java小站"><meta property="og:description" content="学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解  首先，要明确为什么要存在代理呢？ 存在一个常见的需求：怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200521125516667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center"><meta property="article:published_time" content="2021-03-03T07:25:19.204Z"><meta property="article:modified_time" content="2021-03-03T07:25:19.198Z"><meta property="article:author" content="洋仔"><meta property="article:tag" content="代理模式"><meta property="article:tag" content="动静态代理"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://img-blog.csdnimg.cn/20200521125516667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://coderstudy.vip/article/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F.html"},"headline":"什么是静态代理和动态代理？","image":[],"datePublished":"2021-03-03T07:25:19.204Z","dateModified":"2021-03-03T07:25:19.198Z","author":{"@type":"Person","name":"洋仔"},"description":"学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解  首先，要明确为什么要存在代理呢？ 存在一个常见的需求：怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？"}</script><link rel="canonical" href="http://coderstudy.vip/article/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F.html"><link rel="icon" href="/img/java%E5%B0%8F%E7%AB%99logo.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?6c71c3728e98d57c841f10b76014c609";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Java小站" type="application/atom+xml"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/java%E5%B0%8F%E7%AB%99logo.png" alt="Java小站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">--Java小站--</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories/Java%E5%9F%BA%E7%A1%80">Java基础</a><a class="navbar-item" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a><a class="navbar-item" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91">高并发</a><a class="navbar-item" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6">中间件</a><a class="navbar-item" href="/categories/Spring%E7%B3%BB%E5%88%97">Spring系列</a><a class="navbar-item" href="/categories/MySql">MySql</a><a class="navbar-item" href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93">图数据库</a><a class="navbar-item" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><a class="navbar-item" href="/categories/%E7%AE%97%E6%B3%95">算法</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">问题解决</a><a class="navbar-item" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><a class="navbar-item" href="/about">--关于站长--</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yoylee"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-4 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>什么是静态代理和动态代理？</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-03</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span><span class="level-item">1 小时读完 (大约7318个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><blockquote><p>学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解</p></blockquote><p><strong>首先，要明确为什么要存在<code>代理</code>呢？</strong></p><p>存在一个常见的需求：<code>怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？</code></p><span id="more"></span><p>先不考虑什么代理不代理的，我们设计一个简单的实现方案：</p><p>新创建一个类B，类B组合类A，在类B中创建一个方法b，方法b中调用类A中的方法a，在调用前和调用后都可以添加一些自定义的附加与增强代码。 当有需求需要调用类A的方法a并且想要添加一个附加功能时，就去调用类B的方法b即可实现上述需求；</p><p>下面为了便于理解，附上伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是方法a!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">    <span class="comment">// 组合ClassA</span></span><br><span class="line">    ClassA  A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我执行啦~!&quot;</span>);</span><br><span class="line">        A.methoda();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我完成啦~!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，让我们来调用一下ClassB的methodb方法，则会产生以下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是方法a的附加功能代码，我执行啦~!</span><br><span class="line">我是方法a!</span><br><span class="line">我是方法a的附加功能代码，我完成啦~!</span><br></pre></td></tr></table></figure><p>可以发现，方法a执行了，并且在没有修改类A代码的前提下，为方法a附加了其他的功能；<br>不难吧，其实上述的代码就是一个最简单的<code>代理模式</code>了</p><p><strong>代理存在的意义</strong>：使用代理模式可以在不修改别代理对象代码的基础上，通过扩展代理类，进行一些功能的附加与增强</p><h1 id="代理种类"><a href="#代理种类" class="headerlink" title="代理种类"></a>代理种类</h1><p>代理分为<code>静态代理</code>和<code>动态代理</code>，其涉及的设计模式就是<code>代理模式</code>本尊了，代理模式一般包含几种元素，如下图：<br><img src="https://img-blog.csdnimg.cn/20200521125516667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>主题接口(subject)：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</li><li>真实主题(RealSubject)：真正实现业务逻辑的类；</li><li>代理类(Proxy)：用来代理和封装真实主题；</li><li>客户端(Client)：使用代理类和主题接口完成一些工作。</li></ol><p>为了更好的理解，我们将上述实现的最简易版的代理完善一下，添加接口，代理类也实现相应的被代理类的接口，实现同一个方法，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类的接口（上图中subject）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImpA</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义类A（上图中RealSubject）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">ImpA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是方法a!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类B（上图中Proxy）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span>  <span class="title">ImpA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合ClassA</span></span><br><span class="line">    ImpA  A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写被代理类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我执行啦~!&quot;</span>);</span><br><span class="line">        A.methoda();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我完成啦~!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端类（上图中Client）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建被代理对象实例</span></span><br><span class="line">    ImpA A = <span class="keyword">new</span> ClassA();</span><br><span class="line">    <span class="comment">// 构造器注入被代理对象实例</span></span><br><span class="line">    ImpA B = <span class="keyword">new</span> ClassB(A);</span><br><span class="line">    <span class="comment">// 调用代理方法</span></span><br><span class="line">    B.methoda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><code>所谓静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</code><br>上面的代码就是实现了一个静态代理； 其实静态代理就已经能够满足上述需求了，为什么还需要动态代理呢？ 这里就涉及到静态代理的两个缺点了</p><ol><li><code>代理对象</code>的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，在程序规模稍大时静态代理代理类就会过多会造成代码混乱</li><li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。<br>基于上述两个问题，动态代理诞生了~</li></ol><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><code>动态代理是在程序运行时，通过反射获取被代理类的字节码内容用来创建代理类</code></p><p><strong>具体什么是动态代理呢？</strong><br>名词：<code>动态</code>，动态在程序中就是表达在程序运行时就根据配置自动的生成代理类并且代理类和被代理类是在运行时才确定相互之间的关系；</p><p>在JDK中包含两种动态代理的实现机制：<code>JDK Proxy</code> 和 <code>CGLib</code>；</p><p>下面我们以<code>JDK Proxy</code>为例，讲解一下动态代理和根据源码分析并简单说一下应用场景</p><h3 id="JDK-Proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h3><p><code>JDK Proxy动态代理</code>，api在包<code>java.lang.reflect</code>下，大家可能发现了，为什么在反射的包下呢？这个问题我们下面的源码分析会解决；</p><p>其核心api包含两个重要的核心接口和类：一个是 <code>InvocationHandler(Interface)</code>、另一个则是 <code>Proxy(Class)</code>，简单说就这两个简单的很，这两个是我们实现动态代理所必需的用到的，下面简单介绍一下两个类：<br><strong><code>java.lang.reflect.Proxy（Class）</code></strong> ：Proxy是 Java 动态代理机制的主类，提供一组静态方法来为一组接口动态地生成代理类及其对象。包含以下四个静态方法：</p><ul><li><code>static InvocationHandler getInvocationHandler(Object proxy)</code><br>该方法用于获取指定代理对象所关联的调用处理器</li><li><code>static Class getProxyClass(ClassLoader loader, Class[] interfaces)</code><br>该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</li><li><code>static boolean isProxyClass(Class cl)</code><br>该方法用于判断指定类对象是否是一个动态代理类</li><li><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces,InvocationHandler h)</code><br>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，包含下面的参数：<ul><li><code>loader</code> 指定代理类的ClassLoader加载器</li><li><code>interfaces</code> 指定代理类要实现的所有接口</li><li><code>h</code>: 表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</li></ul></li></ul><p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p><p><strong><code>java.lang.reflect.InvocationHandler（interface）</code></strong> ： <code>InvocationHandler</code>是上述<code>newProxyInstance</code>方法的<code>InvocationHandler h</code>参数传入，负责连接代理类和委托类的中间类必须实现的接口<br>它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><p><strong>上述就是动态代理两个核心的方法，不太明白？先别急，我们先用上述实现一个动态代理，你先看一下</strong></p><p>还是以上述的案例从静态代理来改造为动态代理，实现动态代理主要就两步，假设还是存在上述的ImplA、ClassA</p><p><strong>1：创建一个<code>处理器</code>类实现InvocationHandler接口，重写invoke方法，伪代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">// 标识被代理类的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Object delegate;   </span><br><span class="line">    <span class="comment">// 构造器注入被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Object delegate)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理方法调用前的附加代码执行~ &quot;</span>);</span><br><span class="line">        <span class="comment">// 真实的被代理方法调用</span></span><br><span class="line">        method.invoke(delegate, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理方法调用后的附加代码执行~ &quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样一个<code>处理器</code>就搞定了，当我们在调用<code>被代理类</code>的方法时，就是去执行上述<code>重写的invoke方法</code>，下面创建一个ClassA的<code>代理类</code></p><p><strong>2：创建<code>代理类</code>，并调用被代理方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        ImplA A = <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 创建处理器类实现</span></span><br><span class="line">        InvocationHandler myHandler = <span class="keyword">new</span> MyHandler(A);</span><br><span class="line">        <span class="comment">// 重点！ 生成代理类， 其中proxyA就是A的代理类了</span></span><br><span class="line">        ImplA proxyA = (ImplA)Proxy.newProxyInstance(A.getClass().getClassLoader(), A.getClass().getInterfaces(), myHandler);</span><br><span class="line">        <span class="comment">// 调用代理类的代理的methoda方法， 在此处就会去调用上述myHandler的invoke方法区执行，至于为什么，先留着疑问，下面会说清楚~</span></span><br><span class="line">        proxyA.methoda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，至此一个动态代理就构建完成了，执行代码，会发现输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被代理方法调用前的附加代码执行~</span><br><span class="line">我是方法a！</span><br><span class="line">被代理方法调用后的附加代码执行~</span><br></pre></td></tr></table></figure><p>太简单了有木有，这里总结一下动态代理的优缺点：</p><p><strong>优点：</strong></p><ol><li><p>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</p></li><li><p>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</p></li><li><p>接口增加一个方法，除了所有实现类需要实现这个方法外，动态代理类会直接自动生成对应的代理方法。</p></li></ol><p><strong>缺点：</strong><br>JDK proxy只能对有实现接口的类才能代理，也就是说没有接口实现的类，jdk proxy是无法代理的，为什么呢？下面会解答.</p><p><em>有什么解决方案吗？</em> 当然有，还有一种动态代理的方案：<code>CGLib</code>，它是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的，和jdk proxy基本思想是相似的，毕竟都是动态代理的实现方案嘛，在这篇文章就不做详解了，博主会在其他的博文单独介绍这个nb的框架</p><p><strong>上述带大家搞了一遍动态代理和静态代理的应用；在这过程中，你有没有想过，动态代理是怎么实现的呢？</strong></p><p>下面我们就从源码的角度分析一下，解决大家的疑问。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在开始分析的时候，我希望大家带着几个<code>问题</code>去阅读，可以帮助大家更好的理解：</p><ul><li><code>问题1</code>：代理类为什么可以在运行的时候自动生成呢？如何生成的呢？</li><li><code>问题2</code>：为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</li><li><code>问题3</code>：为什么jdk proxy只支持代理有接口实现的类呢？</li></ul><p>ps ：<em>为了提升阅读体验，让大家有一个更清晰的认知，以下源码会将一些异常处理和日志打印代码删除，只保留主干代码，请知悉~</em></p><p>我们就从两个核心：<code>InvocationHandler</code>和<code>Proxy</code>来进行分析整个脉络，他们都在<code>java.lang.reflect</code>包下</p><h4 id="InvocationHandler源码"><a href="#InvocationHandler源码" class="headerlink" title="InvocationHandler源码"></a>InvocationHandler源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是InvocationHandler的源码，没什么其他的就是一个接口，里面有一个待实现方法invoke，处理类实现此接口重写invoke方法</p><h4 id="Proxy源码"><a href="#Proxy源码" class="headerlink" title="Proxy源码"></a>Proxy源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理类实例 变量</span></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">    <span class="comment">// 用于存储 已经通过动态代理获取过的代理类缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;  proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(),<span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line">    <span class="comment">// 私有无参构造，使得只能通过传入InvocationHandler参数来创建该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 保护 构造函数，入参InvocationHandler处理类</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span>  <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理类的实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 各种私有方法</span></span><br><span class="line">    <span class="keyword">private</span> ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>类的整体的架构就类似于上述，<code>InvocationHandler h</code>参数和<code>两个构造函数</code>、<code>四个上述已经介绍过的共有方法</code>，还有一系列的私有方法，getProxyClass、isProxyClass、getInvocationHandler功能就和上面介绍的一样，就不再详细介绍了</p><p><strong>我们下面来主要看一下<code>newProxyInstance</code>方法</strong><br>newProxyInstance方法，我在方法内添加上了对应的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 克隆对应的接口，用于代理类实现的接口数组</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.  源码中的介绍</span></span><br><span class="line"><span class="comment">     * 2. 查找或者生成指定的代理类， 下面会详细介绍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     * 3. 上面代码已经生成了代理类 cl，cl其中包含一个参数为传入的InvocationHandler h的构造函数， 获取该构造函数并通过该构造函数创建一个类的实例对象并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 通过《反射》获取参数为InvocationHandler的构造函数</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="comment">// 5. 判断构造函数是否为私有的，如果为私有的则需要设置私有可访问权限</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6. 通过上述获取的构造函数创建对应的 实例对象，并返回！over~</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">       <span class="comment">// 各种异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我简单的标注了一下每行代码的作用，下面我们来详细分析一下；</p><p><strong>代理类的字节码生成逻辑</strong></p><p>我们知道，在加载jvm前，java文件都已经被编译成了<code>class字节码</code>文件， 然后jvm通过<code>类加载器</code>将字节码文件加载到jvm中；</p><p>我们的代理类也是这样，不同的是动态代理的类是在程序运行时产生的，我们要做的就是如何在程序运行的时候，通过<code>被代理类</code>的字节码生成<code>代理类</code>的字节码！</p><p>我们接下来详细分析<code>newProxyInstance</code>方法：</p><p>在newProxyInstance中调用了<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code>语句生成了<code>代理类的字节码</code>，此处调用了getProxyClass0方法，传入了指定的类加载器和对应要实现的接口</p><p>那么， 我们看看<code>getProxyClass0</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxyClassCache是WeakCache弱引用缓存类，如果之前就生成过对应的代理类就从缓存中取，如果没生成过就重新生成</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxyClassCache</code>是Proxy类中的静态变量，是WeakCache类，里面封装了两个类KeyFactory、ProxyClassFactory，都是BiFunction函数式接口(如果不清楚函数式接口，请自行google)；</p><p>将其拿过来看一下<code>proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(),new ProxyClassFactory());</code> 其中调用了proxyClassCache.get(loader, interfaces)方法的实现</p><p>未避免代码过长，只粘贴了核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 这部分主要是获取对应的 函数式接口，如果不明白函数式接口，google一下吧~</span></span><br><span class="line">     Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">     Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">     Factory factory = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">// 此处为什么是while循环呢， 主要是supplier不为空的话，则执行下面的语句赋值后，再循环执行下一次则supplier不为空</span></span><br><span class="line">         <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果存在对应的函数式接口，  调用函数式接口对应的代码</span></span><br><span class="line">             <span class="comment">// 重点！！！调用函数式接口！！</span></span><br><span class="line">             V value = supplier.get();</span><br><span class="line">             <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> value;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 创建一个 专门创建代理类字节码的工厂类，实现类是ProxyClassFactory</span></span><br><span class="line">             factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">             supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">             <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 将supplier赋值factory</span></span><br><span class="line">                 supplier = factory;</span><br><span class="line">             &#125;&#125;&#125;&#125; &#125;</span><br></pre></td></tr></table></figure><p>总结一下上述方法的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[缓存中获取代理类字节码] --&gt; C&#123;是否存在&#125;</span><br><span class="line">C --&gt;|是| D[代理中获取并返回]</span><br><span class="line">C --&gt;|否| E[调用ProxyClassFactory的apply方法生成代理类字节码]</span><br></pre></td></tr></table></figure><p>接着<code>ProxyClassFactory.apply</code>方法看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">     Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">     <span class="comment">// 获取接口对应的接口class对象</span></span><br><span class="line">     <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">     <span class="comment">// 判断是否包含公有的接口对象，判断是否可以通过jdk proxy的方式进行生成代理类</span></span><br><span class="line">     <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">         <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">             accessFlags = Modifier.FINAL;</span><br><span class="line">             String name = intf.getName();</span><br><span class="line">             <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">             String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">             <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 proxyPkg = pkg;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果没有公有接口类，需要使用CGLib来实现。。。</span></span><br><span class="line">     <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">         proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 组装代理类的类名称</span></span><br><span class="line">     <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">     String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">     <span class="comment">// 重点！！ 此处生成代理类的字节码数组</span></span><br><span class="line">     <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClassproxyName, interfaces, accessFlags);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过类加载器将字节码数组加载到JVm的方法区中生成Class对象！</span></span><br><span class="line">         <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                             proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述的<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</code> 为生成代理类字节码数组的方法，调用的方法中调用了<code>generateClassFile</code>方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">// 首先，默认代理的三个方法：hashCode\equals\toString</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        <span class="comment">// 获取所有的要被代理类实现的接口</span></span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">// 遍历上述获取的接口</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            <span class="comment">// 赋值： 将接口的Class对象赋值！</span></span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="comment">// 通过“反射”获取所有方法</span></span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="comment">// 将方法添加到 要被代理的方法中</span></span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取要代理方法后，开始组装字节码</span></span><br><span class="line">        var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">        var14.writeShort(<span class="number">0</span>);</span><br><span class="line">        var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">        var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">        <span class="comment">// 注意！！！  .... 此处省略了绝大部分 字节码的组装过程，只给出了几行代码展示一下字节码的组装</span></span><br><span class="line">        <span class="comment">// 最终返回组装好的字节码文件</span></span><br><span class="line">        <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>generateClassFile</code>中，你会发现里面全部是重组字节码的代码， 主要是获取<code>被代理类</code>字节码和<code>操作类InvocationHandler</code>字节码组装出<code>代理类</code>的字节码，在重组的过程因为是在<code>运行时</code>进行了代理类的创建，无法像往常一样new一个被代理类的实例获取他的方法，让代理类进行调用。</p><p>获取字节码后，接下来就要将代理类的字节码加载进JVM中了，这里调用的是一个<code>return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length)</code> 其中的<code>defineClass0</code>是一个本地native 方法，传入了<code>代理类名称、类加载器、代理类的字节码文件、文件长度参数</code>，从而将字节码加载进JVM中！ 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(ClassLoader loader, String name,</span><br><span class="line">                                                <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure><p>将代理类的字节码加载进JVM后，会在方法区内生成一个<code>Class对象</code>，标识这个代理类；</p><p><strong>代理类的实例生成逻辑</strong><br>上面，我们知道了通过字节码技术生成了代理类字节码，并通过类加载器将字节码文件加载到了JVM的方法区中生成了一个Class对象，我们如何在运行时获取这个Class对象的实例呢？ 只有获取了对象实例才可以使用不是~<br>还是回到<code>newProxyInstance</code>方法中，上面我们分析了<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs)</code>这部分逻辑，生成了Class对象<code>cl</code>，下面生辰该实例代码，过程很简单，相关逻辑我就直接在代码中注释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数的参数类型，下面的一个语句使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =    &#123; InvocationHandler.class &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取上述获取的Class对象的带参构造函数，参数必须是上述定义的 InvocationHandler.class类型</span></span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="comment">// 检查权限，如果是私有权限，设为可被访问</span></span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 通过构造函数传入对应 处理类h 参数，生成实例！</span></span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure><p>上述就是生成实例的代码，生成实例后<code>newProxyInstance</code>就返回该实例了，就可以使用了~</p><h4 id="反射：在运行时获取被代理类的字节码"><a href="#反射：在运行时获取被代理类的字节码" class="headerlink" title="反射：在运行时获取被代理类的字节码"></a>反射：在运行时获取被代理类的字节码</h4><p><strong>那如何才能在运行时获取到被代理类的构造函数、方法、属性等字节码呢？</strong> 此时“<code>反射！</code>”登场了！我们通过反射可以在运行时获取到类的所有信息，所有哦。<br><strong>定义：</strong> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>java语言的反射机制</code>。</p><p>比如，在上述所说的组装代理类字节码时，在获取被代理类的所有方法时，就调用了<code>Method[] var5 = var4.getMethods();</code> 反射中的<code>getMethods</code>方法，通过反射获取到了被代理类的所有方法，这样我们就可以在运行时获取到任何类的所有的字节码信息了! 从而可以组装出我们想要的代理类字节码！</p><p>所以说，<code>反射</code>也为<code>动态代理</code>的实现提供了<code>理论支持</code>！！因为只有在运行时能获取到对应类的信息，才可以通过信息创造出对应的我们所需要的代理类；</p><h3 id="源码分析总结"><a href="#源码分析总结" class="headerlink" title="源码分析总结"></a>源码分析总结</h3><p>总而言之，<code>动态代理</code>的理论支持是可以通过<code>反射机制</code>在<code>运行时</code>获取到类的所有信息，如果运行时获取不到被代理类的信息，那还咋生成代理类。<br><strong>动态代理的大致流程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[反射获取被代理字节码] --&gt; B[反射获取InvocationHandler实现类字节码]</span><br><span class="line">B --&gt;C[依据被代理类字节码和InvocationHandler实现类字节码 通过操作字节码组装 代理类 字节码]</span><br><span class="line">C --&gt;D[通过给定的classLoad将 代理类字节码 加载到JVM中]</span><br><span class="line">D --&gt;E[调用native方法 加载到JVM的方法区 生成Class对象]</span><br><span class="line">E --&gt;F[反射获取代理类的Class对象的构造函数]</span><br><span class="line">F --&gt;G[通过反射获取的构造函数new一个代理类的实例A]</span><br><span class="line">G --&gt;H[使用代理类实例A]</span><br></pre></td></tr></table></figure><p>通过上述流程。我们就获得了一个代理类对象了，调用代理类对应的方法，就会执行我们规定的执行逻辑，实现对被代理类的运行时动态增强和扩展！</p><p>此时，我们再拿出刚开始我们用JDK proxy实现的动态代理代码中的生成代理类的代码：<code>ImplA proxyA = (ImplA)Proxy.newProxyInstance(A.getClass().getClassLoader(), A.getClass().getInterfaces(), myHandler)</code> 每个参数的作用，是不是就很清晰了</p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>上面<code>动态代理实现流程</code>，我们可以回答上述的第一个<code>代理类为什么可以在运行的时候自动生成呢？如何生成的呢？</code> 问题了</p><p>对于第二个<code>为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</code>和第三个<code>为什么jdk proxy只支持代理有接口实现的类呢？</code>问题，我们需要反编译一下我们通过字节码技术产生的<code>代理类</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ImplA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.test.ImplA&quot;</span>).getMethod(<span class="string">&quot;methoda&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">           <span class="comment">// ..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要被加强的方法methoda</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码包含几个关键点：</p><ol><li>方法为<code>final</code>类型，不可再被继承</li><li>代理名称为 <code>$Proxy</code> 代理类前缀 + 递增数字</li><li>继承动态代理的核心类<code>Proxy</code>， 实现了我们指定的接口<code>ImplA</code></li><li>一个带参构造方法<code>$Proxy0(InvocationHandler var1)</code> 传入InvocationHandler内部调用了父类的<code>Proxy</code>的构造函数</li><li>methoda、toString、hashCode、equals全部调用的传入的InvocationHandler参数的 <code>invoke</code>方法！！！</li></ol><p>现在回答第二个问题<code>为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</code></p><p>显而易见，代理类内部的代理方法全部显式调用的InvocationHandler实现类的invoke方法</p><p>第三个问题<code>为什么jdk proxy只支持代理有接口实现的类呢？</code></p><p>因为代理类在使用JDK proxy方式生成代理类时，默认继承Proxy类，又因为java语言是单继承不支持多继承，那怎样才能标识我要代理什么类型的类或是代理什么方法呢？ 接口呗，java支持接口的多继承，多少个都ok~</p><p>好了，上述将动态代理的使用方式 和 实现原理统一过了一遍，也回答了几个容易疑惑的问题，下面我们简单说下动态代理在现实的java框架大家庭中的一些典型应用</p><h3 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h3><p><strong><code>spring aop</code></strong> ： 这可以说是spring框架中最典型的应用了，通过动态代理在运行时产生代理类，完成对被代理类的增强和功能附加<br><strong><code>RPC框架的实现</code></strong> ： 远程过程调用，RPC使得调用远程方法和调用本地方法一样，这是怎么搞的呢？服务方对外放出服务的接口api，调用方拿到接口api，通过动态代理的方式生成一个代理类，代理类的处理类的invoke方法可以通过websocket连接远程服务器调用对应的远程接口； 这样我们再用代理对象进行调用对应方法时时，就像调用本地方法一样了<br><strong><code>mybatis框架中</code></strong> ： mapper.xml中编写sql语句，mapper.java接口写上对应的方法签名；我们直接调用mapper.java中的方法就可以执行对应的sql语句，有没有想过为什么？ 框架使用动态代理创建一个mapper.java的代理对象，代理对象的处理类invoke中执行sql，就ok了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理分为<code>静态代理</code>和<code>动态代理</code>，动态代理的两种实现方式：<code>JDK Proxy</code>和<code>CGLib</code>，动态代理的<code>核心反射机制</code>，通过反射在运行时获取被代理类字节码和处理类字节码，动态代理代理类的生成通过<code>重组字节码</code>的方式。</p><p><strong>原创不易，有收获的话，<code>关注</code>、<code>点赞</code>、<code>评论</code>三连支持，我最大的动力~</strong></p><blockquote><p>关于博文有任何问题请不吝评论，感谢</p></blockquote><blockquote><p>参考：JDK源码，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/861223789d53">https://www.jianshu.com/p/861223789d53</a></p></blockquote></div><div class="article-licensing box"><div class="licensing-title"><p>什么是静态代理和动态代理？</p><p><a href="http://coderstudy.vip/article/什么是静态代理和动态代理？.html">http://coderstudy.vip/article/什么是静态代理和动态代理？.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>洋仔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式, </a><a class="link-muted" rel="tag" href="/tags/%E5%8A%A8%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/">动静态代理</a></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-603e216abef49db8" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-JanusGraph%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%EF%BC%88Monitoring_JanusGraph%EF%BC%89.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">图解JanusGraph系列-JanusGraph指标监控报警（Monitoring JanusGraph）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/article/git-revert.html"><span class="level-item">Git提交错误，回退的三种方式！</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="article/什么是静态代理和动态代理？.html"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid:"cyvk3kK5A",conf:"prod_4d15c7a1b97dcc293442445086f1bcf4"})</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/gzh-ewm.jpg" alt="Java小站"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Java小站</p><p class="is-size-6 is-block">以匠心-卓不凡</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China-BeiJing</span></p></div></div></nav><nav class="level is-mobile"><a class="level-item has-text-centered is-marginless" href="/categories"><div><p class="heading">文章</p><div><p class="title">23</p></div></div></a><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://images.coderstudy.vip/gzh-ewm.jpg" target="_blank" rel="noopener">扫码关注微信公众号</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yoylee"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="邮件" href="mailto:1591992570@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#代理种类"><span class="level-left"><span class="level-item">1</span><span class="level-item">代理种类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态代理"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">静态代理</span></span></a></li><li><a class="level is-mobile" href="#动态代理"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">动态代理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JDK-Proxy"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">JDK Proxy</span></span></a></li><li><a class="level is-mobile" href="#源码分析"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">源码分析</span></span></a></li><li><a class="level is-mobile" href="#源码分析总结"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">源码分析总结</span></span></a></li><li><a class="level is-mobile" href="#问题解答"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">问题解答</span></span></a></li><li><a class="level is-mobile" href="#动态代理的应用"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">动态代理的应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">总结</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MySql/"><span class="level-start"><span class="level-item">MySql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring%E7%B3%BB%E5%88%97/"><span class="level-start"><span class="level-item">Spring系列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">图数据库</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"><span class="level-start"><span class="level-item">问题解决</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">高并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JanusGraph/"><span class="tag">JanusGraph</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring%E7%B3%BB%E5%88%97/"><span class="tag">Spring系列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/idea/"><span class="tag">idea</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="tag">二进制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"><span class="tag">代理模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"><span class="tag">动静态代理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><span class="tag">线程池</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:30.624Z">2021-03-03</time></p><p class="title"><a href="/article/JanusGraph_-_data_model.html">图解图库JanusGraph系列-一文知晓“图数据“底层存储结构（JanusGraph data model）</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:17.818Z">2021-03-03</time></p><p class="title"><a href="/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E5%85%B3%E4%BA%8EJanusGraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%83%B3%E6%B3%95%EF%BC%88bulk_load_data%EF%BC%89.html">图解JanusGraph系列 - 关于JanusGraph图数据批量快速导入的方案和想法（bulk load data）</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:08.629Z">2021-03-03</time></p><p class="title"><a href="/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html">图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:26:58.125Z">2021-03-03</time></p><p class="title"><a href="/article/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-idea_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%ABjar%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AFpom%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E6%A0%87%E7%BA%A2.html">问题解决-idea 本地仓库中包含jar包，但是pom依赖文件标红</a></p><p class="categories"><a href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">问题解决</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:26:52.210Z">2021-03-03</time></p><p class="title"><a href="/article/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%8C%E4%BB%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9D%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%BE%8E.html">编程之美，从线程池状态管理来看二进制操作之美</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/yoylee" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://liyangyang.blog.csdn.net/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liyangyang.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.jianshu.com/u/dabfb12677f1" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span><span class="level-right"><span class="level-item tag">www.jianshu.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/java%E5%B0%8F%E7%AB%99logo.png" alt="Java小站" height="28"></a><p class="is-size-7"><span>&copy; 2021 洋仔</span>  备案号：鲁ICP备17056511号 &amp; <a href="http://coderstudy.vip" target="_blank" rel="noopener">coderstudy.vip</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"folded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script data-ad-client="ca-pub-6038794546438627" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>