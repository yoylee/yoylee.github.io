<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="google-site-verification" content="n148olMBZDZJMyBPHjiiPTrf-4xuA3Nawz6-sbWEtfM"><meta><title>图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析 - Java小站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Java小站"><meta name="msapplication-TileImage" content="/img/gzh-ewm.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Java小站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？分布式锁！ 大家好，我是洋仔，JanusGraph图解系列文章，实时更新~"><meta property="og:type" content="blog"><meta property="og:title" content="图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析"><meta property="og:url" content="http://coderstudy.vip/2021/03/03/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html"><meta property="og:site_name" content="Java小站"><meta property="og:description" content="在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？分布式锁！ 大家好，我是洋仔，JanusGraph图解系列文章，实时更新~"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9e6da024452de3eb2ac72cc15d8daf60.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c7d2707674f5b8029da1f146350cdf91.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e335e5d11f814fd448ce065fa20dce9e.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/257a9bbcc1110d06a8f52ce09906cd16.png"><meta property="article:published_time" content="2021-03-03T07:27:08.629Z"><meta property="article:modified_time" content="2021-03-03T07:27:08.624Z"><meta property="article:author" content="洋仔"><meta property="article:tag" content="JanusGraph"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/9e6da024452de3eb2ac72cc15d8daf60.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://coderstudy.vip/2021/03/03/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html"},"headline":"图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析","image":["https://img-blog.csdnimg.cn/img_convert/9e6da024452de3eb2ac72cc15d8daf60.png","https://img-blog.csdnimg.cn/img_convert/c7d2707674f5b8029da1f146350cdf91.png","https://img-blog.csdnimg.cn/img_convert/e335e5d11f814fd448ce065fa20dce9e.png","https://img-blog.csdnimg.cn/img_convert/257a9bbcc1110d06a8f52ce09906cd16.png"],"datePublished":"2021-03-03T07:27:08.629Z","dateModified":"2021-03-03T07:27:08.624Z","author":{"@type":"Person","name":"洋仔"},"description":"在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？分布式锁！ 大家好，我是洋仔，JanusGraph图解系列文章，实时更新~"}</script><link rel="canonical" href="http://coderstudy.vip/2021/03/03/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html"><link rel="icon" href="/img/java.jpeg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?6c71c3728e98d57c841f10b76014c609";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Java小站" type="application/atom+xml"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/gzh-ewm.jpg" alt="Java小站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">--Java小站--</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories/Java%E5%9F%BA%E7%A1%80">Java基础</a><a class="navbar-item" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a><a class="navbar-item" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91">高并发</a><a class="navbar-item" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6">中间件</a><a class="navbar-item" href="/categories/Spring%E7%B3%BB%E5%88%97">Spring系列</a><a class="navbar-item" href="/categories/MySql">MySql</a><a class="navbar-item" href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93">图数据库</a><a class="navbar-item" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><a class="navbar-item" href="/categories/%E7%AE%97%E6%B3%95">算法</a><a class="navbar-item" href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">问题解决</a><a class="navbar-item" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a><a class="navbar-item" href="/about">--关于站长--</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/yoylee"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-4 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-03-03</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-03-03</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></span><span class="level-item">32 分钟读完 (大约4795个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？<strong>分布式锁！</strong></p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a target="_blank" rel="noopener" href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录</a></li><li><strong>地址：</strong><a target="_blank" rel="noopener" href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（码文不易，求个star~）</code>**： <a target="_blank" rel="noopener" href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p><strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a target="_blank" rel="noopener" href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><hr><p>在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？<strong>分布式锁！</strong></p><h2 id="一：分布式锁"><a href="#一：分布式锁" class="headerlink" title="一：分布式锁"></a>一：分布式锁</h2><p>常用的分布式锁实现方式有三种：</p><p>1、基于数据库实现分布式锁</p><p>​ 针对于数据库实现的分布式锁，如mysql使用使用<code>for update</code>共同竞争一个行锁来实现； 在JanusGraph中，也是基于数据库实现的分布式锁，这里的<code>数据库</code>指的是我们当前使用的第三方<code>backend storage</code>，具体的实现方式也和mysql有所不同，具体我们会在下文分析</p><p>2、基于Redis实现的分布式锁</p><p>​ 基于<code>lua脚本</code>+<code>setNx</code>实现</p><p>3、基于zk实现的分布式锁</p><p>​ 基于<code>znode</code>的有序性和<code>临时节点</code>+zk的<code>watcher</code>机制实现</p><p>4、MVCC多版本并发控制乐观锁实现</p><blockquote><p>本文主要介绍Janusgraph的锁机制，其他的实现机制就不在此做详解了</p></blockquote><p>下面我们来分析一下<code>JanusGraph</code>的<code>锁机制</code>实现~</p><h2 id="二：JanusGraph锁机制"><a href="#二：JanusGraph锁机制" class="headerlink" title="二：JanusGraph锁机制"></a>二：JanusGraph锁机制</h2><p>在JanusGraph中使用的锁机制是：<code>本地锁</code> + <code>分布式锁</code>来实现的；</p><h3 id="2-1-一致性行为"><a href="#2-1-一致性行为" class="headerlink" title="2.1 一致性行为"></a>2.1 一致性行为</h3><p>在<code>JanusGraph</code>中主要有三种<code>一致性修饰词(Consistency Modifier)</code>来表示3种不同的<code>一致性行为</code>，来控制图库使用过程中的并发问题的控制程度；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConsistencyModifier</span> </span>&#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LOCK,</span><br><span class="line">    FORK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中<code>ConsistencyModifier</code>枚举类主要作用：用于控制JanusGraph在<code>最终一致或其他非事务性后端系统</code>上的一致性行为！其作用分别为：</p><ul><li><strong>DEFAULT</strong>：默认的一致性行为，不使用分布式锁进行控制，对配置的存储后端使用由封闭事务保证的默认一致性模型，一致性行为主要取决于存储后端的配置以及封闭事务的（可选）配置；无需显示配置即可使用</li><li><strong>LOCK</strong>：在存储后端支持锁的前提下，显示的获取分布式锁以保证一致性！确切的一致性保证取决于所配置的锁实现；需<code>management.setConsistency(element, ConsistencyModifier.LOCK);</code>语句进行配置</li><li><strong>FORK</strong>：只适用于<code>multi-edges</code>和<code>list-properties</code>两种情况下使用；使JanusGraph修改数据时，采用先删除后添加新的边/属性的方式，而不是覆盖现有的边/属性，从而避免潜在的并发写入冲突；需<code>management.setConsistency(element, ConsistencyModifier.FORK);</code>进行配置</li></ul><h4 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h4><p>在查询或者插入数据时，是否使用<code>分布式锁</code>进行并发控制，在图<code>shcema</code>的创建过程中，如上述可以通过配置<code>schema元素</code>为<code>ConsistencyModifier.LOCK</code>方式控制并发，则在使用过程中就会用<code>分布式锁</code>进行并发控制；</p><p>为了提高效率，JanusGraph默认不使用锁定。 因此，用户必须为定义<code>一致性约束</code>的每个架构元素决定是否使用锁定。</p><p>使用<code>JanusGraphManagement.setConsistency（element，ConsistencyModifier.LOCK）</code>显式启用对架构元素的锁定</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mgmt = graph.openManagement() </span><br><span class="line">name = mgmt.makePropertyKey(<span class="string">&#x27;consistentName&#x27;</span>).dataType(String.class).make() </span><br><span class="line">index = mgmt.buildIndex(<span class="string">&#x27;byConsistentName&#x27;</span>, Vertex.class).addKey(name).unique().buildCompositeIndex() </span><br><span class="line">mgmt.setConsistency(name, ConsistencyModifier.LOCK) <span class="comment">// Ensures only one name per vertex </span></span><br><span class="line">mgmt.setConsistency(index, ConsistencyModifier.LOCK) <span class="comment">// Ensures name uniqueness in the graph </span></span><br><span class="line">mgmt.commit()</span><br></pre></td></tr></table></figure><h4 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h4><p>由于边缘作为单个记录存储在基础存储后端中，因此同时修改单个边缘将导致冲突。</p><p><code>FORK</code>就是为了代替<code>LOCK</code>，可以将边缘标签配置为使用<code>ConsistencyModifier.FORK</code>。</p><p>下面的示例创建一个新的edge label，并将其设置为<code>ConsistencyModifier.FORK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mgmt = graph.openManagement() </span><br><span class="line">related = mgmt.makeEdgeLabel(<span class="string">&#x27;related&#x27;</span>).make() </span><br><span class="line">mgmt.setConsistency(related, ConsistencyModifier.FORK) </span><br><span class="line">mgmt.commit()</span><br></pre></td></tr></table></figure><p>经过上述配置后，修改标签配置为<code>FORK</code>的edge时，操作步骤为：</p><ol><li>首先，删除该边</li><li>将修改后的边作为新边添加</li></ol><p>因此，如果两个并发事务修改了同一边缘，则提交时将存在边缘的两个修改后的副本，可以在查询遍历期间根据需要解决这些副本。</p><p>注意edge fork仅适用于MULTI edge。 具有多重性约束的边缘标签不能使用此策略，因为非MULTI的边缘标签定义中内置了一个唯一性约束，该约束需要显式锁定或使用基础存储后端的冲突解决机制</p><p>下面我们具体来看一下<code>janusgrph</code>的<code>锁机制</code>的实现：</p><h3 id="2-2-LoackID"><a href="#2-2-LoackID" class="headerlink" title="2.2 LoackID"></a>2.2 LoackID</h3><p>在介绍锁机制之前，先看一下锁应该锁什么东西呢？</p><p>我们都知道在<code>janusgraph</code>的底层存储中，vertexId作为Rowkey，属性和边存储在cell中，由column+value组成</p><p>当我们修改<code>节点的属性和边</code>+<code>边的属性时</code>，很明显只要锁住对应的<code>Rowkey + Column</code>即可；</p><p>在<code>Janusgraph</code>中，这个锁的标识的基础部分就是<code>LockID</code>：</p><blockquote><p>LockID = RowKey + Column</p></blockquote><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeyColumn lockID = <span class="keyword">new</span> KeyColumn(key, column);</span><br></pre></td></tr></table></figure><h3 id="2-3-本地锁"><a href="#2-3-本地锁" class="headerlink" title="2.3 本地锁"></a>2.3 本地锁</h3><p><code>本地锁</code>是在任何情况下都需要获取的一个锁，只有获取成功后，才会进行下述<code>分布式锁</code>的获取！</p><p><code>本地锁</code>是基于<code>图实例</code>维度存在的；主要作用是保证当前图实例下的操作中无冲突！</p><p>本地锁的实现是通过<code>ConcurrentHashMap</code>数据结构来实现的，在图实例维度下唯一；</p><p>基于当前<code>事务</code>+<code>lockId</code>来作为<code>锁标识</code>；</p><p><strong>获取的主要流程：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9e6da024452de3eb2ac72cc15d8daf60.png" alt="image-20200810170411991"></p><p><strong>结合源码如下：</strong></p><p>上述图建议依照源码一块分析，源码在<code>LocalLockMediator</code>类中的下述方法，下面<code>源码分析模块</code>会详细分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(KeyColumn kc, T requester, Instant expires)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入本地锁机制，主要目的：</strong> 在图实例维度来做一层锁判断，<code>减少分布式锁的并发冲突</code>，减少分布式锁带来的性能消耗</p><h3 id="2-4-分布式锁"><a href="#2-4-分布式锁" class="headerlink" title="2.4 分布式锁"></a>2.4 分布式锁</h3><p>在<code>本地锁</code>获取成功之后才会去尝试获取<code>分布式锁</code>；</p><p>分布式锁的获取整体分为两部分流程：</p><ol><li><code>分布式锁信息插入</code></li><li><code>分布式锁信息状态判断</code></li></ol><h4 id="分布式锁信息插入"><a href="#分布式锁信息插入" class="headerlink" title="分布式锁信息插入"></a>分布式锁信息插入</h4><p>该部分主要是通过<code>lockID</code>来构造要插入的<code>Rowkey和column</code>并将数据插入到<code>hbase</code>中；插入成功即表示这部分处理成功！</p><p>具体流程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c7d2707674f5b8029da1f146350cdf91.png" alt="2"></p><h4 id="分布式锁信息状态判断"><a href="#分布式锁信息状态判断" class="headerlink" title="分布式锁信息状态判断"></a>分布式锁信息状态判断</h4><p>该部分在上一部分完成之后才会进行，主要是判断分布式锁是否获取成功！</p><p>查询出当前hbase中对应<code>Rowkey的所有column</code>，过滤未过期的column集合，比对集合的第一个column是否等于当前事务插入的column；</p><p>等于则获取成功！不等于则获取失败！</p><p>具体流程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e335e5d11f814fd448ce065fa20dce9e.png" alt="3"></p><h2 id="三：源码分析-与-整体流程"><a href="#三：源码分析-与-整体流程" class="headerlink" title="三：源码分析 与 整体流程"></a>三：源码分析 与 整体流程</h2><p>源码分析已经push到github：<a target="_blank" rel="noopener" href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p><p><strong>1、获取锁的入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(StaticBuffer key, StaticBuffer column, StaticBuffer expectedValue, StoreTransaction txh)</span> <span class="keyword">throws</span> BackendException </span>&#123;</span><br><span class="line">    <span class="comment">// locker是一个一致性key锁对象</span></span><br><span class="line">    <span class="keyword">if</span> (locker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前事务对象</span></span><br><span class="line">        ExpectedValueCheckingTransaction tx = (ExpectedValueCheckingTransaction) txh;</span><br><span class="line">        <span class="comment">// 判断：当前的获取锁操作是否当前事务的操作中存在增删改的操作</span></span><br><span class="line">        <span class="keyword">if</span> (tx.isMutationStarted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(<span class="string">&quot;Attempted to obtain a lock after mutations had been persisted&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用key+column组装为lockID，供下述加锁使用！！！！！</span></span><br><span class="line">        KeyColumn lockID = <span class="keyword">new</span> KeyColumn(key, column);</span><br><span class="line">        log.debug(<span class="string">&quot;Attempting to acquireLock on &#123;&#125; ev=&#123;&#125;&quot;</span>, lockID, expectedValue);</span><br><span class="line">        <span class="comment">// 获取本地当前jvm进程中的写锁（看下述的 1：写锁获取分析）</span></span><br><span class="line">        <span class="comment">// （此处的获取锁只是将对应的KLV存储到Hbase中！存储成功并不代表获取锁成功）</span></span><br><span class="line">        <span class="comment">// 1. 获取成功（等同于存储成功）则继续执行</span></span><br><span class="line">        <span class="comment">// 2. 获取失败（等同于存储失败），会抛出异常，抛出到最上层，打印错误日志“Could not commit transaction [&quot;+transactionId+&quot;] due to exception” 并抛出对应的异常，本次插入数据结束</span></span><br><span class="line">        locker.writeLock(lockID, tx.getConsistentTx());</span><br><span class="line">        <span class="comment">// 执行前提：上述获取锁成功！</span></span><br><span class="line">        <span class="comment">// 存储期望值，此处为了实现当相同的key + value + tx多个加锁时，只处理第一个</span></span><br><span class="line">        <span class="comment">// 存储在事务对象中，标识在commit判断锁是否获取成功时，当前事务插入的是哪个锁信息</span></span><br><span class="line">        tx.storeExpectedValue(<span class="keyword">this</span>, lockID, expectedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// locker为空情况下，直接抛出一个运行时异常，终止程序</span></span><br><span class="line">        store.acquireLock(key, column, expectedValue, unwrapTx(txh));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行 locker.writeLock(lockID, tx.getConsistentTx()) 触发锁获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">(KeyColumn lockID, StoreTransaction tx)</span> <span class="keyword">throws</span> TemporaryLockingException, PermanentLockingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != tx.getConfiguration().getGroupName()) &#123;</span><br><span class="line">        MetricManager.INSTANCE.getCounter(tx.getConfiguration().getGroupName(), M_LOCKS, M_WRITE, M_CALLS).inc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前事务是否在图实例的维度 已经占据了lockID的锁</span></span><br><span class="line">    <span class="comment">// 此处的lockState在一个事务成功获取本地锁+分布式锁后，以事务为key、value为map，其中key为lockID，value为加锁状态（开始时间、过期时间等）</span></span><br><span class="line">    <span class="keyword">if</span> (lockState.has(tx, lockID)) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Transaction &#123;&#125; already wrote lock on &#123;&#125;&quot;</span>, tx, lockID);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前事务没有占据lockID对应的锁</span></span><br><span class="line">    <span class="comment">// 进行(lockLocally(lockID, tx） 本地加锁锁定操作，</span></span><br><span class="line">    <span class="keyword">if</span> (lockLocally(lockID, tx)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在本地锁获取成功的前提下：</span></span><br><span class="line">            <span class="comment">// 尝试获取基于Hbase实现的分布式锁；</span></span><br><span class="line">            <span class="comment">// 注意！！！（此处的获取锁只是将对应的KLV存储到Hbase中！存储成功并不代表获取锁成功）</span></span><br><span class="line">            S stat = writeSingleLock(lockID, tx);</span><br><span class="line">            <span class="comment">// 获取锁分布式锁成功后（即写入成功后），更新本地锁的过期时间为分布式锁的过期时间</span></span><br><span class="line">            lockLocally(lockID, stat.getExpirationTimestamp(), tx); <span class="comment">// update local lock expiration time</span></span><br><span class="line">            <span class="comment">// 将上述获取的锁，存储在标识当前存在锁的集合中Map&lt;tx,Map&lt;lockID,S&gt;&gt;，  key为事务、value中的map为当前事务获取的锁，key为lockID，value为当前获取分布式锁的ConsistentKeyStatus（一致性密匙状态）对象</span></span><br><span class="line">            lockState.take(tx, lockID, stat);</span><br><span class="line">            ok = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TemporaryBackendException tse) &#123;</span><br><span class="line">            <span class="comment">// 在获取分布式锁失败后，捕获该异常，并抛出该异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryLockingException(tse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AssertionError ae) &#123;</span><br><span class="line">            <span class="comment">// Concession to ease testing with mocks &amp; behavior verification</span></span><br><span class="line">            ok = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> ae;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 出现底层存储错误！ 则直接加锁失败！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否成功获取锁，没有获分布式锁的，则释放本地锁</span></span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                <span class="comment">// 没有成功获取锁，则释放本地锁</span></span><br><span class="line">                <span class="comment">// lockState.release(tx, lockID); // has no effect</span></span><br><span class="line">                unlockLocally(lockID, tx);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tx.getConfiguration().getGroupName()) &#123;</span><br><span class="line">                    MetricManager.INSTANCE.getCounter(tx.getConfiguration().getGroupName(), M_LOCKS, M_WRITE, M_EXCEPTIONS).inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取本地锁失败，则直接抛出异常，不进行重新本地争用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fail immediately with no retries on local contention</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(<span class="string">&quot;Local lock contention&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含两个部分：</p><ol><li>本地锁的获取<code>lockLocally(lockID, tx)</code></li><li>分布式锁的获取<code>writeSingleLock(lockID, tx)</code> 注意此处只是将锁信息写入到Hbase中，并不代表获取分布式锁成功，只是做了上述介绍的第一个阶段<code>分布式锁信息插入</code></li></ol><p><strong>3、本地锁获取 <code>lockLocally(lockID, tx)</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(KeyColumn kc, T requester, Instant expires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> <span class="keyword">null</span> != kc;</span><br><span class="line">      <span class="keyword">assert</span> <span class="keyword">null</span> != requester;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> StackTraceElement[] acquiredAt = log.isTraceEnabled() ?</span><br><span class="line">              <span class="keyword">new</span> Throwable(<span class="string">&quot;Lock acquisition by &quot;</span> + requester).getStackTrace() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// map的value，以事务为核心</span></span><br><span class="line">      <span class="keyword">final</span> AuditRecord&lt;T&gt; audit = <span class="keyword">new</span> AuditRecord&lt;&gt;(requester, expires, acquiredAt);</span><br><span class="line">      <span class="comment">//  ConcurrentHashMap实现locks, 以lockID为key，事务为核心value</span></span><br><span class="line">      <span class="keyword">final</span> AuditRecord&lt;T&gt; inMap = locks.putIfAbsent(kc, audit);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 代表当前map中不存在lockID，标识着锁没有被占用，成功获取锁</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == inMap) &#123;</span><br><span class="line">          <span class="comment">// Uncontended lock succeeded</span></span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;New local lock created: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125;&quot;</span>,</span><br><span class="line">                  kc, name, requester);</span><br><span class="line">          &#125;</span><br><span class="line">          success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inMap.equals(audit)) &#123;</span><br><span class="line">          <span class="comment">// 代表当前存在lockID，比对旧value和新value中的事务对象是否是同一个</span></span><br><span class="line">          <span class="comment">// requester has already locked kc; update expiresAt</span></span><br><span class="line">          <span class="comment">// 上述判断后，事务对象为同一个，标识当前事务已经获取这个lockID的锁；</span></span><br><span class="line">          <span class="comment">// 1. 这一步进行cas替换，作用是为了刷新过期时间</span></span><br><span class="line">          <span class="comment">// 2. 并发处理，如果因为锁过期被其他事务占据，则占用锁失败</span></span><br><span class="line">          success = locks.replace(kc, inMap, audit);</span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                  log.trace(<span class="string">&quot;Updated local lock expiration: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; oldexp=&#123;&#125; newexp=&#123;&#125;&quot;</span>,</span><br><span class="line">                      kc, name, requester, inMap.expires, audit.expires);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.trace(<span class="string">&quot;Failed to update local lock expiration: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; oldexp=&#123;&#125; newexp=&#123;&#125;&quot;</span>,</span><br><span class="line">                      kc, name, requester, inMap.expires, audit.expires);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &gt; inMap.expires.compareTo(times.getTime())) &#123;</span><br><span class="line">          <span class="comment">// 比较过期时间，如果锁已经过期，则当前事务可以占用该锁</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// the recorded lock has expired; replace it</span></span><br><span class="line">          <span class="comment">// 1. 当前事务占用锁</span></span><br><span class="line">          <span class="comment">// 2. 并发处理，如果因为锁过期被其他事务占据，则占用锁失败</span></span><br><span class="line">          success = locks.replace(kc, inMap, audit);</span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;Discarding expired lock: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; expired=&#123;&#125;&quot;</span>,</span><br><span class="line">                  kc, name, inMap.holder, inMap.expires);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 标识：锁被其他事务占用，并且未过期，则占用锁失败</span></span><br><span class="line">          <span class="comment">// we lost to a valid lock</span></span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;Local lock failed: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; (already owned by &#123;&#125;)&quot;</span>,</span><br><span class="line">                  kc, name, requester, inMap);</span><br><span class="line">              log.trace(<span class="string">&quot;Owner stacktrace:\n        &#123;&#125;&quot;</span>, Joiner.on(<span class="string">&quot;\n        &quot;</span>).join(inMap.acquiredAt));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上述介绍，本地锁的实现是通过<code>ConcurrentHashMap</code>数据结构来实现的，在图实例维度下唯一！</p><p><strong>4、分布式锁获取第一个阶段：分布式锁信息插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConsistentKeyLockStatus <span class="title">writeSingleLock</span><span class="params">(KeyColumn lockID, StoreTransaction txh)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装插入hbase数据的Rowkey</span></span><br><span class="line">    <span class="keyword">final</span> StaticBuffer lockKey = serializer.toLockKey(lockID.getKey(), lockID.getColumn());</span><br><span class="line">    StaticBuffer oldLockCol = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尝试插入 ，默认尝试次数3次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lockRetryCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 尝试将数据插入到hbase中；oldLockCol表示要删除的column代表上一次尝试插入的数据</span></span><br><span class="line">        WriteResult wr = tryWriteLockOnce(lockKey, oldLockCol, txh);</span><br><span class="line">        <span class="comment">// 如果插入成功</span></span><br><span class="line">        <span class="keyword">if</span> (wr.isSuccessful() &amp;&amp; wr.getDuration().compareTo(lockWait) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Instant writeInstant = wr.getWriteTimestamp(); <span class="comment">// 写入时间</span></span><br><span class="line">            <span class="keyword">final</span> Instant expireInstant = writeInstant.plus(lockExpire);<span class="comment">// 过期时间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConsistentKeyLockStatus(writeInstant, expireInstant); <span class="comment">// 返回插入对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值当前的尝试插入的数据，要在下一次尝试时删除</span></span><br><span class="line">        oldLockCol = wr.getLockCol();</span><br><span class="line">        <span class="comment">// 判断插入失败原因，临时异常进行尝试，非临时异常停止尝试！</span></span><br><span class="line">        handleMutationFailure(lockID, lockKey, wr, txh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理在尝试了3次之后还是没插入成功的情况，删除最后一次尝试插入的数据</span></span><br><span class="line">    tryDeleteLockOnce(lockKey, oldLockCol, txh);</span><br><span class="line">    <span class="comment">// TODO log exception or successful too-slow write here</span></span><br><span class="line">    <span class="comment">// 抛出异常，标识导入数据失败</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryBackendException(<span class="string">&quot;Lock write retry count exceeded&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述只是将锁信息插入，插入成功标识该流程结束</p><p><strong>5、分布式锁获取第一个阶段：分布式锁锁定是否成功判定</strong></p><p>这一步，是在<code>commit</code>阶段进行的验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> BackendException </span>&#123;</span><br><span class="line">    <span class="comment">// 此方法内调用checkSingleLock 检查分布式锁的获取结果</span></span><br><span class="line">    flushInternal();</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>checkSingleLock</code>方法，判断获取锁的状态！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkSingleLock</span><span class="params">(<span class="keyword">final</span> KeyColumn kc, <span class="keyword">final</span> ConsistentKeyLockStatus ls,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> StoreTransaction tx)</span> <span class="keyword">throws</span> BackendException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否被检查过</span></span><br><span class="line">    <span class="keyword">if</span> (ls.isChecked())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice the store</span></span><br><span class="line">    KeySliceQuery ksq = <span class="keyword">new</span> KeySliceQuery(serializer.toLockKey(kc.getKey(), kc.getColumn()), LOCK_COL_START,</span><br><span class="line">        LOCK_COL_END);</span><br><span class="line">    <span class="comment">// 此处从hbase中查询出锁定的行的所有列！ 默认查询重试次数3</span></span><br><span class="line">    List&lt;Entry&gt; claimEntries = getSliceWithRetries(ksq, tx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从每个返回条目的列中提取timestamp和rid，然后过滤出带有过期时间戳的timestamp对象</span></span><br><span class="line">    <span class="keyword">final</span> Iterable&lt;TimestampRid&gt; iterable = Iterables.transform(claimEntries,</span><br><span class="line">        e -&gt; serializer.fromLockColumn(e.getColumnAs(StaticBuffer.STATIC_FACTORY), times));</span><br><span class="line">    <span class="keyword">final</span> List&lt;TimestampRid&gt; unexpiredTRs = <span class="keyword">new</span> ArrayList&lt;&gt;(Iterables.size(iterable));</span><br><span class="line">    <span class="keyword">for</span> (TimestampRid tr : iterable) &#123; <span class="comment">// 过滤获取未过期的锁！</span></span><br><span class="line">        <span class="keyword">final</span> Instant cutoffTime = now.minus(lockExpire);</span><br><span class="line">        <span class="keyword">if</span> (tr.getTimestamp().isBefore(cutoffTime)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将还未过期的锁记录存储到一个集合中</span></span><br><span class="line">        unexpiredTRs.add(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前tx是否成功持有锁！ 如果我们插入的列是读取的第一个列，或者前面的列只包含我们自己的rid（因为我们是在第一部分的前提下获取的锁，第一部分我们成功获取了基于当前进程的锁，所以如果rid相同，代表着我们也成功获取到了当前的分布式锁），那么我们持有锁。否则，另一个进程持有该锁，我们无法获得锁</span></span><br><span class="line">    <span class="comment">// 如果，获取锁失败，抛出TemporaryLockingException异常！！！！ 抛出到顶层的mutator.commitStorage()处，最终导入失败进行事务回滚等操作</span></span><br><span class="line">    checkSeniority(kc, ls, unexpiredTRs);</span><br><span class="line">    <span class="comment">// 如果上述步骤未抛出异常，则标识当前的tx已经成功获取锁！</span></span><br><span class="line">    ls.setChecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：整体流程"><a href="#四：整体流程" class="headerlink" title="四：整体流程"></a>四：整体流程</h2><p>总流程如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/257a9bbcc1110d06a8f52ce09906cd16.png" alt="4"></p><p><strong>整体流程为：</strong></p><ol><li>获取本地锁</li><li>获取分布式锁<ol><li>插入分布式锁信息</li><li>commit阶段判断分布式锁获取是否成功</li></ol></li><li>获取失败，则重试</li></ol><h2 id="五：总结"><a href="#五：总结" class="headerlink" title="五：总结"></a>五：总结</h2><p>JanusGraph的锁机制主要是通过<code>本地锁+分布式锁</code>来实现分布式系统下的数据一致性；</p><p>分布式锁的控制维度为：property、vertex、edge、index都可以；</p><p><code>JanusGraph</code>支持在数据导入时通过前面<code>一致性行为</code>部分所说的<code>LOCK</code>来开关分布式锁：</p><ul><li>LOCK：数据导入时开启分布式锁保证分布式一致性</li><li>DEFAULT、FORK：数据导入时关闭分布式锁</li></ul><p><strong>是否开启分布式锁思考：</strong></p><p>在开启分布式锁的情况下，数据导入开销非常大；如果是数据不是要求很高的一致性，并且数据量比较大，我们可以选择关闭分布式锁相关，来提高导入速度；</p><p>然后，针对于小数据量的要求高一致性的数据，单独开启分布式锁来保证数据安全；</p><p>另外，我们在不开启分布式锁定的情况下，可以通过针对于导入的<code>数据的充分探查</code>来减少冲突！</p><p>针对于图schema的元素开启还是关闭分布式锁，还是根据实际业务情况来决定。</p><blockquote><p>本文有任何问题，可加博主微信或评论指出，感谢！</p><p>码文不易，给个赞和star吧~</p></blockquote></div><div class="article-licensing box"><div class="licensing-title"><p>图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析</p><p><a href="http://coderstudy.vip/2021/03/03/图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析.html">http://coderstudy.vip/2021/03/03/图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>洋仔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/JanusGraph/">JanusGraph</a></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-603e216abef49db8" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/03/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E5%85%B3%E4%BA%8EJanusGraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%83%B3%E6%B3%95%EF%BC%88bulk_load_data%EF%BC%89.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">图解JanusGraph系列 - 关于JanusGraph图数据批量快速导入的方案和想法（bulk load data）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/03/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-idea_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%ABjar%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AFpom%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E6%A0%87%E7%BA%A2.html"><span class="level-item">问题解决-idea 本地仓库中包含jar包，但是pom依赖文件标红</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="2021/03/03/图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析.html"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid:"cyvk3kK5A",conf:"prod_4d15c7a1b97dcc293442445086f1bcf4"})</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="http://images.coderstudy.vip/gzh-ewm.jpg" alt="Java小站"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Java小站</p><p class="is-size-6 is-block">以匠心-卓不凡</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China-BeiJing</span></p></div></div></nav><nav class="level is-mobile"><a class="level-item has-text-centered is-marginless" href="/categories"><div><p class="heading">文章</p><div><p class="title">23</p></div></div></a><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://images.coderstudy.vip/gzh-ewm.jpg" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yoylee"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="邮件" href="mailto:1591992570@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#图数据库文章总目录："><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">图数据库文章总目录：</span></span></a></li></ul></ul><li><a class="level is-mobile" href="#一：分布式锁"><span class="level-left"><span class="level-item">2</span><span class="level-item">一：分布式锁</span></span></a></li><li><a class="level is-mobile" href="#二：JanusGraph锁机制"><span class="level-left"><span class="level-item">3</span><span class="level-item">二：JanusGraph锁机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-一致性行为"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">2.1 一致性行为</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#LOCK"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">LOCK</span></span></a></li><li><a class="level is-mobile" href="#FORK"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">FORK</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-LoackID"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2.2 LoackID</span></span></a></li><li><a class="level is-mobile" href="#2-3-本地锁"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">2.3 本地锁</span></span></a></li><li><a class="level is-mobile" href="#2-4-分布式锁"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">2.4 分布式锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分布式锁信息插入"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">分布式锁信息插入</span></span></a></li><li><a class="level is-mobile" href="#分布式锁信息状态判断"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">分布式锁信息状态判断</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#三：源码分析-与-整体流程"><span class="level-left"><span class="level-item">4</span><span class="level-item">三：源码分析 与 整体流程</span></span></a></li><li><a class="level is-mobile" href="#四：整体流程"><span class="level-left"><span class="level-item">5</span><span class="level-item">四：整体流程</span></span></a></li><li><a class="level is-mobile" href="#五：总结"><span class="level-left"><span class="level-item">6</span><span class="level-item">五：总结</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MySql/"><span class="level-start"><span class="level-item">MySql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring%E7%B3%BB%E5%88%97/"><span class="level-start"><span class="level-item">Spring系列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">图数据库</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"><span class="level-start"><span class="level-item">问题解决</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">高并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JanusGraph/"><span class="tag">JanusGraph</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySql/"><span class="tag">MySql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring%E7%B3%BB%E5%88%97/"><span class="tag">Spring系列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/idea/"><span class="tag">idea</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="tag">二进制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"><span class="tag">代理模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"><span class="tag">动静态代理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><span class="tag">线程池</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:30.624Z">2021-03-03</time></p><p class="title"><a href="/2021/03/03/JanusGraph_-_data_model.html">图解图库JanusGraph系列-一文知晓“图数据“底层存储结构（JanusGraph data model）</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:17.818Z">2021-03-03</time></p><p class="title"><a href="/2021/03/03/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E5%85%B3%E4%BA%8EJanusGraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%83%B3%E6%B3%95%EF%BC%88bulk_load_data%EF%BC%89.html">图解JanusGraph系列 - 关于JanusGraph图数据批量快速导入的方案和想法（bulk load data）</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:27:08.629Z">2021-03-03</time></p><p class="title"><a href="/2021/03/03/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html">图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析</a></p><p class="categories"><a href="/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/">图数据库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:26:58.125Z">2021-03-03</time></p><p class="title"><a href="/2021/03/03/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-idea_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%ABjar%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AFpom%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E6%A0%87%E7%BA%A2.html">问题解决-idea 本地仓库中包含jar包，但是pom依赖文件标红</a></p><p class="categories"><a href="/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">问题解决</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-03T07:26:52.210Z">2021-03-03</time></p><p class="title"><a href="/2021/03/03/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%8C%E4%BB%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9D%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%BE%8E.html">编程之美，从线程池状态管理来看二进制操作之美</a></p><p class="categories"><a href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/yoylee" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">GitHub</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://liyangyang.blog.csdn.net/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liyangyang.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.jianshu.com/u/dabfb12677f1" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span><span class="level-right"><span class="level-item tag">www.jianshu.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/gzh-ewm.jpg" alt="Java小站" height="28"></a><p class="is-size-7"><span>&copy; 2021 洋仔</span>  备案号：鲁ICP备17056511号 &amp; <a href="http://coderstudy.vip" target="_blank" rel="noopener">coderstudy.vip</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"folded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script data-ad-client="ca-pub-6038794546438627" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></body></html>