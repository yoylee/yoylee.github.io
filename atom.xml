<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Java小站</title>
  
  <subtitle>匠心独具，全网好文</subtitle>
  <link href="http://coderstudy.vip/atom.xml" rel="self"/>
  
  <link href="http://coderstudy.vip/"/>
  <updated>2021-03-03T07:27:30.619Z</updated>
  <id>http://coderstudy.vip/</id>
  
  <author>
    <name>洋仔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解图库JanusGraph系列-一文知晓“图数据“底层存储结构（JanusGraph data model）</title>
    <link href="http://coderstudy.vip/article/JanusGraph_-_data_model.html"/>
    <id>http://coderstudy.vip/article/JanusGraph_-_data_model.html</id>
    <published>2021-03-03T07:27:30.624Z</published>
    <updated>2021-03-03T07:27:30.619Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细讲解了JanusGraph的存储结构！</p><p>大家好，我是洋仔，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（求star~~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="一：存储模式"><a href="#一：存储模式" class="headerlink" title="一：存储模式"></a>一：存储模式</h2><h3 id="1、图内容"><a href="#1、图内容" class="headerlink" title="1、图内容"></a>1、图内容</h3><p>本文以下所有内容基于：JanusGraph基于<code>属性图</code>来进行构造图数据：</p><p><strong>属性图：</strong> 属性图是由 顶点（Vertex），边（Edge），属性（Property）组成的有向图</p><p>Vertex可以包含Properties；Edge也可以包含Properties；</p><h3 id="2、存储方法"><a href="#2、存储方法" class="headerlink" title="2、存储方法"></a>2、存储方法</h3><p>图存储的方式常用的有两种：<code>邻接列表</code>  和 <code>邻接矩阵</code></p><p>JanusGraph采用<code>邻接列表</code>进行图数据的存储，如下图所示：（此处将图中节点抽象为 只有节点，没有属性）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b994eef98c31ccf9b891558cc565118e.png" alt="邻接列表"></p><p>在Janusgraph中一个顶点的邻接列表包含该节点对应的<code>属性</code>和<code>关联的边</code>，下述会详细说明 Janusgraph中邻接列表是如何实现的；</p><h3 id="3、图切割方式"><a href="#3、图切割方式" class="headerlink" title="3、图切割方式"></a>3、图切割方式</h3><p>图的切割方式分为两种：<code>按节点切割(Vertex Cut)</code>和<code>按边切割(Edge Cut)</code></p><ul><li>Vertex Cut：根据点进行切割，每个边只存储一次，只要是节点对应的边便会多一份该节点的存储</li><li>Edge Cut：根据边进行切割，以节点为中心，边会存储两次，源节点的邻接列表存储一次，目标节点的邻接列表存储一次</li></ul><p>在Janusgraph中既存在Edge Cut，也存在Vertex Cut的情况；</p><p>在默认的情况下使用<code>边切割</code>，而针对<code>热点</code>节点可以通过配置<code>makeVertexLabel(&#39;product&#39;).partition()</code>来将节点类型为<code>product</code>类型的节点进行<code>Vertex Cut</code>； </p><p>也就是说，在没有上述<code>makeVertexLabel(&#39;product&#39;).partition()</code>配置的话，JanusGraph所有的图数据都是以<code>Edge Cut</code>的方式来进行切割存储的；</p><p>具体可以查看文章：《JanusGraph-分区》中自定义分区部分中关于图切割部分的介绍；</p><p><strong>我们例子来说明一下：</strong></p><p>如下图： <code>张三</code>用户节点通过<code>手机号</code>关联出来<code>李四</code>用户节点</p><ul><li>张三 和 李四 代表Vertex；指向的name、age、gender代表张三的属性</li><li>edgeA 和edgeB 代表Edge；也可以包含边的属性，例如下图中边包含属性create_time</li></ul><p><img src="https://img-blog.csdnimg.cn/2020081410534974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>按边切割后：</p><table><thead><tr><th align="center">节点</th><th align="left"></th><th align="left"></th><th></th><th></th></tr></thead><tbody><tr><td align="center"><strong>张三</strong></td><td align="left">name(property)</td><td align="left">age(property)</td><td>gender(property)</td><td>edgeA(edge)</td></tr><tr><td align="center"><strong>phone</strong></td><td align="left">phone(property)</td><td align="left">edgeA(edge)</td><td>edgeB(edge)</td><td></td></tr><tr><td align="center"><strong>李四</strong></td><td align="left">name(property)</td><td align="left">age(property)</td><td>gender(property)</td><td>edgeB(edge)</td></tr></tbody></table><p>上述可以看到，按照边切割后每一条边会存储两次！</p><h2 id="二：BigTable模型"><a href="#二：BigTable模型" class="headerlink" title="二：BigTable模型"></a>二：BigTable模型</h2><blockquote><p>在JanusGraph的存储中，  JanusGraph将图形的邻接列表的表示存储在支持Bigtable数据模型的任何存储后端中</p></blockquote><p>BigTable模型如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200814105356896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在Bigtable数据模型中，每个表是行的集合，由一个key唯一标识。</p><p>每行由任意（可以很大数量但是必须有限数量）数量的cell组成；cell由column和value组成，column唯一标识某一个cell。</p><p>上述图中，有两部分需要排序的支持：<code>sorted by key</code> 和 <code>sorted by column</code>：</p><ul><li>sorted by key：标识存储后端存储的数据时按照key的大小进行排序存储的</li><li>sorted by column：这是JanusGraph对Bigtable数据模型有一个额外要求，存储<code>edge(边)</code>的单元格必须按column排序，并且列范围指定的单元格子集必须是有效可检索的； 这句话详细解答在下述文章中有体现</li></ul><p>在Bigtable模型中的行称为“宽行”，因为它们支持大量cell，并且不必像关系数据库中那样预先定义这些cell的column。</p><p>在关系型数据库中我们必须先定义好表的schema，才可以存储数据，如果存储过程中想要改变表结构，则所有的数据都要对变化的列做出变化。但是Bigtable模型存储中就不必如此，每个行的column不同，我们可以随时仅对某一行进行变化，也不许预先定义行的schema，只需要定义图的schema即可。</p><p>此外，特定的Bigtable实现可以使行按其键的顺序排序。JanusGraph可以利用这样的键序来有效地划分图形，从而为非常大的图形提供更好的加载和遍历性能。</p><p><strong>JanusGraph是如何基于BigTable数据模型针对于自身的图数据特性进行设计的呢？</strong></p><p>下面我们看下JanusGraph的逻辑存储结构</p><h2 id="三：存储逻辑结构"><a href="#三：存储逻辑结构" class="headerlink" title="三：存储逻辑结构"></a>三：存储逻辑结构</h2><blockquote><p>JanusGraph基于使用BigTable模型的存储后端 实现了自己的存储的逻辑结构</p><p>ps：为了更好的理解，下面部分知识点会基于HBase存储后端进行进一步的解释！</p></blockquote><h3 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h3><p><img src="https://img-blog.csdnimg.cn/20200814105407558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在JanusGraph中，以节点为中心，按切边的方式存储数据的。比如在Hbase中节点的ID作为HBase的Rowkey，节点上的每一个属性和每一条边，作为该Rowkey行的一个个独立的Cell。即每一个属性、每一条边，都是一个个独立的KCV结构(Key-Column-Value)</p><p>上图中，我们可以发现图的存储整体分为三部分：<code>vertex id</code>、<code>property</code>、<code>edge</code>：</p><ul><li><p><strong>vertex id：</strong> 对应节点的唯一id，如果底层存储使用的是Hbase则代表着当前行的Rowkey，唯一代表某一个节点</p></li><li><p><strong>property：</strong> 代表节点的属性</p></li><li><p><strong>edge：</strong> 代表节点的对应的边</p></li></ul><p>排序方式分为三种：<code>sorted by id</code>、<code>sorted by type</code>、<code>sorted by sort key</code>：</p><ul><li><p><strong>sorted by id：</strong> 依据vertex id在存储后端进行顺序存储</p></li><li><p><strong>sorted by type</strong>：此处的个人理解为针对于property 和 edge的类型进行排序，保证同种类型的属性或者边连续存储在一块便于遍历查找；  // TODO 深层次理解</p></li><li><p><strong>sorted by sort key：</strong> sort key是边组成以的一部分，主要作用是，在同种类型的edge下，针对于sort key进行排序存储，提升针对于指定sort key的检索速度；下面<code>edge结构</code>部分有详细介绍</p></li></ul><h3 id="2、Vertex-id-的结构"><a href="#2、Vertex-id-的结构" class="headerlink" title="2、Vertex id 的结构"></a>2、Vertex id 的结构</h3><p>此处的<code>Vertex id</code>唯一标识图中的某一个节点；节点vertex id的组成结构我们在源码类<code>IDManager</code>的一段注释中可以发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--- JanusGraphElement id bit format ---</span></span><br><span class="line"><span class="comment"> *  [ 0 | count | partition | ID padding (if any) ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这是在Janusgraph在生成所有的id时统一的格式包含vertex id\edge id\property id的时候，这个顺序也 就是标识我们再使用gremlin查询出节点时，节点上标识的vertex id；  <em>这个id值的顺序不同于hbase真实存储Rowkey的顺序！！！！！！！</em></p><p>在对vertex id进行序列化存储时，位置有所调整为：<code>[ partition | 0 | count | ID padding (if any) ]</code> 如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200814105417507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>从图中可以看出：</p><ol><li><p>Vertex ID共包含一个字节、8位、64个bit</p></li><li><p>Vertex ID由partition id、count、ID padding三部分组成</p></li><li><p>最高位5个bit是partition id。partition是JanusGraph抽象出的一个概念。当Storage Backend是HBase时，JanusGraph会根据partition数量，自动计算并配置各个HBase Region的split key，从而将各个partition均匀映射到HBase的多个Region中。然后通过均匀分配partition id最终实现数据均匀打散到Storage Backend的多台机器中</p></li><li><p>中间的count部分是流水号，其中最高位比特固定为0；出去最高位默认的0，count的最大值为2的(64-5-1-3)=55次幂大小：3 6028 7970 1896 3968，总共可以生成30000兆个id，完全满足节点的生成</p></li><li><p>最后几个bit是ID padding, 表示Vertex的类型。具体的位数长度根据不同的Vertex类型而不同。最常用的普通Vertex，其值为’000’</p></li></ol><p><strong>为什么在序列化存储<code>vertex id</code>时，需要调整顺序序列化作为RowKey存储到Hbase呢？</strong></p><p>我们通过下面的3个问题来回答：</p><ol><li><strong>为什么JausGraph分配的逻辑区间值，可以影响hbase物理存储呢？ 可以将分区相同的数据存放的更近呢？</strong></li></ol><blockquote><p>在上述描述中，hbase使用vertex id作为rowkey，hbase根据rowkey顺序排序存储； 每个<code>hbase region</code>存储是一段连续的Rowkey行；</p><p>在<code>janusgraph的vertex id</code>的设计中，可以发现将分区值放到了64位的前5位存储！  在存储数据到hbase时，对rowkey进行排序，因为<code>partition id</code>在前5位，所以同一个分区的<code>vertex id</code>对应的rowkey值相差较小，所以会存储在一块；</p></blockquote><ol start="2"><li><strong>如何快速的查询到不同类型的节点呢？ 换个说法如何快速的确定当前的行就是我们需要的节点类型的行呢？</strong></li></ol><blockquote><p>在JanusGraph的vertex id中包含的 ID padding就代表当前的节点类型（注意此处的类型！=lable）。000标识为普通节点，在id的组成部分中，我们经过前面的分析，最前面是partition id，只有把 ID padding放在最后几个字节便于查找了；</p></blockquote><ol start="3"><li><strong>为什么查询出的节点显示的vertex id要把<code>0|count</code>放在最前面、<code>partiton和id padding</code>放在后面呢？</strong></li></ol><blockquote><p>这里我们猜测一下：count占用55位数据！  试想如果把count不放在最前面，那么id的最小值比2的55次幂还大，显示不友好！ 如果把0|count放在最前面呢？就会有两个效果：</p><p>0在有符号表示中标识当前id始终为正整数！</p><p>count是趋势递增的，所以id值也是从小到大趋势递增的，所以节点id的最小值在2的8次幂周边大小； 比把count放在后面显示的id值友好多了~~~</p></blockquote><p><strong>vertex id是如何保证全局唯一性的呢？</strong>  </p><p>主要是基于<code>数据库 + 号段</code>模式进行分布式id的生成；</p><p>体现在图中就是<code>partition id + count</code> 来保证分布式全局唯一性；  针对不同的<code>partition</code>都有自己的0-2的55次幂的范围的id； 每次要生成vertex id时，首先获取一个partition，获取对应partition对应的一组还未使用的id，用来做count；</p><p>janusgraph在底层存储中存储了对应的partition使用了多少id，从而保证了再生成新的分布式vertex id时，不会重复生成！</p><p>ps ： JanusGraph中分布式唯一vertex id、edge id、property id的生成分析，请看《图解JanusGraph系列-分布式唯一id的生成机制》</p><h3 id="3、edge-和-property的结构"><a href="#3、edge-和-property的结构" class="headerlink" title="3、edge 和 property的结构"></a>3、edge 和 property的结构</h3><p>在上述的JanusGraph的整体结构中，<code>property</code>和<code>edge</code>都是作为<code>cell</code>存储在底层存储中；其中cell又分为<code>column</code>和<code>value</code>两部分，下图展示了这两部分的逻辑结构：</p><p><img src="https://img-blog.csdnimg.cn/20200814105516189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>下面我们详细分析一下 property 和 edge对应的逻辑结构；</p><h4 id="3-1-edge的结构"><a href="#3-1-edge的结构" class="headerlink" title="3.1 edge的结构"></a>3.1 edge的结构</h4><p><strong>Edge的Column组成部分：</strong></p><ul><li>label id：边类型代表的id，在创建图schema的时候janusgraph自动生成的label id，不同于边生成的唯一全局id</li><li>direction：图的方向，out：0、in：1</li><li>sort key：可以指定边的属性为sort key，可多个；在同种类型的edge下，针对于sort key进行排序存储，提升针对于指定sort key的检索速度；<ul><li>该key中使用的关系类型必须是属性非唯一键或非唯一单向边标签；</li><li>存储的为配置属性的value值，可多个（只存property value是因为，已经在schema的配置中保存有当前Sort key对应的属性key了，所以没有必要再存一份）</li></ul></li><li>adjacent vertex id：target节点的节点id，其实存储的是目标节点id和源节点id的差值，这也可以减少存储空间的使用</li><li>edge id：边的全局唯一id</li></ul><p><strong>Edge的value组成部分：</strong></p><ul><li>signature key：边的签名key<ul><li>该key中使用的关系类型必须是属性非唯一键或非唯一单向边标签；</li><li>存储压缩后的配置属性的value值，可多个（只存property value是因为，已经在schema的配置中保存有当前signature key对应的属性key了，所以没有必要再存一份）</li><li>主要作用提升edge的属性的检索速度，将常用检索的属性设置为signature key，提升查找速度</li></ul></li><li>other properties：边的其他属性<ul><li>注意！ 不包含配置的sort key和signature key属性值，因为他们已经在对应的位置存储过了，不需要多次存储！  </li><li>此处的属性，要插入属性key label id和属性value来标识是什么属性，属性值是什么；</li><li>此处的property的序列化结构不同于下述所说的vertex节点的property结构，edge中<code>other properties</code>这部分存储的属性只包含：proeprty key label id + property value；不包含<code>property全局唯一id</code>！</li></ul></li></ul><p><strong>详细解释及思考：</strong></p><p>在进行详细分析前，请大家思考几个问题，如下:</p><ol><li>基于上述的edge逻辑结构，JanusGraph是如何构造邻接列表的 或者 是如何获取源节点的邻接节点的？</li><li>上述的Edge逻辑结构中的，每部分的排列的顺序的含义是什么？</li></ol><p><strong><em>1、基于上述的edge逻辑结构，JanusGraph是如何构造邻接列表的 或者 是如何获取源节点的邻接节点的？</em></strong></p><p>从上述的<code>整体结构</code>部分中，我们可以知道，vertexId行后跟着当前的节点关联的所有的edge；</p><p>而在上述的<code>edge</code>的逻辑结构中，有一个<code>adjacent vertex id</code>字段，通过这个字段就可以获取到target节点的vertex id，就相当于指向了target节点，整理一下：</p><p><img src="https://img-blog.csdnimg.cn/20200814105526807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如上图，通过上述的条件，就可以构造一个VertexA指向VertexB 和 VertexC的邻接链表；</p><p>其实，JanusGraph可以理解为构造的是<code>双向邻接列表</code>， 依据上图，我们知道vertexA 和 vertexB 和 vertexC存在边关系； 当我们构造vertexB的邻接列表时，会包含指向vertexA的节点，只是说在edge对应的逻辑结构中边的方向不同而已：</p><p><img src="https://img-blog.csdnimg.cn/20200814105533297.png#pic_center" alt="在这里插入图片描述"></p><p>总结：JanusGraph通过vertex id行中包含所有关联的edge，edge逻辑结构中包含指向target节点的数据来组成双向邻接列表的结构；</p><p><strong>2、上述的Edge逻辑结构中的，每部分的排列的顺序的含义是什么？</strong></p><p>首先，在查询的时候为了提升查询速度，我们首先要过滤的是什么，针对于edge毋庸置疑是<code>边的类型</code>和<code>边的方向</code>； </p><p>所以，为了我们可以更快的拿到类型和方向，所以在<code>edge</code>的存储结构中，我们发现作者将类型和方向存放在了column中，并且是column的最前面部分；这样我们可以直接通过判断column的第一部分字节就可以对<code>边类型</code>和<code>方向</code>进行过滤！</p><blockquote><p> ps：虽然我们在写Gremlin语句的时候，可能是语句写的是先过滤边的属性或者其他，但是JanusGraph会针对我们的gremlin语句进行优化为先过滤<code>边类型</code>和<code>方向</code></p></blockquote><p>接下来，我们可能对边的属性进行过滤，我们怎样提升经常要过滤的属性的查询速度呢？ 我们将经常用于范围查询的属性配置为sort key，然后就可以在过滤完边类型和方向后快速的进行属性的范围过滤（此处快速的指过滤配置为sort key的属性）；</p><h4 id="3-2-property的结构"><a href="#3-2-property的结构" class="headerlink" title="3.2 property的结构"></a>3.2 property的结构</h4><p>property的存储结构十分的简单，只包含<code>key id</code>、<code>property id</code>和<code>value</code>三部分：</p><ul><li>key id：属性label对应的id，有创建schema时JanusGraph创建； 不同于属性的唯一id</li><li>property id：属性的唯一id，唯一代表某一个属性</li><li>value：属性值</li></ul><p>注意：属性的类型包含<code>SINGLE</code>、<code>LIST</code>和<code>SET</code>三种Cardinality；当属性被设置为<code>LIST</code>类型时，因为<code>LIST</code>允许当前的节点存在多个相同的属性kv对，仅通过<code>key id</code>也就是属性的label id是无法将相同的属性label区分出来的</p><p>所以在这种情况下，JanusGraph的<code>property</code>的存储结构有所变化， <code>property id</code>也将会被存储在<code>column</code>中，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200814105540758.png#pic_center" alt="在这里插入图片描述"></p><h2 id="四：index存储结构"><a href="#四：index存储结构" class="headerlink" title="四：index存储结构"></a>四：index存储结构</h2><h3 id="1、Composite-Index-vertex-index结构"><a href="#1、Composite-Index-vertex-index结构" class="headerlink" title="1、Composite Index-vertex index结构"></a>1、Composite Index-vertex index结构</h3><p><strong>图一（唯一索引Composite Index结构图）：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce2b88f6757535f3c4289097515239e1.png" alt="image-20200807172610213"></p><p><strong>图二（非唯一索引Composite Index结构图）：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0bcb510f960f7edd4916e99b27449ad5.png" alt="image-20200807172620360"></p><p>Rowkey由<code>index label id</code> 和<code>properties value</code>两大部分组成：</p><ul><li>index label id：标识当前索引类型</li><li>properties value：索引中包含属性的所有属性值，可多个； 存在压缩存储，如果超过<code>16000</code>个字节，则使用<code>GZIP</code>对property value进行压缩存储！</li></ul><p>Column由<code>第一个字节0</code> 和 <code>vertex id</code>组成：</p><ul><li>第一个字节0：无论是唯一索引，还是非唯一索引此部分都会存在；如图一</li><li>vertex id：非唯一索引才会在column中存在，用于分别多个相同索引值对应的不同节点；如图二</li></ul><p>value由<code>vertex id</code>组成：</p><ul><li>vertex id：针对于rowkey + column查询到的value是vertex id，然后通过vertex id查询对应的节点</li></ul><h3 id="2、Composite-Index-edge-index结构"><a href="#2、Composite-Index-edge-index结构" class="headerlink" title="2、Composite Index-edge index结构"></a>2、Composite Index-edge index结构</h3><p><strong>图一（唯一索引Composite Index结构图）：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f0fb556401f6ed3868b1fd2e2543db4.png" alt="image-20201204172501463"></p><p><strong>图二（非唯一索引Composite Index结构图）：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2d5b3fb7e2ea7bab986dd4ad42250ad4.png" alt="image-20201204172538392"></p><p>Rowkey同Vertex index部分</p><p>Column由<code>第一个字节0</code> 和 <code>edge id</code>组成：</p><ul><li>第一个字节0：无论是唯一索引，还是非唯一索引此部分都会存在；如图一</li><li>edge id：非唯一索引才会在column中存在，用于分别多个相同索引值对应的不同节点；如图二</li></ul><p>value由以下4部分组成：</p><ul><li>edge id：边id</li><li>out vertex id：边对应的出边id</li><li>type id：edge 的label type id</li><li>in vertex id：边对应的入边id</li></ul><h3 id="2、Mixed-Index结构"><a href="#2、Mixed-Index结构" class="headerlink" title="2、Mixed Index结构"></a>2、Mixed Index结构</h3><p>这里以<code>ES</code>作为第三方索引库为例，这里只介绍普通的范围查找的mixed index的构造：</p><p>ES的概念为：index 包含多个 type；每个type包含多个document id，每个document id包含多个field name 和对应的field value；</p><p>在<code>Jausgraph</code>中</p><ul><li><p>index：包含两种，<code>janusgraph_edge</code> 和 <code>janusgraph_vertex</code>两种</p></li><li><p>type：可自定义</p></li><li><p>document id：edge id或者 vertex id</p></li><li><p>field name：索引对应属性的label string</p></li><li><p>field value：属性对应的property value</p></li></ul><p>基于<code>倒排索引</code>的查询顺序为，给定过一个property label 和 property value查询对应的Vertex id 或者 edge id，则查询满足要求的field name 和 field value，就可以获取到对应的document id即Vertex id 或者 edge id；</p><h2 id="五：序列化数据案例"><a href="#五：序列化数据案例" class="headerlink" title="五：序列化数据案例"></a>五：序列化数据案例</h2><p>以序列化实例来看下上述所说的整体结构</p><p>测试节点数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>:<span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;propertyMap&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;create_time&quot;</span>:<span class="string">&quot;2016-12-09 02:29:26&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user_name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span>:<span class="string">&quot;test110&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;vertexId&quot;</span>:<span class="number">4152</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试边数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;edgeId&quot;</span>:<span class="number">17514510</span>,</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>:<span class="string">&quot;user_login_phone_number&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;propertyMap&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;productid&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sourceId&quot;</span>:<span class="number">4152</span>,</span><br><span class="line">    <span class="attr">&quot;targetId&quot;</span>:<span class="number">40964120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪Janusgraph源码，获取其序列化信息，后端存储使用<code>Hbase</code>：</p><p>节点序列化后数据（不包含索引）：<br><img src="https://img-blog.csdnimg.cn/20200814105603280.png#pic_center" alt="在这里插入图片描述"></p><p>边序列化后数据（不包含索引）：<br><img src="https://img-blog.csdnimg.cn/20200814105608275.png#pic_center" alt="在这里插入图片描述"></p><p>节点的vertex id序列化后的数据为<code>56 0 0 0 0 0 0 -128</code>；一个节点对应的属性和边的Rowkey相同，依据<code>qualifier</code>也就是column来进行区分；</p><p>在边的序列化结果中，包含两部分：一部分是节点<code>4152</code>的kcv，一个是节点<code>40964120</code>的kcv；这地方也可以说明JanusGraph是采用的双向邻接链表进行图存储的</p><h2 id="五：Schema的使用"><a href="#五：Schema的使用" class="headerlink" title="五：Schema的使用"></a>五：Schema的使用</h2><p>从上述来看，我们可以知道，JanusGraph图的schema该怎样定义主要是由edge labels 、property keys 和vertex labels 组成（<em>Each JanusGraph graph has a schema comprised of the edge labels, property keys, and vertex labels used therein</em>）</p><p>JanusGraph的schema可以显式或隐式创建，推荐用户采用显式定义的方式。JanusGraph的schema是可以在使用过程中修改的，而且不会导致服务宕机，也不会拖慢查询速度。</p><p><strong>比如一个简单的显示定义的销售图的scheme：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;salesman_id&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;销售人员id&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;real_name&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;role&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;角色&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;city_code&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;所处城市代码&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;创建时间&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">edgeLabel</span> <span class="attr">value</span>=<span class="string">&quot;saleman_service_for&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;销售引导&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propertys</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;create_time&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">propertys</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">edgeLabel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">edgeLabel</span> <span class="attr">value</span>=<span class="string">&quot;own_salaman_Idcard&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;销售身份&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propertys</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;create_time&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">propertys</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">edgeLabel</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">index</span> <span class="attr">elementType</span>=<span class="string">&quot;vertex&quot;</span> <span class="attr">indexType</span>=<span class="string">&quot;compositeIndex&quot;</span> <span class="attr">name</span>=<span class="string">&quot;salesman_id_I&quot;</span>  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propertyKeys</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">propertyKey</span> <span class="attr">value</span>=<span class="string">&quot;salesman_id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">propertyKeys</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">vertexLabel</span> <span class="attr">value</span>=<span class="string">&quot;salesman&quot;</span> <span class="attr">explain</span>=<span class="string">&quot;销售&quot;</span>  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propertys</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;salesman_id&quot;</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;real_name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;role&quot;</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;city_code&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">propertys</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">edges</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">edge</span> <span class="attr">value</span>=<span class="string">&quot;saleman_service_for&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">edge</span> <span class="attr">value</span>=<span class="string">&quot;own_salaman_Idcard&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">edges</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vertexLabel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以添加一些其他的可以组成schema的元素，上述三个是必须的，另外的比如索引（index）等，主要的结构还是：</p><pre><code>JanusGraph Schema        |-----------Vertex Lables        |-----------Property Keys        |-----------Edge Labels</code></pre><p>和关系型数据库不同，图数据的schema是定义一张图，而非定义一个vertex的。在Mysql中，我们通常将建立一张表定义为创建一个schema，而在JanusGraph中，一个Graph用于一个schema。</p><h2 id="六：源码分析"><a href="#六：源码分析" class="headerlink" title="六：源码分析"></a>六：源码分析</h2><p>源码分析已经push到github：<a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p><h2 id="七：总结"><a href="#七：总结" class="headerlink" title="七：总结"></a>七：总结</h2><ul><li>JanusGraph采用<code>Edge cut</code>的方式进行图切割，并且按照<code>双向邻接列表</code>的形式进行图存储</li><li>JanusGraph每个节点都是对应的kcv结构； vertex id唯一标识节点；对应的行cell存储节点属性和对应的边</li><li>节点id的分布式唯一性采用<code>数据库+号段</code>模式进行生成； </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详细讲解了JanusGraph的存储结构！&lt;/p&gt;
&lt;p&gt;大家好，我是洋仔，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~&lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解JanusGraph系列 - 关于JanusGraph图数据批量快速导入的方案和想法（bulk load data）</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E5%85%B3%E4%BA%8EJanusGraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%83%B3%E6%B3%95%EF%BC%88bulk_load_data%EF%BC%89.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E5%85%B3%E4%BA%8EJanusGraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%83%B3%E6%B3%95%EF%BC%88bulk_load_data%EF%BC%89.html</id>
    <published>2021-03-03T07:27:17.818Z</published>
    <updated>2021-03-03T07:27:17.813Z</updated>
    
    <content type="html"><![CDATA[<p>JanusGraph的批量导入速度一直是用户使用的痛点， 下面会依托官网的介绍和个人理解，聊一下关于图数据批量快速导入的一些方案、方案使用场景和一些想法；</p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>源码分析相关可查看<strong>github</strong>（<code>码文不易，求个star~</code>）： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程</p><p>微信公众号：匠心Java</p><p>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JanusGraph的批量导入速度一直是用户使用的痛点， 下面会依托官网的介绍和个人理解，聊一下关于图数据批量快速导入的一些方案、方案使用场景和一些想法；</p><p>写这篇文章的目的主要是为了让大家了解一下janus的导入的一些常用方案，算是一个总结吧，如有疑问或者文章错误，欢迎留言联系我</p><p>首先，说一下<code>JanusGraph</code>的批量导入的可配置的优化配置选项 和 基于<code>第三方存储和索引</code>的优化配置选项：</p><ul><li>批量导入的配置选项</li><li>第三方存储后端的优化选项（Hbase为例）</li><li>第三方索引后端的优化选项（ES为例）</li></ul><p>之后分析一下数据导入的五个方案：</p><ul><li>基于JanusGraph Api的批量导入</li><li>基于Gremlin Server的批量导入</li><li>使用JanusGraph-utils的批量导入</li><li>基于<strong>bulk loader</strong> 导入方式</li><li>基于<strong>抽取序列化逻辑生成Hfile</strong>离线批量导入</li></ul><p>最后聊一下关于批量导入的一些想法；</p><h2 id="一：批量导入的优化配置选项"><a href="#一：批量导入的优化配置选项" class="headerlink" title="一：批量导入的优化配置选项"></a>一：批量导入的优化配置选项</h2><h3 id="1、批量导入的配置选项"><a href="#1、批量导入的配置选项" class="headerlink" title="1、批量导入的配置选项"></a>1、批量导入的配置选项</h3><p><code>JanusGraph</code>中有许多配置选项和工具可以将<code>大量的图数据</code>更有效地导入。这种导入称为<code>批量加载</code>，与默认的事务性加载相反，默认的事务性加载单个事务只会添加少量数据。</p><p>下述介绍了配置选项和工具，这些工具和工具使JanusGraph中的批量加载更加高效。</p><p>在继续操作之前，请仔细遵守每个选项的限制和假设，以免丢失数据或损坏数据。</p><h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><blockquote><p>janusgraph支持批量导入，可通过相关配置项设置</p><p>下面具体看一下对应配置项的详细作用：</p></blockquote><h4 id="批量加载"><a href="#批量加载" class="headerlink" title="批量加载"></a>批量加载</h4><p><strong>1) 配置项：</strong><code>storage.batch-loading</code></p><p>启用该配置项，相当于打开了JanusGraph的批量导入开关；</p><p><strong>影响：</strong></p><p>启用批处理加载会在许多地方<code>禁用</code>JanusGraph内部一致性检查，重要的是会<code>禁用lock锁</code>定来保证分布式一致性；JanusGraph假定要加载到JanusGraph中的数据与图形一致，因此出于性能考虑禁用了自己的一致性检查。</p><p>换句话说，我们要在导入数据之前，保证要导入的数据和图中已有的数据不会产生冲突也就是保持一致性！</p><p><strong>为什么要禁用一致性检查来提升性能？</strong></p><p>在许多批量加载方案中，在<code>加载数据之前</code>确保去数据一致性，然后在将数据加载到数据库比在<code>加载数据到图库时</code>确保数据一致性，消耗的成本要便宜的多。</p><p>例如，将现有用户数据文件批量加载到JanusGraph中的用例：假设用户名属性键具有定义的<code>唯一复合索引</code>，即用户名在整个图中必须是唯一的。</p><p>那么按名称对数据文件进行排序并过滤出重复项或编写执行此类过滤的Hadoop作业消耗的时间成本，就会比开启一致性检查在导入图数据时janusgraph检查花费的成本要少的多。</p><p>基于上述，我们可以启用 <code>storage.batch-loading</code>配置，从而大大减少了批量加载时间，因为JanusGraph不必检查每个添加的用户该名称是否已存在于数据库中。</p><p><strong>重要提示</strong>：</p><p>启用<code>storage.batch-loading</code>要求用户确保加载的数据在内部是一致的，并且与图中已存在的任何数据一致。</p><p>特别是，启用批处理加载时，并发类型创建会导致严重的数据完整性问题。因此，我们<strong>强烈</strong>建议通过<code>schema.default = none</code>在图形配置中进行设置来禁用自动类型创建。</p><h4 id="优化ID分配"><a href="#优化ID分配" class="headerlink" title="优化ID分配"></a>优化ID分配</h4><p><strong>1、ID块大小</strong></p><p><strong>1）配置项：</strong><code>ids.block-size</code></p><p>该配置项为配置在分布式id的生成过程中每次获取 id block的大小；</p><p>分布式id相关具体可看文章<a href="https://liyangyang.blog.csdn.net/article/details/108000639">《图解Janusgraph系列-分布式id生成策略分析》</a></p><p><strong>原理：</strong></p><p>每个新添加的顶点或边都分配有唯一的ID。JanusGraph的ID池管理器以block的形式获取特定JanusGraph实例的ID。id块获取过程很昂贵，因为它需要保证块的全局唯一分配。</p><p>增加 <code>ids.block-size</code>会减少获取次数，但可能会使许多ID未被分配，从而造成浪费。对于事务性工作负载，默认块大小是合理的，但是在批量加载期间，顶点和边的添加要频繁得多，而且要快速连续。</p><p>因此，通常建议将块大小增加10倍或更多，具体取决于每台机器要添加的顶点数量。</p><p><strong>经验法则</strong>：</p><p>设置<code>ids.block-size</code>为您希望每小时为每个JanusGraph实例添加的顶点数。</p><p><strong>重要提示：</strong></p><p>必须为所有JanusGraph实例配置相同的值，<code>ids.block-size</code>以确保正确的ID分配。因此，在更改此值之前，请<code>务必关闭所有JanusGraph实例</code>。</p><p><strong>2、ID Acquisition流程</strong></p><p>当许多JanusGraph实例频繁并行分配id块时，不可避免地会出现实例之间的分配冲突，从而减慢了分配过程。</p><p>此外，由于大容量加载而导致的增加的写负载可能会使该过程进一步减慢到JanusGraph认为失败并引发异常的程度。可以调整2个配置选项来避免这种情况；</p><p><strong>1）配置项：</strong><code>ids.authority.wait-time</code></p><p>配置ID池管理器等待应用程序获取ID块被存储后端确认的时间（以毫秒为单位）。这段时间越短，应用程序在拥挤的存储群集上发生故障的可能性就越大。</p><p><strong>经验法则</strong>：</p><p>将其设置为负载下存储后端集群上测量的第95百分位读写时间的总和。</p><p><strong>重要说明</strong>：</p><p>所有JanusGraph实例的该值都应该相同。</p><p><strong>2）配置项：</strong><code>ids.renew-timeout</code></p><p>配置JanusGraph的ID池管理器在尝试获取新的ID块总共等待的毫秒数。</p><p><strong>经验法则</strong>：</p><p>将此值设置为尽可能大，不必为不可恢复的故障等待太久。增加它的唯一缺点是JanusGraph将在不可用的存储后端群集上尝试更长的时间</p><h4 id="优化读写"><a href="#优化读写" class="headerlink" title="优化读写"></a>优化读写</h4><p><strong>1、缓冲区大小</strong></p><p>JanusGraph在数据导入时存在一个<code>缓冲区</code>，用来缓冲当前事务的部分请求，从而可以小批量的写入和执行，从而减少针对存储后端的请求数。在短时间内执行大量写操作时，存储后端可能会因为大量的写请求打入而变得超负荷；</p><p><strong>配置项：</strong><code>storage.buffer-size</code></p><p>这些批次的大小由<code>storage.buffer-size</code>来控制。 增加<code>storage.buffer-size</code>可以通过增加缓冲区大小，来使得批次保存更多的请求，从而减少写请求的次数来避免上述失败。</p><p><strong>注意：</strong></p><p>增加缓冲区大小会增加写请求的等待时间及其失败的可能性。因此，不建议为事务性负载增加此设置，并且应该在批量加载期间仔细尝试此设置的一个合适的值。</p><p><strong>2、读写健壮性</strong></p><p>在批量加载期间，群集上的负载通常会增加，从而使读和写操作失败的可能性更大（尤其是如上所述，如果缓冲区大小增加了）。 </p><p><strong>1）配置项：</strong><code>storage.read-attempts</code></p><p>该配置项配置JanusGraph在放弃之前尝试对存储后端执行读取或写入操作的次数。</p><p><strong>2）配置项：</strong><code>storage.attempt-wait</code></p><p>该配置项指定JanusGraph在重新尝试失败的后端操作之前将等待的毫秒数。较高的值可以确保重试操作不会进一步增加后端的负载。</p><p><strong>注意：</strong></p><p>如果在批量加载期间后端上可能会有很高的负载，通常建议增加这些配置选项。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>1）配置项：</strong><code>storage.read-attempts</code></p><h3 id="2、第三方存储后端的优化选项"><a href="#2、第三方存储后端的优化选项" class="headerlink" title="2、第三方存储后端的优化选项"></a>2、第三方存储后端的优化选项</h3><p>针对于第三方存储的优化分为两部分：</p><ul><li>第三方存储集群自身的优化</li><li>JanusGraph结合第三方存储的优化选项</li></ul><h4 id="集群自身的优化"><a href="#集群自身的优化" class="headerlink" title="集群自身的优化"></a>集群自身的优化</h4><p>集群自身的优化，本文主要介绍janusgraph相关优化这里就不多说这部分了，主要是提升hbase集群的读写能力；</p><p>这里主要还是关注的Hbase的写数据能力优化后的提升！这部分的优化至关重要！ 下面举几个例子：</p><p><strong>1）配置项：</strong> <code>hbase.client.write.buffer</code></p><p>设置buffer的容量</p><p>HBase Client会在数据累积到设置的阈值后才提交Region Server。这样做的好处在于可以减少RPC连接次数。</p><p>计算一下服务端因此而消耗的内存：<code>hbase.client.write.buffer * hbase.regionserver.handler.count</code>从在减少PRC次数和增加服务器端内存之间找到平衡点。</p><p><strong>2）配置项：</strong> <code>hbase.regionserver.handler.count</code></p><p>定义每个Region Server上的RPC Handler的数量</p><p>Region Server通过RPC Handler接收外部请求并加以处理。所以提升RPC Handler的数量可以一定程度上提高HBase接收请求的能力。</p><p>当然，handler数量也不是越大越好，这要取决于节点的硬件情况。</p><p>等等各种配置项</p><p><strong>3）针对一些CF、RowKey设计之类的优化点，因为这些都是janus预设好的，所以在<code>janusGraph</code>中使用不到；</strong></p><h4 id="JanusGraph针对优化"><a href="#JanusGraph针对优化" class="headerlink" title="JanusGraph针对优化"></a>JanusGraph针对优化</h4><p>针对于JanusGraph+第三方存储的优化，<a href="https://docs.janusgraph.org/basics/configuration-reference/#indexxelasticsearch">官网(配置项文档超链接)</a> 给出了一些配置选项，可从其找出对应的配置项；</p><p>针对于hbase，我在配置项中找出了对应的一些可能有作用的配置如下：</p><p><strong>1）配置项：</strong> <code>storage.hbase.compression-algorithm</code></p><p>hbase存储数据压缩算法的配置，我们在《图解图库JanusGraph系列-一文知晓“图数据“底层存储结构》文章中提到有好几个地方都是压缩存储的，此处就是配置的压缩算法；</p><p><strong>类型:</strong> 枚举值，支持 <code>lzo</code>、<code>gz</code>、<code>snappy</code>、<code>lz4</code>、<code>bzip2</code>、<code>zstd</code>五种压缩算法 和 不压缩配置：<code>none</code></p><p><strong>默认值：</strong>  <code>gz</code>压缩；</p><p><strong>注意：</strong>此处配置的算法需要hbase也支持才可以！  如果存储空间足够，可以考虑配置为不压缩，也会提升导入速率！</p><p><strong>2）配置项：</strong><code>storage.hbase.skip-schema-check</code></p><p>假设JanusGraph的HBase表和列族已经存在。 如果是这样，JanusGraph将不会检查其 table/ CF 的存在，也不会在任何情况下尝试创建它们。 </p><p><strong>类型：</strong> 布尔值</p><p><strong>默认值：</strong>  false，检查</p><p><strong>注意：</strong> 可以在数据导入时，将该配置项设置为<code>true</code>，去除table/ CF的检查，这个其实作用不大；因为都是在初始化图实例的时候就去检查了。。</p><h3 id="3、第三方索引后端的优化选项"><a href="#3、第三方索引后端的优化选项" class="headerlink" title="3、第三方索引后端的优化选项"></a>3、第三方索引后端的优化选项</h3><p>针对于第三方存索引的优化分为两部分：</p><ul><li>第三方索引集群自身的优化</li><li>JanusGraph结合第三方索引的优化选项</li></ul><h4 id="集群自身的优化-1"><a href="#集群自身的优化-1" class="headerlink" title="集群自身的优化"></a>集群自身的优化</h4><p>集群自身的优化，本文主要介绍janusgraph相关优化这里就不多说这部分了，主要是提升索引集群的读写能力；</p><p>这里主要还是关注的索引的写数据能力优化后的提升！这部分的优化至关重要！</p><p><strong>例如es的线程池参数优化等</strong></p><h4 id="JanusGraph针对优化-1"><a href="#JanusGraph针对优化-1" class="headerlink" title="JanusGraph针对优化"></a>JanusGraph针对优化</h4><p>针对于JanusGraph+第三方索引的优化，<a href="https://docs.janusgraph.org/basics/configuration-reference/#indexxelasticsearch">官网(配置项文档超链接)</a> 给出了一些配置选项，可从其找出对应的配置项；</p><p>针对于es，我在配置项中找出了对应的一些可能有作用的配置如下：</p><p><strong>1）配置项：</strong> <code>index.[X].elasticsearch.retry_on_conflict</code></p><p>指定在发生冲突时应重试操作多少次。</p><p><strong>类型:</strong>  整数</p><p><strong>默认值：</strong>  0次</p><p><strong>注意：</strong> 增大该值可以提升在批量导入中，发生冲突后解决冲突的几率</p><h3 id="3、JVM的优化"><a href="#3、JVM的优化" class="headerlink" title="3、JVM的优化"></a>3、JVM的优化</h3><p>JanusGraph基于Java语言编写，则毋庸置疑会用到JVM</p><p>对JVM的调优也主要集中到垃圾收集器和堆内存的调优</p><p><strong>堆大小调整：</strong></p><p>我们在导入图数据时会产生大量的临时数据，这里需要我们调整一个合适的堆空间；</p><p>推荐至少为8G</p><p><strong>垃圾收集器调优：</strong></p><p>如果在使用CMS发现GC过于频繁的话，我们可以考虑将垃圾收集器设置为：G1</p><p>这个收集器适用于大堆空间的垃圾收集，有效的减少垃圾收集消耗的时间；</p><p><strong>注意：</strong></p><p>此处的JVM调优设计<code>JanusGraph java api项目</code> 和 <code>gremlin server</code>部分的JVM调优；</p><h2 id="二：基于数据层面的优化"><a href="#二：基于数据层面的优化" class="headerlink" title="二：基于数据层面的优化"></a>二：基于数据层面的优化</h2><h3 id="2-1-拆分图-并发执行"><a href="#2-1-拆分图-并发执行" class="headerlink" title="2.1 拆分图 并发执行"></a>2.1 拆分图 并发执行</h3><p>在某些情况下，图数据可以分解为多个断开连接的子图。这些子图可以跨多台机器独立地并行加载；不管是采用下述的那种方式加载都可以；</p><p>这里有一个前提： 底层第三方存储集群的处理能力没有达到最大； 如果底层存储集群当前的平均cpu已经是80 90%的了，就算拆分多个图也没用，底层存储的处理能力已经被限制住当前的速度了；</p><p>这个方式官网上提了一句，这个地方其实很难可以将图拆分为断开的子图，并且针对于拆分为多个子图来说，主要还是依托于底层存储集群的处理能力；</p><p>一般情况下，不用拆分图进行一个好的优化后，底层存储集群的处理能力都可以完全调用起来；</p><h3 id="2-2-分步骤-并发执行"><a href="#2-2-分步骤-并发执行" class="headerlink" title="2.2 分步骤 并发执行"></a>2.2 分步骤 并发执行</h3><p>如果无法分解图形，则分多个步骤加载通常是有益的，也就是将vertex 和 edge 分开导入；</p><p>这种方式，需要数据同学做好<code>充分的数据探查</code>，不然可能会产生数据不一致的情况！ 下面是步骤（<code>其中最后两个步骤可以在多台计算机上并行执行</code>）：</p><ol><li><strong>前提：</strong> 确保vertex和edge数据集 删除了重复数据 并且是一致的</li><li><strong>环境配置：</strong> 设置<code>batch-loading=true</code> 并且优化上述介绍的其他选项</li><li><strong>vertex全量导入：</strong> 将所有的vertex及节点对应的property添加到图中。维护一份从顶点ID（由加载的数据用户自定义）到JanusGraph的内部顶点分布式一致性ID（即<code>vertex.getId()</code>）的映射，该ID 为64位长</li><li><strong>edge全量导入：</strong> 使用映射添加所有的边 来查找JanusGraph的顶点id 并使用该id检索顶点。</li></ol><p><strong>讲述过程：</strong></p><p>假设存在3个用户，“-”号后为对应的自定义的顶点id值（注意，非导入图库中的顶点id，只是标识当前节点的业务id）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user1-1</span><br><span class="line">user2-2</span><br><span class="line">user3-3</span><br></pre></td></tr></table></figure><p>上述第三步，我们将这些节点导入到图库中！ 产生一个业务id 与 图库中节点的分布式唯一id的对应关系如下：</p><blockquote><p>我们在导入一个点后，janus会返回一个vertex实例对象，通过这个对象就可以拿到对应的图库vertexId</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">业务id-图库中节点id</span><br><span class="line">1-4261</span><br><span class="line">2-4274</span><br><span class="line">3-4351</span><br></pre></td></tr></table></figure><p>注意：这一步骤，我们可以多线程并行导入而无需担心一致性问题，因为节点全部唯一</p><p>节点导入完成！</p><p>假设存在对应的有3条边如下，</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edge1：user1 --&gt; user2 </span><br><span class="line">edge2：user1 --&gt; user3</span><br><span class="line">edge3：user2 --&gt; user3</span><br></pre></td></tr></table></figure><p>我们通过user1对应业务id：1，而业务id：1对应节点id：4261，我们就可以转化为下述对应关系：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4261 --&gt; 4274</span><br><span class="line">4261 --&gt; 4351</span><br><span class="line">4274 --&gt; 4351</span><br></pre></td></tr></table></figure><blockquote><p>在JanusGraph中通过节点id查询节点，是获取节点的最快方式！！</p></blockquote><p>我们就可以通过id获取图库中对应的vertex对象实例，然后使用addVertex将edge导入！</p><p>注意：这一步骤，我们可以多线程并行导入而无需担心一致性问题，因为edge全部唯一</p><p>第三个步骤和第四个步骤也可以并行执行，我们在导入点的过程中，可以也同时将源节点和目标节点已经导入到图库中的edge同步入图；</p><h2 id="三：批量导入方案"><a href="#三：批量导入方案" class="headerlink" title="三：批量导入方案"></a>三：批量导入方案</h2><p>下述介绍一下5种导入方案，其中包含3种批量导入方案；</p><h3 id="3-1-方案一：基于JanusGraph-Api的数据导入"><a href="#3-1-方案一：基于JanusGraph-Api的数据导入" class="headerlink" title="3.1 方案一：基于JanusGraph Api的数据导入"></a>3.1 方案一：基于JanusGraph Api的数据导入</h3><p>该方案可以整合上述第二部分<code>二：基于数据层面的优化</code>；</p><p><strong>涉及方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphVertex <span class="title">addVertex</span><span class="params">(Object... keyValues)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphEdge <span class="title">addEdge</span><span class="params">(String label, Vertex vertex, Object... keyValues)</span></span>;</span><br></pre></td></tr></table></figure><p>在janusGraph的业务项目中，可以开发一个数据导入模块，使用提供的类似于java api等，进行数据的导入；</p><p><strong>流程：</strong></p><p>这种是最简单的方案，具体的细节，这里就不给出了，节点导入大体流程为下述：</p><ol><li>获取图实例</li><li>获取图实例事务对象</li><li>插入节点</li><li>提交事务</li></ol><p>边导入大体流程如下：</p><ol><li>获取图实例</li><li>获取图实例事务对象</li><li>查询源节点 + 目标节点（这个地方可能是性能瓶颈）</li><li>在两个节点中插入边</li><li>提交事务</li></ol><p><strong>主要作用：</strong></p><p>此方案可以用于数据量较小的情况下使用，例如每天的<code>增量导入</code>等；</p><p><strong>优化点：</strong></p><p>1、批量事务提交</p><p>此处的事务提交，我们可以通过一个常用的优化手段： 处理多个vertex 或者 edge后再提交事务！ </p><p>可以减少janus与底层存储的交互，减少网络消耗和连接数，提升导入的性能！</p><p>处理的个数多少主要还是和底层存储集群相关，几百还是几千这就需要自己调试获取当前环境下的最优配置了</p><p><strong>注意：</strong></p><p>如果开启了上述提到的<code>storage.batch-loading</code>，则需要你们现在的环境下注意一致性的问题；</p><p>例如图库中原本存在一个a节点，你又插入一个a节点，便会有一致性问题；</p><p>我们可以通过插入数据前，先通过唯一索引查询节点，节点存在则更新节点，不存在则插入节点；</p><h3 id="3-2-方案二：基于Gremlin-Server的批量导入"><a href="#3-2-方案二：基于Gremlin-Server的批量导入" class="headerlink" title="3.2 方案二：基于Gremlin Server的批量导入"></a>3.2 方案二：基于Gremlin Server的批量导入</h3><p>该方案可以整合上述第二部分<code>二：基于数据层面的优化</code>；</p><p>这里需要我们搭建一个Gremlin server服务器，通过在服务器执行<code>gremlin-server.sh</code>即可，暴露出一个tcp接口；</p><p>则可以将对应的gremlin 语句提交到对应的gremlin服务器执行；</p><p>具体的流程和第一个方案一致</p><p><strong>优化点：</strong></p><p>同上一个方案优化点1；</p><p>3、gremlin server池参数调整</p><p>除了上述给定的一些配置的优化项，还有两个gremlin server的优化项需要调整</p><ul><li><p>threadPoolWorke：最大2*core个数，用于处理非阻塞读写的Gremlin服务器可用的线程数；</p></li><li><p>gremlinPool：用于在ScriptEngine中执行实际脚本的“Gremlin”线程的数量。此池表示Gremlin服务器中可用于处理阻塞操作的工作者；</p></li></ul><p>和线程池调优一样，要找出最合适的一个值，太小不好，太大也不好；</p><p><strong>注意：</strong></p><p>该方案本质上和第一个方案类似，只不过是一个是通过给定的java api提交插入请求，一个直接通过gremlin语句提交插入请求到gremlin server；</p><h3 id="3-3-方案三：IBM的janusgraph-utils"><a href="#3-3-方案三：IBM的janusgraph-utils" class="headerlink" title="3.3 方案三：IBM的janusgraph-utils"></a>3.3 方案三：IBM的janusgraph-utils</h3><p>这个方案没用过，简单看了一下，这个主要也是通过多线程对数据进行导入； </p><p>自己手动组装对应的schema文件，将schema导入到数据库；</p><p>然后将组装为特定格式的csv文件中的数据，导入到图库中；</p><p><strong>github地址：</strong>  <a href="https://github.com/IBM/janusgraph-utils">https://github.com/IBM/janusgraph-utils</a></p><p><strong>优点：</strong> </p><p>1、使用难度不高，让我们不用再去手写多线程的导入了；减少工作量</p><p>2、直连hbase和es，相对于前两种减少了对应的gremlin server和janus server的网络交互</p><p>3、支持通过配置文件自动创建Janusgraph schema和index</p><p>4、可配置化的线程池大小和每次批量提交的数量</p><p><strong>问题：</strong>  </p><p>1、schema和csv文件也是要用户组装出对应格式</p><p>2、相对于前两种方式性能提升有限，主要是少了一层网络交互。多线程和批量提交，前两种都可以手动去实现；还需要引入一个新的组件</p><p>3、支持janus版本较低，可以手动升级，不难</p><p>4、相对于下面两种方案，性能还是较低</p><h3 id="3-4-方案四：bulk-loader"><a href="#3-4-方案四：bulk-loader" class="headerlink" title="3.4 方案四：bulk loader"></a>3.4 方案四：bulk loader</h3><p>官方提供的批量导入方式；需要hadoop集群和spark集群的支持；</p><p>hadoop和spark集群配置，可以看官网：<a href="https://docs.janusgraph.org/advanced-topics/hadoop/">https://docs.janusgraph.org/advanced-topics/hadoop/</a></p><p>该方案对导入的数据有着严格的要求，支持多种数据格式：<code>json</code>、<code>csv</code>、<code>xml</code>、<code>kryo</code>；</p><p><strong>数据要求：</strong>  节点、节点对应的属性、节点对应的边需要在一行中（一个json中、一个xml项中）</p><p><strong>数据案例：</strong>  下面给一下官网的案例，在<code>data</code>目录下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- json格式</span><br><span class="line">&#123;&quot;id&quot;:2,&quot;label&quot;:&quot;song&quot;,&quot;inE&quot;:&#123;&quot;followedBy&quot;:[&#123;&quot;id&quot;:0,&quot;outV&quot;:1,&quot;properties&quot;:&#123;&quot;weight&quot;:1&#125;&#125;,&#123;&quot;id&quot;:323,&quot;outV&quot;:34,&quot;properties&quot;:&#123;&quot;weight&quot;:1&#125;&#125;]&#125;,&quot;outE&quot;:&#123;&quot;followedBy&quot;:[&#123;&quot;id&quot;:6190,&quot;inV&quot;:123,&quot;properties&quot;:&#123;&quot;weight&quot;:1&#125;&#125;,&#123;&quot;id&quot;:6191,&quot;inV&quot;:50,&quot;properties&quot;:&#123;&quot;weight&quot;:1&#125;&#125;],&quot;sungBy&quot;:[&#123;&quot;id&quot;:7666,&quot;inV&quot;:525&#125;],&quot;writtenBy&quot;:[&#123;&quot;id&quot;:7665,&quot;inV&quot;:525&#125;]&#125;,&quot;properties&quot;:&#123;&quot;name&quot;:[&#123;&quot;id&quot;:3,&quot;value&quot;:&quot;IM A MAN&quot;&#125;],&quot;songType&quot;:[&#123;&quot;id&quot;:5,&quot;value&quot;:&quot;cover&quot;&#125;],&quot;performances&quot;:[&#123;&quot;id&quot;:4,&quot;value&quot;:1&#125;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">-- xml格式</span><br><span class="line">&lt;node id=&quot;4&quot;&gt;&lt;data key=&quot;labelV&quot;&gt;song&lt;/data&gt;&lt;data key=&quot;name&quot;&gt;BERTHA&lt;/data&gt;&lt;data key=&quot;songType&quot;&gt;original&lt;/data&gt;&lt;data key=&quot;performances&quot;&gt;394&lt;/data&gt;&lt;/node&gt;&lt;node id=&quot;5&quot;&gt;&lt;data key=&quot;labelV&quot;&gt;song&lt;/data&gt;&lt;data key=&quot;name&quot;&gt;GOING DOWN THE ROAD FEELING BAD&lt;/data&gt;&lt;data key=&quot;songType&quot;&gt;cover&lt;/data&gt;&lt;data key=&quot;performances&quot;&gt;293&lt;/data&gt;&lt;/node&gt;&lt;node id=&quot;6&quot;&gt;&lt;data key=&quot;labelV&quot;&gt;song&lt;/data&gt;&lt;data key=&quot;name&quot;&gt;MONA&lt;/data&gt;&lt;data key=&quot;songType&quot;&gt;cover&lt;/data&gt;&lt;data key=&quot;performances&quot;&gt;1&lt;/data&gt;&lt;/node&gt;&lt;node id=&quot;7&quot;&gt;&lt;data key=&quot;labelV&quot;&gt;song&lt;/data&gt;&lt;data key=&quot;name&quot;&gt;WHERE HAVE THE HEROES GONE&lt;/data&gt;&lt;data key=&quot;songType&quot;&gt;&lt;/data&gt;&lt;data key=&quot;performances&quot;&gt;0&lt;/data&gt;&lt;/node&gt;</span><br><span class="line"></span><br><span class="line">-- csv格式</span><br><span class="line">2,song,IM A MAN,cover,1 followedBy,50,1|followedBy,123,1|sungBy,525|writtenBy,525       followedBy,1,1|followedBy,34,1</span><br></pre></td></tr></table></figure><p>我们可以观察到，这其实是不容易构造的，节点属性边全部需要整合到一块；</p><p><strong>数据整理方案：</strong> spark的<code>cogroup</code>， cogroup的作用就是将多个 RDD将相同的key jion成一行，从而使用csv格式进行导入，操作实示例如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rdd1 = sc.parallelize(Array((&quot;aa&quot;,1),(&quot;bb&quot;,2),(&quot;cc&quot;,6)))</span><br><span class="line">val rdd2 = sc.parallelize(Array((&quot;aa&quot;,3),(&quot;dd&quot;,4),(&quot;aa&quot;,5)))</span><br><span class="line">rdd1.cogroup(rdd2).collect()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">(aa,(CompactBuffer(1),CompactBuffer(3, 5)))</span><br><span class="line">(dd,(CompactBuffer(),CompactBuffer(4)))</span><br><span class="line">(bb,(CompactBuffer(2),CompactBuffer()))</span><br><span class="line">(cc,(CompactBuffer(6),CompactBuffer()))</span><br></pre></td></tr></table></figure><p>这里大家可以参考<code>360</code>对这方面的处理，转化代码github地址：<a href="https://github.com/360jinrong/janusgraph-data-importer">https://github.com/360jinrong/janusgraph-data-importer</a></p><p><strong>注意：</strong></p><p>此处的原始数据的准备需要细致，一致性保证完全依赖于原始数据的一致性保证；</p><h3 id="3-5-方案五：基于抽取序列化逻辑的生成Hbase-File离线批量导入"><a href="#3-5-方案五：基于抽取序列化逻辑的生成Hbase-File离线批量导入" class="headerlink" title="3.5 方案五：基于抽取序列化逻辑的生成Hbase File离线批量导入"></a>3.5 方案五：基于抽取序列化逻辑的生成Hbase File离线批量导入</h3><p>博主在图库初始化时采用了这种方式，前前后后花费了接近一个月的时间，经过细致的验证，现已应用到生产环境使用，下面介绍一下对应的注意点和主要流程：</p><p><strong>方案：</strong> 依据源码抽取出对应的序列化逻辑，分布式生成Hfile，将Hfile导入到Hbase；</p><p><strong>问题：</strong> 人力成本过高，需要看源码抽逻辑，并且需要一个细致的验证；</p><p><strong>方案难点：</strong></p><p>JanusGraph对于Hbase的数据底层格式，可以看我写的博客：</p><ul><li><a href="https://liyangyang.blog.csdn.net/article/details/107999814">《图解图库JanusGraph系列-一文知晓“图数据“底层存储结构（JanusGraph data model）》</a>   </li><li><a href="https://liyangyang.blog.csdn.net/article/details/111315187">《图解Janusgraph系列-图数据底层序列化源码分析（Data Serialize）》</a></li></ul><p>这两篇博客，一个分析了底层存储的格式，一个进行了相应的源码分析；</p><p><strong>流程+验证+建议：</strong> 请看我写的另外一个博客：<a href="https://liyangyang.blog.csdn.net/article/details/111479347">《图解JanusGraph系列-生成Hbase file离线批量导入方案》</a></p><p>这种方式，其实消耗的人力会比较大；另外，对于抽取的逻辑是否开源，这个后续我们会考虑这个问题，开源后地址会同步更新到本文章；</p><h2 id="四：几种场景"><a href="#四：几种场景" class="headerlink" title="四：几种场景"></a>四：几种场景</h2><h3 id="4-1-图库中已经存在数据"><a href="#4-1-图库中已经存在数据" class="headerlink" title="4.1 图库中已经存在数据"></a>4.1 图库中已经存在数据</h3><p>如果图库中已经存在数据，对于<code>3.4 方案四：bulk loader</code> 和 <code>3.5 方案五：基于抽取序列化逻辑的生成Hbase File离线批量导入</code> 这两种方案可能就无法使用了；</p><p>我们可以采取两种方式：</p><ol><li>使用第一种方案和第二种方案进行导入（注意数据一致性）</li><li>整体迁移图库，将图库中现有数据和将要导入的数据整体迁移到另外一个新图库，就可以使用4、5方案进行导入</li></ol><h3 id="4-2-图数据初始化或者迁移"><a href="#4-2-图数据初始化或者迁移" class="headerlink" title="4.2 图数据初始化或者迁移"></a>4.2 图数据初始化或者迁移</h3><p>数据量小，建议使用<code>3.1 方案一：基于JanusGraph Api的数据导入</code>  和  <code>3.2 方案二：基于Gremlin Server的批量导入</code>  和 <code>3.3 方案三：IBM的janusgraph-utils</code>；</p><p>数据量大，建议使用<code>3.4 方案四：bulk loader</code> 和 <code>3.5 方案五：基于抽取序列化逻辑的生成Hbase File离线批量导入</code>；</p><h3 id="4-3-单纯只看业务数据量"><a href="#4-3-单纯只看业务数据量" class="headerlink" title="4.3 单纯只看业务数据量"></a>4.3 单纯只看业务数据量</h3><p>选择什么方式导入，单纯基于业务数据量给一些个人建议：</p><ul><li>小数据量（亿级以下）：  直接janusgraph api 或者 gremlin server导入即可，几小时就ok了； 如果想要更快可以使用另外的方式，只是会增加人力成本；</li><li>中等数据量（十亿级以下）：数据充分探查，开启<code>storage.batch-loading</code>完全可以支持，使用api，2天左右可以完成全量的数据导入</li><li>大数据量（百亿级数据）：推荐采用bulk load方式，配置hadoop集群，使用spark cluster导入</li><li>另一个方案：如果上述还是无法满足你们的需求，可以采用依据源码抽取序列化逻辑生成Hfile，然后离线导入到Hbase的方案，不过这种是花费人力成本最大的一种方式，不过效果也几乎是最好的，尤其是数据量越大效果越明显</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据的批量导入一直是<code>JanusGraph</code>让人难受的地方，经过本文的介绍大家应该有一个大体的认识，针对于百亿级的数据导入，上述的几种方案是可以支持的；</p><p>其他：批量导入后，每天的增量采用消息中间件接入JanusGraph api导入即可；</p><p>数据导入过程中，针对于不同的底层存储、不同的版本还是会有一些问题，具体的导入的坑大家可以加我v，邀你加群</p><blockquote><p>注意！！！以上仅作为参考，有任何问题可评论或加博主v讨论</p></blockquote><blockquote><p>参考：<br>JanusGaph官网<br><a href="https://www.jianshu.com/p/f372f0ef6c42">https://www.jianshu.com/p/f372f0ef6c42</a><br><a href="https://www.jianshu.com/p/4b59c00a15de/">https://www.jianshu.com/p/4b59c00a15de/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;JanusGraph的批量导入速度一直是用户使用的痛点， 下面会依托官网的介绍和个人理解，聊一下关于图数据批量快速导入的一些方案、方案使用场景和一些想法；&lt;/p&gt;
&lt;p&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解Janusgraph系列-并发安全：Lock锁机制(本地锁+分布式锁)分析</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%9ALock%E9%94%81%E6%9C%BA%E5%88%B6(%E6%9C%AC%E5%9C%B0%E9%94%81+%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)%E5%88%86%E6%9E%90.html</id>
    <published>2021-03-03T07:27:08.629Z</published>
    <updated>2021-03-03T07:27:08.624Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？<strong>分布式锁！</strong></p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（码文不易，求个star~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><hr><p>在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？<strong>分布式锁！</strong></p><h2 id="一：分布式锁"><a href="#一：分布式锁" class="headerlink" title="一：分布式锁"></a>一：分布式锁</h2><p>常用的分布式锁实现方式有三种：</p><p>1、基于数据库实现分布式锁</p><p>​        针对于数据库实现的分布式锁，如mysql使用使用<code>for update</code>共同竞争一个行锁来实现； 在JanusGraph中，也是基于数据库实现的分布式锁，这里的<code>数据库</code>指的是我们当前使用的第三方<code>backend storage</code>，具体的实现方式也和mysql有所不同，具体我们会在下文分析</p><p>2、基于Redis实现的分布式锁</p><p>​    基于<code>lua脚本</code>+<code>setNx</code>实现</p><p>3、基于zk实现的分布式锁</p><p>​    基于<code>znode</code>的有序性和<code>临时节点</code>+zk的<code>watcher</code>机制实现</p><p>4、MVCC多版本并发控制乐观锁实现</p><blockquote><p> 本文主要介绍Janusgraph的锁机制，其他的实现机制就不在此做详解了</p></blockquote><p>下面我们来分析一下<code>JanusGraph</code>的<code>锁机制</code>实现~</p><h2 id="二：JanusGraph锁机制"><a href="#二：JanusGraph锁机制" class="headerlink" title="二：JanusGraph锁机制"></a>二：JanusGraph锁机制</h2><p>在JanusGraph中使用的锁机制是：<code>本地锁</code> + <code>分布式锁</code>来实现的；</p><h3 id="2-1-一致性行为"><a href="#2-1-一致性行为" class="headerlink" title="2.1 一致性行为"></a>2.1 一致性行为</h3><p>在<code>JanusGraph</code>中主要有三种<code>一致性修饰词(Consistency Modifier)</code>来表示3种不同的<code>一致性行为</code>，来控制图库使用过程中的并发问题的控制程度；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConsistencyModifier</span> </span>&#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    LOCK,</span><br><span class="line">    FORK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中<code>ConsistencyModifier</code>枚举类主要作用：用于控制JanusGraph在<code>最终一致或其他非事务性后端系统</code>上的一致性行为！其作用分别为：</p><ul><li><strong>DEFAULT</strong>：默认的一致性行为，不使用分布式锁进行控制，对配置的存储后端使用由封闭事务保证的默认一致性模型，一致性行为主要取决于存储后端的配置以及封闭事务的（可选）配置；无需显示配置即可使用</li><li><strong>LOCK</strong>：在存储后端支持锁的前提下，显示的获取分布式锁以保证一致性！确切的一致性保证取决于所配置的锁实现；需<code>management.setConsistency(element, ConsistencyModifier.LOCK);</code>语句进行配置</li><li><strong>FORK</strong>：只适用于<code>multi-edges</code>和<code>list-properties</code>两种情况下使用；使JanusGraph修改数据时，采用先删除后添加新的边/属性的方式，而不是覆盖现有的边/属性，从而避免潜在的并发写入冲突；需<code>management.setConsistency(element, ConsistencyModifier.FORK);</code>进行配置</li></ul><h4 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h4><p> 在查询或者插入数据时，是否使用<code>分布式锁</code>进行并发控制，在图<code>shcema</code>的创建过程中，如上述可以通过配置<code>schema元素</code>为<code>ConsistencyModifier.LOCK</code>方式控制并发，则在使用过程中就会用<code>分布式锁</code>进行并发控制；</p><p>为了提高效率，JanusGraph默认不使用锁定。 因此，用户必须为定义<code>一致性约束</code>的每个架构元素决定是否使用锁定。 </p><p>使用<code>JanusGraphManagement.setConsistency（element，ConsistencyModifier.LOCK）</code>显式启用对架构元素的锁定</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mgmt = graph.openManagement() </span><br><span class="line">name = mgmt.makePropertyKey(<span class="string">&#x27;consistentName&#x27;</span>).dataType(String.class).make() </span><br><span class="line">index = mgmt.buildIndex(<span class="string">&#x27;byConsistentName&#x27;</span>, Vertex.class).addKey(name).unique().buildCompositeIndex() </span><br><span class="line">mgmt.setConsistency(name, ConsistencyModifier.LOCK) <span class="comment">// Ensures only one name per vertex </span></span><br><span class="line">mgmt.setConsistency(index, ConsistencyModifier.LOCK) <span class="comment">// Ensures name uniqueness in the graph </span></span><br><span class="line">mgmt.commit()</span><br></pre></td></tr></table></figure><h4 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h4><p>由于边缘作为单个记录存储在基础存储后端中，因此同时修改单个边缘将导致冲突。 </p><p><code>FORK</code>就是为了代替<code>LOCK</code>，可以将边缘标签配置为使用<code>ConsistencyModifier.FORK</code>。 </p><p>下面的示例创建一个新的edge label，并将其设置为<code>ConsistencyModifier.FORK</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mgmt = graph.openManagement() </span><br><span class="line">related = mgmt.makeEdgeLabel(<span class="string">&#x27;related&#x27;</span>).make() </span><br><span class="line">mgmt.setConsistency(related, ConsistencyModifier.FORK) </span><br><span class="line">mgmt.commit()</span><br></pre></td></tr></table></figure><p>经过上述配置后，修改标签配置为<code>FORK</code>的edge时，操作步骤为：</p><ol><li>首先，删除该边</li><li>将修改后的边作为新边添加</li></ol><p>因此，如果两个并发事务修改了同一边缘，则提交时将存在边缘的两个修改后的副本，可以在查询遍历期间根据需要解决这些副本。</p><p>注意edge fork仅适用于MULTI edge。 具有多重性约束的边缘标签不能使用此策略，因为非MULTI的边缘标签定义中内置了一个唯一性约束，该约束需要显式锁定或使用基础存储后端的冲突解决机制</p><p>下面我们具体来看一下<code>janusgrph</code>的<code>锁机制</code>的实现：</p><h3 id="2-2-LoackID"><a href="#2-2-LoackID" class="headerlink" title="2.2 LoackID"></a>2.2 LoackID</h3><p>在介绍锁机制之前，先看一下锁应该锁什么东西呢？</p><p>我们都知道在<code>janusgraph</code>的底层存储中，vertexId作为Rowkey，属性和边存储在cell中，由column+value组成</p><p>当我们修改<code>节点的属性和边</code>+<code>边的属性时</code>，很明显只要锁住对应的<code>Rowkey + Column</code>即可；</p><p>在<code>Janusgraph</code>中，这个锁的标识的基础部分就是<code>LockID</code>：</p><blockquote><p>LockID = RowKey + Column</p></blockquote><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeyColumn lockID = <span class="keyword">new</span> KeyColumn(key, column);</span><br></pre></td></tr></table></figure><h3 id="2-3-本地锁"><a href="#2-3-本地锁" class="headerlink" title="2.3 本地锁"></a>2.3 本地锁</h3><p><code>本地锁</code>是在任何情况下都需要获取的一个锁，只有获取成功后，才会进行下述<code>分布式锁</code>的获取！</p><p><code>本地锁</code>是基于<code>图实例</code>维度存在的；主要作用是保证当前图实例下的操作中无冲突！</p><p>本地锁的实现是通过<code>ConcurrentHashMap</code>数据结构来实现的，在图实例维度下唯一； </p><p>基于当前<code>事务</code>+<code>lockId</code>来作为<code>锁标识</code>；</p><p><strong>获取的主要流程：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9e6da024452de3eb2ac72cc15d8daf60.png" alt="image-20200810170411991"></p><p><strong>结合源码如下：</strong></p><p>上述图建议依照源码一块分析，源码在<code>LocalLockMediator</code>类中的下述方法，下面<code>源码分析模块</code>会详细分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(KeyColumn kc, T requester, Instant expires)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入本地锁机制，主要目的：</strong> 在图实例维度来做一层锁判断，<code>减少分布式锁的并发冲突</code>，减少分布式锁带来的性能消耗</p><h3 id="2-4-分布式锁"><a href="#2-4-分布式锁" class="headerlink" title="2.4 分布式锁"></a>2.4 分布式锁</h3><p>在<code>本地锁</code>获取成功之后才会去尝试获取<code>分布式锁</code>；</p><p>分布式锁的获取整体分为两部分流程：</p><ol><li><code>分布式锁信息插入</code></li><li><code>分布式锁信息状态判断</code></li></ol><h4 id="分布式锁信息插入"><a href="#分布式锁信息插入" class="headerlink" title="分布式锁信息插入"></a>分布式锁信息插入</h4><p>该部分主要是通过<code>lockID</code>来构造要插入的<code>Rowkey和column</code>并将数据插入到<code>hbase</code>中；插入成功即表示这部分处理成功！</p><p>具体流程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c7d2707674f5b8029da1f146350cdf91.png" alt="2"></p><h4 id="分布式锁信息状态判断"><a href="#分布式锁信息状态判断" class="headerlink" title="分布式锁信息状态判断"></a>分布式锁信息状态判断</h4><p>该部分在上一部分完成之后才会进行，主要是判断分布式锁是否获取成功！</p><p>查询出当前hbase中对应<code>Rowkey的所有column</code>，过滤未过期的column集合，比对集合的第一个column是否等于当前事务插入的column；</p><p>等于则获取成功！不等于则获取失败！</p><p>具体流程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e335e5d11f814fd448ce065fa20dce9e.png" alt="3"></p><h2 id="三：源码分析-与-整体流程"><a href="#三：源码分析-与-整体流程" class="headerlink" title="三：源码分析 与 整体流程"></a>三：源码分析 与 整体流程</h2><p>源码分析已经push到github：<a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p><p><strong>1、获取锁的入口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(StaticBuffer key, StaticBuffer column, StaticBuffer expectedValue, StoreTransaction txh)</span> <span class="keyword">throws</span> BackendException </span>&#123;</span><br><span class="line">    <span class="comment">// locker是一个一致性key锁对象</span></span><br><span class="line">    <span class="keyword">if</span> (locker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前事务对象</span></span><br><span class="line">        ExpectedValueCheckingTransaction tx = (ExpectedValueCheckingTransaction) txh;</span><br><span class="line">        <span class="comment">// 判断：当前的获取锁操作是否当前事务的操作中存在增删改的操作</span></span><br><span class="line">        <span class="keyword">if</span> (tx.isMutationStarted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(<span class="string">&quot;Attempted to obtain a lock after mutations had been persisted&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用key+column组装为lockID，供下述加锁使用！！！！！</span></span><br><span class="line">        KeyColumn lockID = <span class="keyword">new</span> KeyColumn(key, column);</span><br><span class="line">        log.debug(<span class="string">&quot;Attempting to acquireLock on &#123;&#125; ev=&#123;&#125;&quot;</span>, lockID, expectedValue);</span><br><span class="line">        <span class="comment">// 获取本地当前jvm进程中的写锁（看下述的 1：写锁获取分析）</span></span><br><span class="line">        <span class="comment">// （此处的获取锁只是将对应的KLV存储到Hbase中！存储成功并不代表获取锁成功）</span></span><br><span class="line">        <span class="comment">// 1. 获取成功（等同于存储成功）则继续执行</span></span><br><span class="line">        <span class="comment">// 2. 获取失败（等同于存储失败），会抛出异常，抛出到最上层，打印错误日志“Could not commit transaction [&quot;+transactionId+&quot;] due to exception” 并抛出对应的异常，本次插入数据结束</span></span><br><span class="line">        locker.writeLock(lockID, tx.getConsistentTx());</span><br><span class="line">        <span class="comment">// 执行前提：上述获取锁成功！</span></span><br><span class="line">        <span class="comment">// 存储期望值，此处为了实现当相同的key + value + tx多个加锁时，只处理第一个</span></span><br><span class="line">        <span class="comment">// 存储在事务对象中，标识在commit判断锁是否获取成功时，当前事务插入的是哪个锁信息</span></span><br><span class="line">        tx.storeExpectedValue(<span class="keyword">this</span>, lockID, expectedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// locker为空情况下，直接抛出一个运行时异常，终止程序</span></span><br><span class="line">        store.acquireLock(key, column, expectedValue, unwrapTx(txh));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行 locker.writeLock(lockID, tx.getConsistentTx()) 触发锁获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">(KeyColumn lockID, StoreTransaction tx)</span> <span class="keyword">throws</span> TemporaryLockingException, PermanentLockingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != tx.getConfiguration().getGroupName()) &#123;</span><br><span class="line">        MetricManager.INSTANCE.getCounter(tx.getConfiguration().getGroupName(), M_LOCKS, M_WRITE, M_CALLS).inc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前事务是否在图实例的维度 已经占据了lockID的锁</span></span><br><span class="line">    <span class="comment">// 此处的lockState在一个事务成功获取本地锁+分布式锁后，以事务为key、value为map，其中key为lockID，value为加锁状态（开始时间、过期时间等）</span></span><br><span class="line">    <span class="keyword">if</span> (lockState.has(tx, lockID)) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Transaction &#123;&#125; already wrote lock on &#123;&#125;&quot;</span>, tx, lockID);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前事务没有占据lockID对应的锁</span></span><br><span class="line">    <span class="comment">// 进行(lockLocally(lockID, tx） 本地加锁锁定操作，</span></span><br><span class="line">    <span class="keyword">if</span> (lockLocally(lockID, tx)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在本地锁获取成功的前提下：</span></span><br><span class="line">            <span class="comment">// 尝试获取基于Hbase实现的分布式锁；</span></span><br><span class="line">            <span class="comment">// 注意！！！（此处的获取锁只是将对应的KLV存储到Hbase中！存储成功并不代表获取锁成功）</span></span><br><span class="line">            S stat = writeSingleLock(lockID, tx);</span><br><span class="line">            <span class="comment">// 获取锁分布式锁成功后（即写入成功后），更新本地锁的过期时间为分布式锁的过期时间</span></span><br><span class="line">            lockLocally(lockID, stat.getExpirationTimestamp(), tx); <span class="comment">// update local lock expiration time</span></span><br><span class="line">            <span class="comment">// 将上述获取的锁，存储在标识当前存在锁的集合中Map&lt;tx,Map&lt;lockID,S&gt;&gt;，  key为事务、value中的map为当前事务获取的锁，key为lockID，value为当前获取分布式锁的ConsistentKeyStatus（一致性密匙状态）对象</span></span><br><span class="line">            lockState.take(tx, lockID, stat);</span><br><span class="line">            ok = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TemporaryBackendException tse) &#123;</span><br><span class="line">            <span class="comment">// 在获取分布式锁失败后，捕获该异常，并抛出该异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryLockingException(tse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AssertionError ae) &#123;</span><br><span class="line">            <span class="comment">// Concession to ease testing with mocks &amp; behavior verification</span></span><br><span class="line">            ok = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> ae;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 出现底层存储错误！ 则直接加锁失败！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否成功获取锁，没有获分布式锁的，则释放本地锁</span></span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                <span class="comment">// 没有成功获取锁，则释放本地锁</span></span><br><span class="line">                <span class="comment">// lockState.release(tx, lockID); // has no effect</span></span><br><span class="line">                unlockLocally(lockID, tx);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tx.getConfiguration().getGroupName()) &#123;</span><br><span class="line">                    MetricManager.INSTANCE.getCounter(tx.getConfiguration().getGroupName(), M_LOCKS, M_WRITE, M_EXCEPTIONS).inc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取本地锁失败，则直接抛出异常，不进行重新本地争用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fail immediately with no retries on local contention</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PermanentLockingException(<span class="string">&quot;Local lock contention&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含两个部分：</p><ol><li>本地锁的获取<code>lockLocally(lockID, tx)</code></li><li>分布式锁的获取<code>writeSingleLock(lockID, tx)</code>   注意此处只是将锁信息写入到Hbase中，并不代表获取分布式锁成功，只是做了上述介绍的第一个阶段<code>分布式锁信息插入</code></li></ol><p><strong>3、本地锁获取 <code>lockLocally(lockID, tx)</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(KeyColumn kc, T requester, Instant expires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> <span class="keyword">null</span> != kc;</span><br><span class="line">      <span class="keyword">assert</span> <span class="keyword">null</span> != requester;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> StackTraceElement[] acquiredAt = log.isTraceEnabled() ?</span><br><span class="line">              <span class="keyword">new</span> Throwable(<span class="string">&quot;Lock acquisition by &quot;</span> + requester).getStackTrace() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// map的value，以事务为核心</span></span><br><span class="line">      <span class="keyword">final</span> AuditRecord&lt;T&gt; audit = <span class="keyword">new</span> AuditRecord&lt;&gt;(requester, expires, acquiredAt);</span><br><span class="line">      <span class="comment">//  ConcurrentHashMap实现locks, 以lockID为key，事务为核心value</span></span><br><span class="line">      <span class="keyword">final</span> AuditRecord&lt;T&gt; inMap = locks.putIfAbsent(kc, audit);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 代表当前map中不存在lockID，标识着锁没有被占用，成功获取锁</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == inMap) &#123;</span><br><span class="line">          <span class="comment">// Uncontended lock succeeded</span></span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;New local lock created: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125;&quot;</span>,</span><br><span class="line">                  kc, name, requester);</span><br><span class="line">          &#125;</span><br><span class="line">          success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inMap.equals(audit)) &#123;</span><br><span class="line">          <span class="comment">// 代表当前存在lockID，比对旧value和新value中的事务对象是否是同一个</span></span><br><span class="line">          <span class="comment">// requester has already locked kc; update expiresAt</span></span><br><span class="line">          <span class="comment">// 上述判断后，事务对象为同一个，标识当前事务已经获取这个lockID的锁；</span></span><br><span class="line">          <span class="comment">// 1. 这一步进行cas替换，作用是为了刷新过期时间</span></span><br><span class="line">          <span class="comment">// 2. 并发处理，如果因为锁过期被其他事务占据，则占用锁失败</span></span><br><span class="line">          success = locks.replace(kc, inMap, audit);</span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                  log.trace(<span class="string">&quot;Updated local lock expiration: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; oldexp=&#123;&#125; newexp=&#123;&#125;&quot;</span>,</span><br><span class="line">                      kc, name, requester, inMap.expires, audit.expires);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.trace(<span class="string">&quot;Failed to update local lock expiration: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; oldexp=&#123;&#125; newexp=&#123;&#125;&quot;</span>,</span><br><span class="line">                      kc, name, requester, inMap.expires, audit.expires);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &gt; inMap.expires.compareTo(times.getTime())) &#123;</span><br><span class="line">          <span class="comment">// 比较过期时间，如果锁已经过期，则当前事务可以占用该锁</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// the recorded lock has expired; replace it</span></span><br><span class="line">          <span class="comment">// 1. 当前事务占用锁</span></span><br><span class="line">          <span class="comment">// 2. 并发处理，如果因为锁过期被其他事务占据，则占用锁失败</span></span><br><span class="line">          success = locks.replace(kc, inMap, audit);</span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;Discarding expired lock: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; expired=&#123;&#125;&quot;</span>,</span><br><span class="line">                  kc, name, inMap.holder, inMap.expires);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 标识：锁被其他事务占用，并且未过期，则占用锁失败</span></span><br><span class="line">          <span class="comment">// we lost to a valid lock</span></span><br><span class="line">          <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">              log.trace(<span class="string">&quot;Local lock failed: &#123;&#125; namespace=&#123;&#125; txn=&#123;&#125; (already owned by &#123;&#125;)&quot;</span>,</span><br><span class="line">                  kc, name, requester, inMap);</span><br><span class="line">              log.trace(<span class="string">&quot;Owner stacktrace:\n        &#123;&#125;&quot;</span>, Joiner.on(<span class="string">&quot;\n        &quot;</span>).join(inMap.acquiredAt));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上述介绍，本地锁的实现是通过<code>ConcurrentHashMap</code>数据结构来实现的，在图实例维度下唯一！</p><p><strong>4、分布式锁获取第一个阶段：分布式锁信息插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConsistentKeyLockStatus <span class="title">writeSingleLock</span><span class="params">(KeyColumn lockID, StoreTransaction txh)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装插入hbase数据的Rowkey</span></span><br><span class="line">    <span class="keyword">final</span> StaticBuffer lockKey = serializer.toLockKey(lockID.getKey(), lockID.getColumn());</span><br><span class="line">    StaticBuffer oldLockCol = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行尝试插入 ，默认尝试次数3次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lockRetryCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 尝试将数据插入到hbase中；oldLockCol表示要删除的column代表上一次尝试插入的数据</span></span><br><span class="line">        WriteResult wr = tryWriteLockOnce(lockKey, oldLockCol, txh);</span><br><span class="line">        <span class="comment">// 如果插入成功</span></span><br><span class="line">        <span class="keyword">if</span> (wr.isSuccessful() &amp;&amp; wr.getDuration().compareTo(lockWait) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Instant writeInstant = wr.getWriteTimestamp(); <span class="comment">// 写入时间</span></span><br><span class="line">            <span class="keyword">final</span> Instant expireInstant = writeInstant.plus(lockExpire);<span class="comment">// 过期时间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConsistentKeyLockStatus(writeInstant, expireInstant); <span class="comment">// 返回插入对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值当前的尝试插入的数据，要在下一次尝试时删除</span></span><br><span class="line">        oldLockCol = wr.getLockCol();</span><br><span class="line">        <span class="comment">// 判断插入失败原因，临时异常进行尝试，非临时异常停止尝试！</span></span><br><span class="line">        handleMutationFailure(lockID, lockKey, wr, txh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理在尝试了3次之后还是没插入成功的情况，删除最后一次尝试插入的数据</span></span><br><span class="line">    tryDeleteLockOnce(lockKey, oldLockCol, txh);</span><br><span class="line">    <span class="comment">// TODO log exception or successful too-slow write here</span></span><br><span class="line">    <span class="comment">// 抛出异常，标识导入数据失败</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryBackendException(<span class="string">&quot;Lock write retry count exceeded&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述只是将锁信息插入，插入成功标识该流程结束</p><p><strong>5、分布式锁获取第一个阶段：分布式锁锁定是否成功判定</strong></p><p>这一步，是在<code>commit</code>阶段进行的验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> BackendException </span>&#123;</span><br><span class="line">    <span class="comment">// 此方法内调用checkSingleLock 检查分布式锁的获取结果</span></span><br><span class="line">    flushInternal();</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>checkSingleLock</code>方法，判断获取锁的状态！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkSingleLock</span><span class="params">(<span class="keyword">final</span> KeyColumn kc, <span class="keyword">final</span> ConsistentKeyLockStatus ls,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> StoreTransaction tx)</span> <span class="keyword">throws</span> BackendException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否被检查过</span></span><br><span class="line">    <span class="keyword">if</span> (ls.isChecked())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice the store</span></span><br><span class="line">    KeySliceQuery ksq = <span class="keyword">new</span> KeySliceQuery(serializer.toLockKey(kc.getKey(), kc.getColumn()), LOCK_COL_START,</span><br><span class="line">        LOCK_COL_END);</span><br><span class="line">    <span class="comment">// 此处从hbase中查询出锁定的行的所有列！ 默认查询重试次数3</span></span><br><span class="line">    List&lt;Entry&gt; claimEntries = getSliceWithRetries(ksq, tx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从每个返回条目的列中提取timestamp和rid，然后过滤出带有过期时间戳的timestamp对象</span></span><br><span class="line">    <span class="keyword">final</span> Iterable&lt;TimestampRid&gt; iterable = Iterables.transform(claimEntries,</span><br><span class="line">        e -&gt; serializer.fromLockColumn(e.getColumnAs(StaticBuffer.STATIC_FACTORY), times));</span><br><span class="line">    <span class="keyword">final</span> List&lt;TimestampRid&gt; unexpiredTRs = <span class="keyword">new</span> ArrayList&lt;&gt;(Iterables.size(iterable));</span><br><span class="line">    <span class="keyword">for</span> (TimestampRid tr : iterable) &#123; <span class="comment">// 过滤获取未过期的锁！</span></span><br><span class="line">        <span class="keyword">final</span> Instant cutoffTime = now.minus(lockExpire);</span><br><span class="line">        <span class="keyword">if</span> (tr.getTimestamp().isBefore(cutoffTime)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将还未过期的锁记录存储到一个集合中</span></span><br><span class="line">        unexpiredTRs.add(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断当前tx是否成功持有锁！ 如果我们插入的列是读取的第一个列，或者前面的列只包含我们自己的rid（因为我们是在第一部分的前提下获取的锁，第一部分我们成功获取了基于当前进程的锁，所以如果rid相同，代表着我们也成功获取到了当前的分布式锁），那么我们持有锁。否则，另一个进程持有该锁，我们无法获得锁</span></span><br><span class="line">    <span class="comment">// 如果，获取锁失败，抛出TemporaryLockingException异常！！！！ 抛出到顶层的mutator.commitStorage()处，最终导入失败进行事务回滚等操作</span></span><br><span class="line">    checkSeniority(kc, ls, unexpiredTRs);</span><br><span class="line">    <span class="comment">// 如果上述步骤未抛出异常，则标识当前的tx已经成功获取锁！</span></span><br><span class="line">    ls.setChecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：整体流程"><a href="#四：整体流程" class="headerlink" title="四：整体流程"></a>四：整体流程</h2><p>总流程如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/257a9bbcc1110d06a8f52ce09906cd16.png" alt="4"></p><p><strong>整体流程为：</strong> </p><ol><li>获取本地锁</li><li>获取分布式锁<ol><li>插入分布式锁信息</li><li>commit阶段判断分布式锁获取是否成功</li></ol></li><li>获取失败，则重试</li></ol><h2 id="五：总结"><a href="#五：总结" class="headerlink" title="五：总结"></a>五：总结</h2><p>JanusGraph的锁机制主要是通过<code>本地锁+分布式锁</code>来实现分布式系统下的数据一致性；</p><p>分布式锁的控制维度为：property、vertex、edge、index都可以；</p><p><code>JanusGraph</code>支持在数据导入时通过前面<code>一致性行为</code>部分所说的<code>LOCK</code>来开关分布式锁：</p><ul><li>LOCK：数据导入时开启分布式锁保证分布式一致性</li><li>DEFAULT、FORK：数据导入时关闭分布式锁</li></ul><p><strong>是否开启分布式锁思考：</strong></p><p>在开启分布式锁的情况下，数据导入开销非常大；如果是数据不是要求很高的一致性，并且数据量比较大，我们可以选择关闭分布式锁相关，来提高导入速度；</p><p>然后，针对于小数据量的要求高一致性的数据，单独开启分布式锁来保证数据安全；</p><p>另外，我们在不开启分布式锁定的情况下，可以通过针对于导入的<code>数据的充分探查</code>来减少冲突！</p><p>针对于图schema的元素开启还是关闭分布式锁，还是根据实际业务情况来决定。</p><blockquote><p>本文有任何问题，可加博主微信或评论指出，感谢！</p><p>码文不易，给个赞和star吧~   </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分布式系统中，难免涉及到对同一数据的并发操作，如何保证分布式系统中数据的并发安全呢？&lt;strong&gt;分布式锁！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>问题解决-idea 本地仓库中包含jar包，但是pom依赖文件标红</title>
    <link href="http://coderstudy.vip/article/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-idea_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%ABjar%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AFpom%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E6%A0%87%E7%BA%A2.html"/>
    <id>http://coderstudy.vip/article/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-idea_%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%ABjar%E5%8C%85%EF%BC%8C%E4%BD%86%E6%98%AFpom%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E6%A0%87%E7%BA%A2.html</id>
    <published>2021-03-03T07:26:58.125Z</published>
    <updated>2021-03-03T07:26:58.121Z</updated>
    
    <content type="html"><![CDATA[<p>现象，maven的本地仓库中，明明存在这个包，但是在项目的pom文件中就是标红报错，<code>reimport</code>也不可以，这次编译一个框架的源码时遇到了这个问题，解决了一下，下面说下解决方法：</p><span id="more"></span><p>首先，确认<code>本地仓库存在该标红的jar包，版本也是对的！</code></p><p>主要原因是因为，maven的<code>本地仓库的索引（index）</code>没有被更新为<code>最新</code>的问题，项目导入依赖时通过索引就拿不到对应的jar包，就报错。</p><p><code>解决方案</code>：idea编译器</p><ol><li>file -&gt; settings -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt;  Maven -&gt; Repositories</li><li>选择本地仓库地址，点击右侧update<br><img src="https://img-blog.csdnimg.cn/20200529170350731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>等待更新完毕</li><li>重启idea，解决~</li></ol><p>当然，idea还是很友好的，你把鼠标指到对应的标红出，<code>alt+entre</code>就会看到显示出下面的提示：<br><img src="https://img-blog.csdnimg.cn/20200529192047721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择第一个<code>update maven indices</code> 更新maven索引，点击，就会看到在更新索引了，同上面的效果一样~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现象，maven的本地仓库中，明明存在这个包，但是在项目的pom文件中就是标红报错，&lt;code&gt;reimport&lt;/code&gt;也不可以，这次编译一个框架的源码时遇到了这个问题，解决了一下，下面说下解决方法：&lt;/p&gt;</summary>
    
    
    
    <category term="问题解决" scheme="http://coderstudy.vip/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="idea" scheme="http://coderstudy.vip/tags/idea/"/>
    
    <category term="maven" scheme="http://coderstudy.vip/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>编程之美，从线程池状态管理来看二进制操作之美</title>
    <link href="http://coderstudy.vip/article/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%8C%E4%BB%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9D%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%BE%8E.html"/>
    <id>http://coderstudy.vip/article/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%8C%E4%BB%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9D%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%BE%8E.html</id>
    <published>2021-03-03T07:26:52.210Z</published>
    <updated>2021-03-03T07:26:52.205Z</updated>
    
    <content type="html"><![CDATA[<p><code>二进制操作</code>在框架设计中被频繁使用，使用二进制在不同场景有提升<code>计算速度</code>、<code>较少内存占用</code>等多种优点；</p><p>下面，我们依据线程池的状态管理，来看下怎么通过操作二进制对状态进行管理，过程中会发现<code>编程之美~</code> </p><span id="more"></span><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>首先，为了文章的完整性，我们还是先了解一下线程池的状态，总结如下如：<br><img src="https://img-blog.csdnimg.cn/20200814142817783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>线程池状态分为5种</strong>：<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code></p><h3 id="状态代表的含义"><a href="#状态代表的含义" class="headerlink" title="状态代表的含义"></a>状态代表的含义</h3><ul><li>RUNNING：（运行）接收新task，并且处理正在排队的task，不中断正在执行的任务</li><li>SHUTDOWN：（关闭）不接受新的task，只处理正在排队的task，不中断正在执行的任务</li><li>STOP：（停止）不接受新的task，也不处理正在排队的task，并且中断正在执行的任务</li><li>TIDYING：（整理）所有的task都已经终止，上述提到的workCount当前活跃线程数为0，被中断的任务和正在排队的任务执行当前任务的terminated()钩子方法</li><li>TERMINATED：（已终止）标识上述的TIDYING的过程结束，标识当前线程池成功完全停止的状态</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>大致的流程就是：</p><p><code>RUNNING</code>  –&gt; <code>SHUTDOWN</code> –&gt; <code>STOP</code> –&gt; <code>TIDYING</code> –&gt; <code>TERMINATED</code></p><p>上述流程是一个单方向的顺序，也就是说不会出现类似于<code>STOP</code> –&gt; <code>SHUTDOWN</code> 这种情况；</p><p>另外，并不是每一个状态多必须经过的；</p><p><strong>什么时候进行线程池的状态转换呢？</strong></p><ul><li>RUNNING -&gt; SHUTDOWN：调用终止线程的方法<code>shutdown()</code>后</li><li>RUNNING or SHUTDOWN -&gt; STOP：调用<code>shutdownNow()</code>方法后，不管当前在RUNNING状态还是SHUTDOWN状态，都是直接转为STOP状态</li><li>SHUTDOWN -&gt; TIDYING：SHUTDOWN状态下当等待队列 和 正在执行的任务 都为空时，状态转为TIDYING</li><li>STOP -&gt; TIDYING：STOP状态下当正在执行的任务全部中断完毕后，状态转为TIDYING</li><li>TIDYING -&gt; TERMINATED：TIDYING状态下当所有的terminated()钩子方法全部执行完毕后，状态转为TERMINATED，线程池关闭完毕！</li></ul><h2 id="管理线程池状态"><a href="#管理线程池状态" class="headerlink" title="管理线程池状态"></a>管理线程池状态</h2><p>线程池中管理线程池状态 和 线程池当前活跃线程数，是通过一个AtomicInteger变量来管理这两个状态的</p><p>什么？ 一个变量管理两个这么不相干的状态？ 对的;</p><h3 id="CTL变量何许人也"><a href="#CTL变量何许人也" class="headerlink" title="CTL变量何许人也"></a>CTL变量何许人也</h3><p>让我们来看一下线程池针对这部分的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;  <span class="keyword">return</span> c &lt; SHUTDOWN;&#125;</span><br></pre></td></tr></table></figure><p><strong>下面，我们来剖析一下上述的实现：</strong><br>线程池包含5种状态如下：具体线程的状态代表的含义和状态的转换，下面会有讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>我们知道在java中 int 类型占用4个字节32位存储， 上述的几种状态：<br>底层存储二进制为：</p><blockquote><p>1111 1111 1111 1111 1111 1111 1111 1111(-1)<br>0000 0000 0000 0000 0000 0000 0000 0000(0)<br>0000 0000 0000 0000 0000 0000 0000 0001(1)<br>0000 0000 0000 0000 0000 0000 0000 0010(2)<br>0000 0000 0000 0000 0000 0000 0000 0011(3)</p></blockquote><p><code>左移&lt;&lt;COUNT_BITS位</code>，<code> COUNT_BITS = Integer.SIZE - 3</code> 也就是 <code>COUNT_BITS = 29</code>，改句子说明用32位的前3位存储线程池的状态<br>后29位存储线程池中当前线程的个数， <code>&lt;&lt; COUNT_BITS</code>后，变为下面的二进制：</p><blockquote><p>1110 0000 0000 0000 0000 0000 0000 0000<br>0000 0000 0000 0000 0000 0000 0000 0000<br>0010 0000 0000 0000 0000 0000 0000 0000<br>0100 0000 0000 0000 0000 0000 0000 0000<br>0110 0000 0000 0000 0000 0000 0000 0000</p></blockquote><p>我们可以看到，前三位存储的是 标识线程状态的二进制</p><p>对于初始化存储这些状态的变量<code> AtomicInteger ctl</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>初始化AtomicInteger变量<code>ctl</code>，其中<code>ctlOf(RUNNING, 0)</code> 代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中rs标识线程池当前状态，wc为work count标识当前工作线程的数量</p><p>上述传入的是<code>ctlOf(RUNNING, 0)</code> ，当前状态为RUNING也就是<code>1110 0000 0000 0000 0000 0000 0000 0000</code> ，wc为0，也就是当前工作线程数为0，其二进制为<code>0000 0000 0000 0000 0000 0000 0000 0000</code> ，做<code>&quot;|&quot;</code>或操作，即</p><blockquote><p>1110 0000 0000 0000 0000 0000 0000 0000 | 0000 0000 0000 0000 0000 0000 0000 0000<br>= 1110 0000 0000 0000 0000 0000 0000 0000</p></blockquote><p>上述得到的结果<code>1110 0000 0000 0000 0000 0000 0000 0000</code>就标识，当前线程池状态为RUNNING，线程池活跃线程个数为0！</p><h3 id="如何管理？"><a href="#如何管理？" class="headerlink" title="如何管理？"></a>如何管理？</h3><p><strong>通过上述创建的ctl变量获取 线程池当前状态 和 线程中活跃线程个数 这两个状态：</strong></p><p>获取线程池当前状态，我们可以想一下该如何获取呢？ 现在知道的是ctl的前3位是线程池的状态，那我们直接构造一个前三位为1，后29位为0的int即可，然后取余就可以了呗，下面看下源码的实现，就是如此：<br>使用方法<code>runStateOf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br></pre></td></tr></table></figure><p>其中<code>CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1</code> 转化为二进制为：<br><code>0001 1111 1111 1111 1111 1111 1111 1111</code><br>取反”<del>“后，二进制为：<br><code>1110 0000 0000 0000 0000 0000 0000 0000</code><br>也就是将前3位全部变为1，后面全部变为0；<br>接下来，传入的ctl变量和`</del>CAPACITY`做“&amp;”操作，只会保留ctl变量的前3位变量，后29位变量全部为0；</p><p>例如：一个标识当前状态为STOP状态的线程池和当前活跃线程数为3的ctl变量为：<br><code>0010 0000 0000 0000 0000 0000 0000 0011</code><br>和上述得到的<code>1110 0000 0000 0000 0000 0000 0000 0000</code>做“&amp;”操作后得到：<br><code>0010 0000 0000 0000 0000 0000 0000 0000</code> 和上述分析的STOP的状态的二进制相同！ 即获得了当前线程的状态！</p><p>获取线程池当前状态，也很简单，我们知道ctl变量的32的后29位存储的是当前活跃线程数，直接构造一个前三位为0，后29位为1的int即可，然后取余就可以获取到了<br>使用方法<code>workerCountOf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><p>上述知道CAPACITY为：<code>0001 1111 1111 1111 1111 1111 1111 1111</code>  </p><p>例如：一个标识当前状态为STOP状态的线程池和当前活跃线程数为3的ctl变量为：<br><code>0010 0000 0000 0000 0000 0000 0000 0011</code> 和 <code>0001 1111 1111 1111 1111 1111 1111 1111</code> 取与后:<br><code>0000 0000 0000 0000 0000 0000 0000 0011</code><br>标识当前线程池中活跃线程数量为3！</p><h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><p><strong>1、计算ctl的值</strong></p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中，入参rs代表当前线程状态，wc代表当前活跃线程数，取“|”或即可<br>上述代码不出现问题的前提是：rs只使用的前3位，wc只使用了后29位！</p><p><strong>2、判断当前线程池是否正在运行</strong></p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;  <span class="keyword">return</span> c &lt;小于SHUTDOWN;&#125;值即可！</span><br></pre></td></tr></table></figure><p>上述我们知道，5中状态只有RUNNING小于0，SHUTDOWN状态等于0，其他的都是大于0的，所以我们直接把给定的ctl值小于SHUTDOWN值即可！</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>上述，我们介绍了 线程池的状态 管理部分，主要通过不同位置的二进制来进行标识不同的状态，工作学习还会发现更多巧妙美妙的设计，等待着作为程序员我们去发现；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;二进制操作&lt;/code&gt;在框架设计中被频繁使用，使用二进制在不同场景有提升&lt;code&gt;计算速度&lt;/code&gt;、&lt;code&gt;较少内存占用&lt;/code&gt;等多种优点；&lt;/p&gt;
&lt;p&gt;下面，我们依据线程池的状态管理，来看下怎么通过操作二进制对状态进行管理，过程中会发现&lt;code&gt;编程之美~&lt;/code&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://coderstudy.vip/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="线程池" scheme="http://coderstudy.vip/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="二进制" scheme="http://coderstudy.vip/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何解决内存泄漏问题？</title>
    <link href="http://coderstudy.vip/article/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F.html"/>
    <id>http://coderstudy.vip/article/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F.html</id>
    <published>2021-03-03T07:26:43.813Z</published>
    <updated>2021-03-03T07:26:43.808Z</updated>
    
    <content type="html"><![CDATA[<p>项目上线了一个接口，先灰度一台机器观察调用情况；<br>接口不断的调用，过了一段时间，发现机器上的接口调用开始报<code>OOM异常</code> ！<br>当天就是上线deadline了，刺激。。</p><span id="more"></span><h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><h4 id="第一步，使用jps命令获取出问题jvm进程的进程ID"><a href="#第一步，使用jps命令获取出问题jvm进程的进程ID" class="headerlink" title="第一步，使用jps命令获取出问题jvm进程的进程ID"></a>第一步，使用<code>jps</code>命令获取出问题jvm进程的进程ID</h4><p>使用<code>jps -l -m</code>获取到当前jvm进程的pid，通过上述命令获取到了服务的进程号：427726 （此处假设为这个）<br><img src="https://img-blog.csdnimg.cn/20200416192240963.png" alt="在这里插入图片描述"><br><strong>jps命令</strong></p><blockquote><p><code>jps</code>(JVM Process Status Tool)：显示指定系统内所有的HotSpot虚拟机进程<br><code>jps -l -m</code> ： 参数-l列出机器上所有jvm进程，-m显示出JVM启动时传递给main()的参数</p></blockquote><h4 id="第二步，使用jstat观察jvm状态，发现问题"><a href="#第二步，使用jstat观察jvm状态，发现问题" class="headerlink" title="第二步，使用jstat观察jvm状态，发现问题"></a>第二步，使用<code>jstat</code>观察jvm状态，发现问题</h4><blockquote><p>因为是OOM异常，所以我们首先重启机器观察了JVM的运行情况；</p></blockquote><p>我们使用<code>jstat -gc pid time</code>命令观察GC，发现GC在YGC后，GC掉的内存并不多，每次YGC后都有一部分内存未回收，导致在多次YGC后回收不掉的内存被挪到堆的old区，old满了之后FGC发现也是回收不掉；<br>这里基本可以确定是内存泄漏的问题了，下面我们有简单看了下机器的cpu、内存、磁盘状态</p><p><strong>jstat命令：</strong></p><blockquote><p><code>jstat</code>(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。<br><code>jstat -gc pid time</code> ： -gc 监控jvm的gc信息，pid 监控的jvm进程id，time每个多少毫秒刷新一次<br><code>jstat -gccause pid time</code>  ： -gccause 监控gc信息并显示上次gc原因，pid 监控的jvm进程id，time每个多少毫秒刷新一次<br><code>jstat -class pid time</code>： -class 监控jvm的类加载信息，pid 监控的jvm进程id，time每个多少毫秒刷新一次</p></blockquote><p><strong>在这里先简单说一下，堆的GC：</strong></p><blockquote><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。</p></blockquote><blockquote><p>年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的，minor GC会一直重复这样的过程。</p></blockquote><h4 id="第三步，观察机器状态，确认问题"><a href="#第三步，观察机器状态，确认问题" class="headerlink" title="第三步，观察机器状态，确认问题"></a>第三步，观察机器状态，确认问题</h4><p>使用<code>top -p pid</code>获取进程的cpu和内存使用率；查看RES 和 %CPU %MEM三个指标：<br><img src="https://img-blog.csdnimg.cn/20200416192252606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在这里先简单说一下，top命令展示的内容：</strong></p><blockquote><p>VIRT：virtual memory usage 虚拟内存<br>1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等<br>2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量</p></blockquote><blockquote><p>RES：resident memory usage 常驻内存<br>1、进程当前使用的内存大小，但不包括swap out<br>2、包含其他进程的共享<br>3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反<br>4、关于库占用内存的情况，它只统计加载的库文件所占内存大小</p></blockquote><blockquote><p>SHR：shared memory 共享内存<br>1、除了自身进程的共享内存，也包括其他进程的共享内存<br>2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小<br>3、计算某个进程所占的物理内存大小公式：RES – SHR<br>4、swap out后，它将会降下来</p></blockquote><blockquote><p>DATA<br>1、数据占用的内存。如果top没有显示，按f键可以显示出来。<br>2、真正的该程序要求的数据空间，是真正在运行中要使用的。</p></blockquote><blockquote><p>ps : 如果程序占用实存比较多，说明程序申请内存多，实际使用的空间也多。<br>如果程序占用虚存比较多，说明程序申请来很多空间，但是没有使用。</p></blockquote><p>发现机器的自身状态不存在问题， so毋庸置疑，发现问题了，典型的内存泄漏。。</p><h4 id="第四步，使用jmap获取jvm进程dump文件"><a href="#第四步，使用jmap获取jvm进程dump文件" class="headerlink" title="第四步，使用jmap获取jvm进程dump文件"></a>第四步，使用jmap获取jvm进程dump文件</h4><p>我们使用<code>jmap -dump:format=b,file=dump_file_name pid</code> 命令，将当前机器的jvm的状态dump下来或缺的一份dump文件，用做下面的分析</p><p><strong>jmap命令：</strong></p><blockquote><p><code>jmap</code>(JVM Memory Map)命令用于生成heap dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。<br><code>jmap -dump:format=b,file=dump_file_name pid</code> ： file=指定输出数据文件名， pid jvm进程号</p></blockquote><p>接下来，回滚灰度的机器，开始解决问题=.=</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><h4 id="第一步，dump文件分析"><a href="#第一步，dump文件分析" class="headerlink" title="第一步，dump文件分析"></a>第一步，dump文件分析</h4><p>在这里，我们分析dump文件，使用的<code>Jprofiler</code>软件，就是下面这个东东：<br><img src="https://img-blog.csdnimg.cn/20200416192308173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>具体的使用方法，在这就不再赘述了，下面将dump文件导入到<code>Jprofiler</code>中：<br>选择<code>Heap Walker</code> 中的<code>Current Object Set</code>，这里面显示的是当前的类的占用资源，从占用空间从大到小排序；<br><img src="https://img-blog.csdnimg.cn/20200416192318740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图中，没有观察出什么问题，我们点击<code>Biggest Objects</code>，查看哪个对象的占用的内存高：<br><img src="https://img-blog.csdnimg.cn/2020041619234123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图中，我们发现<code>org.janusgraph.graphdb.database.StandardJanusGraph</code>这个对象居然占用了高达<strong>724M</strong>的内存！ 看来内存泄漏八九不离十就是这个对象的问题了！<br>再点开看看 ，如下图，可以发现是一个<code>openTransactions</code>的类型为<code>ConcurrentHashMap</code>的数据结构：<br><img src="https://img-blog.csdnimg.cn/20200416192345326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="第二步，源码查找定位代码"><a href="#第二步，源码查找定位代码" class="headerlink" title="第二步，源码查找定位代码"></a>第二步，源码查找定位代码</h4><p>这到底是什么对象呢，去项目中查找一下，打开idea-打开项目-双击shift键-打开全局类查找-输入<code>StandardJanusGraph</code>，如下图：<br><img src="https://img-blog.csdnimg.cn/20200416192353268.png" alt="在这里插入图片描述"><br>发现是我们项目使用的图数据库<code>janusgraph</code>的一个类，找到对应的数据结构：<br>类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;StandardJanusGraphTx&gt; openTransactions;</span><br></pre></td></tr></table></figure><p>初始化为一个ConcurrentHashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openTransactions = Collections.newSetFromMap(<span class="keyword">new</span> </span><br><span class="line">ConcurrentHashMap&lt;StandardJanusGraphTx, Boolean&gt;(<span class="number">100</span>, </span><br><span class="line"><span class="number">0.75f</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>观察上述代码，我们可以看到，里面的存储的<code>StandardJanusGraphTx</code>从字面意义上理解是janusgraph框架中的事务对象，下面往上追一下代码，看看什么时候会往这个Map中赋值：<br>// 1. 找到执行openTransactions.add()的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StandardJanusGraphTx <span class="title">newTransaction</span><span class="params">(<span class="keyword">final</span> TransactionConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isOpen) ExceptionFactory.graphShutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StandardJanusGraphTx tx = <span class="keyword">new</span> StandardJanusGraphTx(<span class="keyword">this</span>, configuration);</span><br><span class="line">        tx.setBackendTransaction(openBackendTransaction(tx));</span><br><span class="line">        openTransactions.add(tx);  <span class="comment">// 注意！ 此处对上述的map对象进行了add</span></span><br><span class="line">        <span class="keyword">return</span> tx;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BackendException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JanusGraphException(<span class="string">&quot;Could not start new transaction&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> // 2. 上述发现，是一个newTransaction，创建事务的一个方法，为确保起见，再往上跟找到调用上述方法的类：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphTransaction <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     TransactionConfiguration immutable = <span class="keyword">new</span> ImmutableTxCfg(isReadOnly, hasEnabledBatchLoading,</span><br><span class="line">             assignIDsImmediately, preloadedData, forceIndexUsage, verifyExternalVertexExistence,</span><br><span class="line">             verifyInternalVertexExistence, acquireLocks, verifyUniqueness,</span><br><span class="line">             propertyPrefetching, singleThreaded, threadBound, getTimestampProvider(), userCommitTime,</span><br><span class="line">             indexCacheWeight, getVertexCacheSize(), getDirtyVertexSize(),</span><br><span class="line">             logIdentifier, restrictedPartitions, groupName,</span><br><span class="line">             defaultSchemaMaker, customOptions);</span><br><span class="line">     <span class="keyword">return</span> graph.newTransaction(immutable);  <span class="comment">// 注意！此处调用了上述的newTransaction方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br> // 3. 接着找上层调用，发现了最上层的方法<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphTransaction <span class="title">newTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTransaction().start();  <span class="comment">// 此处调用了上述的start方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>在我们对图数据库中图数据操作的过程中，采用的是手动创建事务的方式，在每次查询图数据库之前，我们都会调用类似于<code>dataDao.begin()</code>代码，<br>其中就是调用的<code> public JanusGraphTransaction newTransaction()</code>这个方法；</p><p>最后，我们简单的看下源码可以发现，从上述内存泄漏的map中去除数据的逻辑就是<code>commit</code>事务的接口，调用链如下：<br>// 1. 从openTransactions这个map中删除事务对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeTransaction</span><span class="params">(StandardJanusGraphTx tx)</span> </span>&#123;</span><br><span class="line">    openTransactions.remove(tx); <span class="comment">// 从map中删除StandardJanusGraphTx对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isOpen = <span class="keyword">false</span>;</span><br><span class="line">    graph.closeTransaction(<span class="keyword">this</span>); <span class="comment">// 调用上述closeTransaction方法</span></span><br><span class="line">    vertexCache.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 2. 最上层找到了commit方法，提交事务后就会将对应的事务对象从map中移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Preconditions.checkArgument(isOpen(), <span class="string">&quot;The transaction has already been closed&quot;</span>);</span><br><span class="line">     <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != config.getGroupName()) &#123;</span><br><span class="line">         MetricManager.INSTANCE.getCounter(config.getGroupName(), <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;commit&quot;</span>).inc();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (hasModifications()) &#123;</span><br><span class="line">             graph.commit(addedRelations.getAll(), deletedRelations.values(), <span class="keyword">this</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             txHandle.commit();  <span class="comment">// 这个commit方法中释放事务也是调用releaseTransaction</span></span><br><span class="line">         &#125;</span><br><span class="line">         success = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             txHandle.rollback();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BackendException e1) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> JanusGraphException(<span class="string">&quot;Could not rollback after a failed commit&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> JanusGraphException(<span class="string">&quot;Could not commit transaction due to exception during persistence&quot;</span>, e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         releaseTransaction();  <span class="comment">// // 调用releaseTransaction</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != config.getGroupName() &amp;&amp; !success) &#123;</span><br><span class="line">             MetricManager.INSTANCE.getCounter(config.getGroupName(), <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;commit.exceptions&quot;</span>).inc();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>终于，我们找到了内存泄漏的根源所在：项目代码中存在调用了事务<code>begin</code>但是没有<code>commit</code>的代码!</strong></p><h4 id="第三步，修复问题验证"><a href="#第三步，修复问题验证" class="headerlink" title="第三步，修复问题验证"></a>第三步，修复问题验证</h4><p><strong>解决问题</strong>： 找到内存泄漏接口的代码，并发现了没有commit()的位置，try-catch-finally中添加上了commit()代码；</p><p>提交-部署-发布-灰度一台机器后观察内存泄漏的现象消失，GC回收正常；</p><p><strong>内存泄漏问题解决，项目如期上线~</strong></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>对于内存泄漏导致的内存溢出问题，排查步骤大致如上述，总的步骤：找出问题（GC、CPU、磁盘、内存、网络），定位问题（使用第三方工具分析dump文件等），解决问题； </p><p>另外，内存泄漏的分析方法有好多种，但是大致原理和流程都是相似的；</p><blockquote><p>原创不易，如果大家有所收获，希望大家可以<strong>点赞评论</strong>支持一下~</p></blockquote><p><strong>也欢迎大家关注我的CSDN支持一下作者，作者定期分享工作中的所见所得~</strong> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目上线了一个接口，先灰度一台机器观察调用情况；&lt;br&gt;接口不断的调用，过了一段时间，发现机器上的接口调用开始报&lt;code&gt;OOM异常&lt;/code&gt; ！&lt;br&gt;当天就是上线deadline了，刺激。。&lt;/p&gt;</summary>
    
    
    
    <category term="问题解决" scheme="http://coderstudy.vip/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="内存泄漏" scheme="http://coderstudy.vip/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
    <category term="JVM" scheme="http://coderstudy.vip/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>图解图库JanusGraph系列-解惑图数据库！你知道什么是图数据库吗？</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3%E5%9B%BE%E5%BA%93JanusGraph%E7%B3%BB%E5%88%97-%E8%A7%A3%E6%83%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%81%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%97%EF%BC%9F.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3%E5%9B%BE%E5%BA%93JanusGraph%E7%B3%BB%E5%88%97-%E8%A7%A3%E6%83%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%81%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%97%EF%BC%9F.html</id>
    <published>2021-03-03T07:26:37.146Z</published>
    <updated>2021-03-03T07:26:37.139Z</updated>
    
    <content type="html"><![CDATA[<p>为什么需要图数据库？</p><p>大家好，我是洋仔，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（求star~~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="为什么需要图数据库？"><a href="#为什么需要图数据库？" class="headerlink" title="为什么需要图数据库？"></a>为什么需要图数据库？</h2><p><strong>设想一个场景</strong>：<br>在金融的反欺诈场景下，当一个用户<code>小李</code> 请求订单，我们可以设定一个规则：</p><ol><li>获取该用户的身份证号、注册手机号、银行预留手机号、银行卡号、紧急联系人等信息</li><li>通过这些信息去关联包含这些信息的用户集合<code>小王、小张、小天</code></li><li>通过对关联出的<code>小王、小张、小天</code>判断黑名单用户、逾期用户、授信拒绝等信息综合判定一个分数</li><li>然后根据这个分数对<code>小李</code> 判定是否授信通过；</li></ol><p>为了更加有效果我们可以<code>小王、小张、小天</code>作为源用户列表再获取这些用户的2度关联用户<code>小小、小大</code>，获取一个综合评分，和一度关联的用户综合评分共同参考，来判定这个userA到底该不该授信通过，借钱给他，如下图：<br><img src="https://img-blog.csdnimg.cn/20200527163652471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>基于上述场景，我们首先先考虑使用<code>关系型数据库</code>： 一个用户表存储用户详情，上述过程我们需要</p><ol><li>从接口入参获取小李的各种信息 </li><li>通过小李的各种信息去表中查询出对应数据 </li><li>再根据查出的一度用户去表中查询二度用户，那如果要查多度呢，如果想要获取用户的其他信息呢，就要join，多表join、多次join想想就刺激~</li></ol><p>那么，基于<code>图论</code>的<code>图数据库</code>就诞生了，详细的我们下面再介绍，先基于将数据存储到图库中，用户做为节点、用户与用户之间的关系作为边、用户的其他属性作为节点的属性，类似于下图；<br><img src="https://img-blog.csdnimg.cn/20200527163722380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>那么用图库该怎么查呢？</strong><br>我们就以一种图库查询语言<code>gremlin</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().has(<span class="string">&#x27;user_name&#x27;</span>,<span class="string">&quot;小李&quot;</span>).both(<span class="string">&quot;user_friend&quot;</span>).both(<span class="string">&quot;user_friend&quot;</span>).both(<span class="string">&quot;user_friend&quot;</span>).bothV().has(<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一句话搞定，不用多次查询、图库帮你搞定~  多度查询轻松拈来 </p><p>ps ： 具体图库底层数如何存储、查询逻辑、图库架构等 欢迎关注我~ 后续系列文章会出~</p><p><strong>总结一下，图库在<code>特定场景</code>下的优点:</strong></p><ol><li><code>高性能</code>：随着数据量的增多和关联深度的增加，传统关系型数据库受制于检索时需要多个表之间连接操作，数据写入时也需考虑外键约束，从而导致较大的额外开销，产生严重的性能问题。而图模型固有的数据索引结构，使得它的数据查询与分析速度更快。</li><li><code>灵活</code>：图数据库有非常灵活的数据模型，使用者可以根据业务变化随时调整数据模型，比如任意添加或删除顶点、边，扩充或者缩小图模型这些都可以轻松实现，这种频繁的 Schema 更改在关系型数据库上不能到很好的支持。</li><li><code>敏捷</code>：图数据库的图模型非常直观，支持测试驱动开发模式，每次构建时可进行功能测试和性能测试，符合当今最流行的敏捷开发需求，对于提高生产和交付效率也有一定帮助。</li></ol><h1 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h1><p>图形数据库是<code>NoSQL</code>数据库的一种类型，起源于<code>欧拉理论和图理论</code>，也可称为<code>面向/基于图的数据库</code>，对应的英文是<code>Graph Database</code>。</p><p>它应用<code>图形理论</code>存储<code>实体之间的关系信息</code>；图数据库的基本含义是以<code>“图”</code>这种数据结构做为<code>逻辑结构</code>存储和查询数据。</p><p>我们知道一个图包含节点和边，如下图：<br><img src="https://img-blog.csdnimg.cn/20200527163733183.png" alt="在这里插入图片描述"></p><p>在图数据库中<code>图</code>将<code>实体表现为节点</code>，<code>实体与其他实体连接的方式表现为联系（边）</code>。我们可以用这个通用的、富有表现力的结构来建模各种场景，从宇宙火箭的建造到道路系统，从食物的供应链及原产地追踪到人们的病历，甚至更多其他的场景。</p><p><strong>例如</strong>，<code>实体</code>：类似于用户、用户的亲属等作为一个节点存在于图中，<code>边</code>：用户和用户亲属之间关联的关系，小李—&gt;小李的父亲，这两个节点之间的边可以设定为“用户父母”的边；</p><h2 id="主流图数据库"><a href="#主流图数据库" class="headerlink" title="主流图数据库"></a>主流图数据库</h2><p>目前主流的图数据库有：Neo4j，Janusgraph，Dgraph，Giraph，TigerGraph等。</p><blockquote><p>ps : 这里我们只看 database model专用支持graph类型的图库</p></blockquote><p>受欢迎程度如下，时间是：2020-5月</p><p><img src="https://img-blog.csdnimg.cn/20200527163742923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>简单介绍一下Neo4j 和 Janusgraph区别：</p><p><strong>Neo4j：</strong></p><ol><li>Neo4J使用原生的图存储，以高度自由且规范的方式管理和存储数据。对比非原生图解决方案中，随着信息量的增加，使用面向对象的数据库存储数据库使数据操作变得越来越慢。</li><li>Neo4J可以以每秒一百万条的惊人速度提供结果，因为数据中的链接部分或实体在物理上是已经相互连接的。</li><li>Neo4J的另一个特点是ACID事务，它确保实时显示数据的合法性和准确性，这是企业级应用的重要特性。</li><li>单击不收费，集群收费，所以对于不想要花大价钱买的话，这个不推荐；如果不差钱，强烈推荐使用，社群活跃，服务稳定，功能强大</li></ol><p><strong>Janusgraph：</strong></p><ol><li>开源的分布式图数据库，采用第三方存储作为底层存储，如：HBase、Cassandra等</li><li>使用第三方框架支持全文匹配、范围匹配等，如Es等</li><li>集群节点可以线性扩展，以支持更大的图和更多的并发访问用户。</li><li>数据分布式存储，并且每一份数据都有多个副本，因此，有更好的计算性能和容错性。</li><li>原生集成Apache TinkerPop图技术栈，包括Gremlin graph query language、Gremlin graph server、Gremin applications。</li><li>免费开源，我们现在正在使用的就是这个</li></ol><p>下面就以<code>JanusGraph</code>为例来初探图数据库的设计</p><h2 id="JanusGraph"><a href="#JanusGraph" class="headerlink" title="JanusGraph"></a>JanusGraph</h2><p>可以看下官网上的解释：</p><blockquote><p>JanusGraph is a scalable graph database optimized for storing and querying graphs containing hundreds of billions of vertices and edges distributed across a multi-machine cluster. JanusGraph is a transactional database that can support thousands of concurrent users executing complex graph traversals in real time.  </p></blockquote><p>JanusGraph是一个<code>可扩展的图形数据库</code>，专门用于存储和查询分析分布在多机集群中的数千亿个顶点和关系边的图形。</p><p>JanusGraph是一个<code>事务数据库</code>，可以支持数千个并发用户实时执行复杂的图遍历。</p><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><ul><li>JanusGraph是2016年12月27日从Titan fork出来的一个分支，之后TiTan的开发团队在2017年陆续发了0.1.0rc1、0.1.0rc2、0.1.1、0.2.0等四个版本，最新的版本是2017年10月12日。　</li><li>titan是从2012年开始开发，到2016年停止维护的一个分布式图数据库。最初在2012年启动titan项目的公司是Aurelius，2015年此公司被 DataStax（DataStax是开发apache Cassandra 的公司）收购，DataStax公司吸收了TiTan的图存储能力，形成了自己的商业产品DataStax Enterprise Graph。　</li><li>TiTan开发者们希望把TitTan放到Apache Software Foundation下，不过，DataStax不愿意这样做，而且自从2015年9月DataStax收购了Titan的母公司后，TiTan一直处于停滞状态,鉴于此，2016年6月，TiTan的开发者们fork了一个TiTan的分支，重命名为JanusGraph，并将其置于Linux Software Foundation下。　</li><li>2017年4月6日发布了第一个版本0.1.0-rc1，目前最新版本是<code>2020年05月27日</code>发布的<code>0.6版</code></li></ul><p><code>JanusGraph</code>项目启动的初衷是“<code>通过为其增加新功能、改善性能和扩展性、增加后端存储系统来增强分布式图系统的功能，从而振兴分布式图系统的开发</code>”</p><p><code>JanusGraph</code>从<code>Apahce TinkerPop</code>中吸收了对<code>属性图模型（Property Graph Model）</code>的支持和对属性图模型进行遍历的Gremlin遍历语言。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>同大多数图数据库一样，JanusGraph采用 <code>属性图</code> 进行建模。基于<code>属性图</code>的模型，JanusGraph有如下基本概念：</p><ol><li><code>Vertex Label</code>：节点的类型，用于表示现实世界中的实体类型，比如”人”，“车”。在JanusGraph中，每一个节点有且只有一个Vertex Label。当不显式指定Vertex Label时，采用默认的Vertex Label。</li><li><code>Vertex</code>：节点/顶点，用于表示现实世界中的实体对象。</li><li><code>Edge Label</code>：边的类型，用于表示现实世界中的关系类型，比如“通话关系”，“转账关系”，“微博关注关系”等；</li><li><code>Edge</code>: 边，用于表示一个个具体的联系。JanusGraph的边都是单向边。如果需要双向边，则通过两条相反方向的单向边组成。JanusGraph不存在无向边。</li><li><code>Property Key</code>：属性的类型，比如“姓名”，“年龄”，“时间”等。Property Key有Cardinality的概念。Cardinality有SINGLE、LIST和SET三种选项。这三种选项分别用于表示一个Property中，对于同一个Property Key是只允许有一个值、允许多个可重复的值，还是多个不可重复的值。</li><li><code>Property</code>：属性，用于表示一个个具体的附加信息，采用Key-Value结构。Key就是Property Key，Value就是具体的值。</li></ol><p>类似于下面这种图，包含节点和边，节点包含多个属性：<br><img src="https://img-blog.csdnimg.cn/20200527163800574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li>弹性和线性可扩展性，适用于不断增长的数据和用户群。    </li><li>用于性能和容错的数据分发和复制。    </li><li>多数据中心高可用性和热备份。    </li><li>支持ACID和 最终的一致性。    </li><li>支持各种存储后端：  Apache Cassandra\Apache HBase \ Google Cloud Bigtable \ Oracle BerkeleyDB    </li><li>通过与大数据平台集成，支持全局图形数据分析，报告和ETL：  Apache Spark\Apache Giraph\ApacheHadoop    </li><li>支持以下方式进行geo、数据范围搜索和全文搜索： ElasticSearch \ Apache Solr \Apache Lucene </li><li>与Apache TinkerPop图形堆栈本机集成： Gremlin图查询语言 \ Gremlin图服务器 \ Gremlin应用程序    </li><li>Apache 2许可下的开源 </li><li>工具可视化存储在JanusGraph中的图形：Cytoscape \Apache TinkerPop 的 Gephi插件\ Graphexp \ Cambridge Intelligence 的 KeyLines\Linkurious </li></ul><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p> JanusGraph是一个图形数据库引擎，本身专注于紧凑图形序列化，丰富的图形数据建模和高效的查询。利用Hadoop进行图形分析和批处理图处理。</p><p>JanusGraph为数据持久性、数据索引和客户端访问实现了强大的模块化接口。其模块化架构使其能够与各种存储、索引和客户端技术进行互操作；模块化架构还简化了支持新的一个 模块的流程。</p><p>架构图如下：<br><img src="https://img-blog.csdnimg.cn/20200527163810936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>ps：避免篇幅过大，架构相关的信息会在后续的博文详细说明</p></blockquote><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p> 作为一个<code>数据库系统</code>，它是要用来为<code>应用程序存储数据</code>用的，那么应用程序应该如何使用JanusGraph来为自己存储数据呢？　　</p><p> 一般来说，应用程序可以通过两种不同的方式来使用JanusGraph：　</p><ol><li><p>第一种方式：可以把JanusGraph嵌入到应用程序中去，JanusGraph和应用程序处在<code>同一个JVM中</code>。应用程序中的客户代码（相对JanusGraph来说是客户）直接调用<code>Gremlin</code>去查询JanusGraph中存储的图，这种情况下外部存储系统可以是本地的，也可以处在远程</p></li><li><p>第二种方式：应用程序和Janus Graph处在两个不同JVM中，应用通过给JanusGraph提交Gremlin查询给GremlinServer，来使用JanusGraph，因为JanusGraph原生是支持Gremlin Server的。</p><blockquote><p>Gremlin Server是Apache Tinkerpop中的一个组件</p></blockquote><p>JanusGraph<code>集群</code>包含一个、或者多个JanusGraph实例。每次启动一个<code>JanusGraph实例</code>的时候，都必须指定JanusGraph的配置。</p></li></ol><p>在配置中，可以指定JanusGraph要用的组件，可以控制JanusGraph运行的各个方面，还可以指定一些JanusGraph集群的调优选项:</p><ul><li>最小的JanusGraph配置只需要指定一下JanusGraph的后端存储系统，也就是它的持久化引擎。　　</li><li>如果要JanusGraph支持高级的图查询，就需要为JanusGraph指定一个索引后端。　　</li><li>若果要提升JanusGraph的查询性能，就必须为JanusGraph指定缓存，指定性能调优的选项。　　</li></ul><p>以上提到的后端存储系统、索引后端、缓存、调优选项等都可以在JanusGraph的配置文件中进行指定。默认情况下它的配置文件存放在<code>JanusGraph_home/conf</code>目录下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">storage.backend=cassandra</span><br><span class="line">storage.hostname=localhost</span><br><span class="line"></span><br><span class="line">index.search.backend=elasticsearch</span><br><span class="line">index.search.hostname=</span><br><span class="line">index.search.elasticsearch.client-only=true</span><br></pre></td></tr></table></figure><p>也可以在写测试用例时代码控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个JanusGraph实例</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> JanusGraph的一个实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JanusGraph <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JanusGraphFactory.build()</span><br><span class="line">                .set(<span class="string">&quot;storage.backend&quot;</span>, <span class="string">&quot;hbase&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;storage.hostname&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;storage.port&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;storage.hbase.table&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;cache.db-cache&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;cache.db-cache-clean-wait&quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;cache.db-cache-time&quot;</span>, <span class="string">&quot;180000&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;cache.db-cache-size&quot;</span>, <span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;index.relationalNetwork.backend&quot;</span>, <span class="string">&quot;elasticsearch&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;index.relationalNetwork.hostname&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .set(<span class="string">&quot;index.relationalNetwork.port&quot;</span>, <span class="number">9000</span>)</span><br><span class="line">                .open();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，就可以生成一个janusgraph图实例，通过操作该图实例来对图数据库进行操作</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了，为什么需要图数据库，图数据库的基础理论，市场上存在的流行的图数据库并依照janusgraph图数据库来展开讲解一下图数据库相关知识等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么需要图数据库？&lt;/p&gt;
&lt;p&gt;大家好，我是洋仔，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~&lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解图库JanusGraph系列-一文搞定janusgraph图数据库的本地源码编译（janusgraph source code compile）</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3%E5%9B%BE%E5%BA%93JanusGraph%E7%B3%BB%E5%88%97-%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Ajanusgraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%EF%BC%88janusgraph_source_code_compile%EF%BC%89.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3%E5%9B%BE%E5%BA%93JanusGraph%E7%B3%BB%E5%88%97-%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Ajanusgraph%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%EF%BC%88janusgraph_source_code_compile%EF%BC%89.html</id>
    <published>2021-03-03T07:26:30.811Z</published>
    <updated>2021-03-03T07:26:30.805Z</updated>
    
    <content type="html"><![CDATA[<p><strong>源码分析</strong> 的第一步就是要先编译好源代码，才能进行debug跟踪流程查看，本文总结了<code>janusgraph源码编译</code>的全流程！</p><p>大家好，我是洋仔，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（求star~~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>源码分析</strong> 的第一步就是要先编译好源代码，才能进行debug跟踪流程查看，本文总结了<code>janusgraph源码编译</code>的全流程！</p><blockquote><p><strong>注意</strong>： 安装好环境之后, 推荐下载github：<a href="https://github.com/YYDreamer/janusgraph/tree/master">https://github.com/YYDreamer/janusgraph/tree/master</a><br>这个地址的janusgraph代码！  里面包含源码分析+编译错误的解决完成</p></blockquote><p>主要介绍了<code>janusgraph+hbase+es</code>的本地源码编译过程，最后介绍了<code>janusgraph+berkeleyje+es</code>的编译过程。</p><p>源码已经上传个人github：<code>https://github.com/YYDreamer/janusgraph</code>  欢迎star和fork~  </p><p><strong>本文所有的 janusgraph源码项目文件 + hadoop安装包 + hadoop在windows的辅助安装包 + hbase安装包 + es安装包全部整合放到了公众号“匠心Java”中，微信搜索“<code>匠心Java</code>”，回复“<code>图库资源</code>”四个字即可</strong><br><img src="https://img-blog.csdnimg.cn/20200610203305774.png" alt="在这里插入图片描述"></p><h1 id="一-本地安装依赖环境"><a href="#一-本地安装依赖环境" class="headerlink" title="一 本地安装依赖环境"></a>一 本地安装依赖环境</h1><p>本机安装<code>hbase</code>环境，这里我后台存储使用的是 hbase，这里为了更好的符合正常的使用情况，没有用janusgraph自带的<code>inmemory</code>存储形式</p><blockquote><p>ps：如果你在其他服务器有hbase和es环境，就不用自己本地搭建了，如果没有的话，我们在本地搭建一个自己的hbase和es，这种网上特别多，下面也给出了我自己搭建看的博客连接</p></blockquote><h2 id="1-安装hadoop-并-启动"><a href="#1-安装hadoop-并-启动" class="headerlink" title="1. 安装hadoop 并 启动"></a>1. 安装hadoop 并 启动</h2><p>hbase依赖于hadoop环境，所以我们在安装hbase前，先安装hadoop环境</p><p><strong>安装</strong>：参考博客：<a href="https://blog.csdn.net/qq_35535690/article/details/81976032">hadoop安装教程</a></p><p><strong>启动</strong>：</p><ul><li>管理员方式打开<code>cmd</code></li><li>转到对应的hadoop的sbin目录下，例如我的：<code>D:\app\app_develop\hadoop-2.7.7\sbin</code></li><li>使用命令<code>start-all</code>* 出现四个黑框框：<code>hadoop namenode、hadoop datanode、yarn resourcemanager、yarn nodemanager</code>即可</li><li>访问<code>http://localhost:50070</code>，可以访问即为成功！</li></ul><h2 id="2-安装hbase-并-启动"><a href="#2-安装hbase-并-启动" class="headerlink" title="2. 安装hbase 并 启动"></a>2. 安装hbase 并 启动</h2><p><strong>注意</strong>：在选择安装hbase的版本时，需要查看自己下载的janusgraph源码的版本支持hbase的什么版本</p><p>这里我们选择的是janusgraph-0.5.2版本，支持hbase-2.1.x版本，所以这里我下载的hbase-2.1.5版本</p><p><strong>安装</strong>：参考博客：<a href="https://blog.csdn.net/superhanliu/article/details/82876451">hbase安装教程</a></p><p><strong>启动</strong>：</p><ul><li>管理员方式打开<code>cmd</code></li><li>转到对应的hadoop目录下，例如我的：<code>D:\app\app_develop\hbase-2.1.5\bin</code></li><li>输入命令，回车<code>start-hbase.cmd</code></li><li>出现一个黑框框，如下<br><img src="https://img-blog.csdnimg.cn/20200610203321401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>在hbase的bin目录下，输入命令<code>hbase shell</code>，能成功连接hbase shell，即为成功！</li></ul><p><strong>如果启动报错：<code>java.lang.ClassNotFoundException: org.apache.htrace.core.HTraceConfiguration</code></strong></p><p><strong>解决方法</strong>： 将本地hbase-2.1.5目录下的<code>lib\client-facing-thirdparty</code>目录下的<code>htrace-core-3.1.0-incubating.jar</code>和<code>htrace-core4-4.2.0-incubating.jar</code>赋值到路径<code>lib</code>下，重新<code>start-hbase.cmd</code>命令，启动成功！</p><h2 id="3-安装es-并-启动"><a href="#3-安装es-并-启动" class="headerlink" title="3. 安装es 并 启动"></a>3. 安装es 并 启动</h2><p><strong>安装</strong>：参考博客：<a href="https://www.jianshu.com/p/8910c4869df5">es安装教程</a></p><p><strong>启动</strong>：</p><ul><li>管理员方式打开<code>cmd</code></li><li>转到对应的hadoop目录下，例如我的：<code>D:\app\app_develop\elasticsearch-6.8.3\bin</code></li><li>输入命令，回车<code>elasticsearch.bat</code></li><li>输入完命令后，当前的黑框中会启动es，最终出现下述：<br><img src="https://img-blog.csdnimg.cn/20200610203332170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>访问<code>http://localhost:9200/</code>，出现下述json即为成功！<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;99Xn4Vd&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;YpMeVAlzQRuzuVis1JzHpA&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;6.8.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> : <span class="string">&quot;zip&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;0c48c0e&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2019-08-29T19:05:24.312154Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;7.7.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;5.6.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;5.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终，我们使用<code>jps</code> 可以看到我们刚才启动的进程，如下图：<br><img src="https://img-blog.csdnimg.cn/20200610203529756.png" alt="在这里插入图片描述"></p><p>经过上述步骤，我们</p><ul><li>在本地安装了hbase、es的环境并启动</li></ul><h1 id="二-配置文件修改和添加对应的依赖"><a href="#二-配置文件修改和添加对应的依赖" class="headerlink" title="二. 配置文件修改和添加对应的依赖"></a>二. 配置文件修改和添加对应的依赖</h1><h2 id="1-修改对应的配置文件"><a href="#1-修改对应的配置文件" class="headerlink" title="1. 修改对应的配置文件"></a>1. 修改对应的配置文件</h2><p>上述代码使用的是hbase 和 es作为底层存储和索引后端的， 这里我们找到对应的源码中<code>janusgraph-dist</code>模块下的<code>\src\assembly\cfilter\conf\janusgraph-hbase-es.properties</code>下的这个文件：</p><p><em>ps： 这里我用的是自己的绝对路径，其实这个文件是在<code>janusgraph-dist</code>模块下的一个文件，如下图：</em><br><img src="https://img-blog.csdnimg.cn/20200610203541102.png" alt="在这里插入图片描述"></p><p>将下面的代码注释删除掉，并删除<code>JANUSGRAPHCFG</code>字段和对应的大括号，下面默认使用的是本地的hbase和es 如果你需要配置远程的hbase和es注意修改对应的ip，修改后如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gremlin.graph=org.janusgraph.core.JanusGraphFactory</span><br><span class="line">storage.backend=hbase</span><br><span class="line">storage.hostname=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">cache.db-cache = <span class="keyword">true</span></span><br><span class="line">cache.db-cache-clean-wait = <span class="number">20</span></span><br><span class="line">cache.db-cache-time = <span class="number">180000</span></span><br><span class="line">cache.db-cache-size = <span class="number">0.5</span></span><br><span class="line">index.search.backend=elasticsearch</span><br><span class="line">index.search.hostname=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h2 id="2-添加相应依赖"><a href="#2-添加相应依赖" class="headerlink" title="2. 添加相应依赖"></a>2. 添加相应依赖</h2><p>我们在<code>janusgrap-test</code>模块编写自己的单测并运行，因为在<code>janusgraph-test</code>模块中使用的是<code>inmory</code>也就是内存作为存储后端的，没有对应的<code>hbase和es</code>依赖</p><p>而我们上述使用的是es 和 hbase所以添加了对应的依赖，根据你使用的在<code>janusgraph-test</code>模块的<code>pom</code>文件下添加对应依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-hbase-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-hbase-10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-es<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="三：下载janusgraph源码并编译"><a href="#三：下载janusgraph源码并编译" class="headerlink" title="三：下载janusgraph源码并编译"></a>三：下载janusgraph源码并编译</h1><h2 id="1-下载janusgraph的源码到本地编译器"><a href="#1-下载janusgraph的源码到本地编译器" class="headerlink" title="1. 下载janusgraph的源码到本地编译器"></a>1. 下载janusgraph的源码到本地编译器</h2><p><strong>方式一：</strong></p><p>使用git的话，可以直接使用<code>git clone</code>从janusgraph的github仓库来clone一份远程代码到本地</p><p>janusgraph 的 github地址： <a href="https://github.com/JanusGraph/janusgraph">https://github.com/JanusGraph/janusgraph</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JanusGraph/janusgraph</span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><p>也可以直接下载源码的zip包，本地解压之后，用idea打开也可以</p><p>然后 <code>git init</code> 初始化为git项目做版本控制，关联到clone到自己的远程仓库即可</p><p>注意修改为自己的maven仓库</p><p><strong>我的github中janusgraph对应的地址：<a href="https://github.com/YYDreamer/janusgraph%EF%BC%8C%E4%BC%9A%E5%B0%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9B%B8%E5%85%B3%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E8%AF%A5%E4%BB%93%E5%BA%93%EF%BC%81">https://github.com/YYDreamer/janusgraph，会将源码分析过程中相关修改提交到该仓库！</a></strong></p><p>1.经过上述的步骤，我们在idea中便有了一个一个janusgraph源码的项目，我们首先去除对应的maven插件</p><ul><li>将项目<code>最外层</code>的<code>pom.xml</code>中的插件<code>maven-enforcer-plugin</code>部分注释掉，不然会出现<code>Failed to execute goal org.apache.maven.plugins:maven-enforcer-plugin:3.0.0-M2:enforce enforce-dependency-convergence) on project janusgraph-test: Some Enforcer rules have failed. Look above for specific messages explaining why the rule failed.</code> 错误！</li><li>将<code>janusgraph-dist</code>模块中的<code>pom.xml</code>文件下的<code>download-maven-plugin</code>插件注释掉，不然会出现<code>org.apache.http.conn.HttpHostConnectException: Connect to artifacts.elastic.co:443 [artifacts.elastic.co/151.101.110.222] failed: Connectiontimed out: connect</code>错误！</li></ul><p>2.接下来，进行编译，点击idea下面的<code>Terminal</code>，输入命令：<br>编译项目全部模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests -Drat.skip=true</span><br></pre></td></tr></table></figure><p>或者单独编译一个模块，下面以<code>janusgraph-test</code>模块示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -pl janusgraph-test -am clean install -Dlicense.skip=true -DskipTests -P prod</span><br></pre></td></tr></table></figure><p>这里，我们使用全部编译的语句，将项目全部编译！</p><p>3.最后全部<code>success</code>即可！ 过程可能有点慢，如果看到编译过程在下载es等组件的话，可以先将下面讲的环境搭建起来，再用上述语句进行编译，成功图如下：<br><img src="https://img-blog.csdnimg.cn/20200610203552891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>错误解决：</strong></p><ol><li> 打开项目后，可能会发现有的pom文件报错，一是看看你的maven有没有正确配置，二是可能是maven的本地仓库索引没有更新，可以参考博客：<a href="https://liyangyang.blog.csdn.net/article/details/106429093">pom问题解决，超链接直接点击即可</a></li></ol><h1 id="四-编写单测-并-运行"><a href="#四-编写单测-并-运行" class="headerlink" title="四. 编写单测 并 运行"></a>四. 编写单测 并 运行</h1><h2 id="1-编写单测"><a href="#1-编写单测" class="headerlink" title="1. 编写单测"></a>1. 编写单测</h2><p>在<code>janusgraph-test</code>模块下的<code>test</code>目录下，新建一个’mytest’文件夹，编写一个单元测试<code>JanusGraphFirstTest</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JanusGraphFirstTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建图实例，存储使用hbase，索引使用es</span></span><br><span class="line">        <span class="comment">// TODO 注意！文件路径修改为自己当前电脑下的绝对路径</span></span><br><span class="line">        JanusGraph graph = JanusGraphFactory</span><br><span class="line">            .open(<span class="string">&quot;D:\\code\\janusgraph-0.5.2\\janusgraph-dist\\src\\assembly\\cfilter\\conf\\janusgraph-hbase-es.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用GraphOfTheGodsFactory加载“The Graph of the Gods”图，这是JanusGraph用于测试自定义的一个图</span></span><br><span class="line">        GraphOfTheGodsFactory.load(graph);</span><br><span class="line">        <span class="comment">// 获取图遍历对象实例</span></span><br><span class="line">        GraphTraversalSource g = graph.traversal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性&quot;name&quot;为&quot;saturn&quot;的节点</span></span><br><span class="line">        Vertex saturn = g.V().has(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;saturn&quot;</span>).next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上述节点对应的所有属性的kv</span></span><br><span class="line">        GraphTraversal&lt;Vertex, Map&lt;Object, Object&gt;&gt; vertexMapGraphTraversal = g.V(saturn).valueMap();</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        List&lt;Map&lt;Object, Object&gt;&gt; saturnProMaps = vertexMapGraphTraversal.toList();</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;Object, Object&gt; proMap : saturnProMaps) &#123;</span><br><span class="line">            proMap.forEach((key,value) -&gt; System.out.println(key + <span class="string">&quot;:&quot;</span> + value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上述节点的father的father的姓名，也就是grandfather的姓名</span></span><br><span class="line">        GraphTraversal&lt;Vertex, Object&gt; values = g.V(saturn).in(<span class="string">&quot;father&quot;</span>).in(<span class="string">&quot;father&quot;</span>).values(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String name = String.valueOf(values.next());</span><br><span class="line">        System.out.println(<span class="string">&quot;grandfather name:&quot;</span> + name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取在(latitude:37.97 and long:23.72)50km内的所有节点</span></span><br><span class="line">        GraphTraversal&lt;Edge, Edge&gt; place = g.E().has(<span class="string">&quot;place&quot;</span>, geoWithin(Geoshape.circle(<span class="number">37.97</span>, <span class="number">23.72</span>, <span class="number">50</span>)));</span><br><span class="line">        <span class="comment">// 获取边对应的节点</span></span><br><span class="line">        GraphTraversal&lt;Edge, Map&lt;String, Object&gt;&gt; node = place.as(<span class="string">&quot;source&quot;</span>)</span><br><span class="line">            .inV().as(<span class="string">&quot;god2&quot;</span>)</span><br><span class="line">            .select(<span class="string">&quot;source&quot;</span>)</span><br><span class="line">            .outV().as(<span class="string">&quot;god1&quot;</span>)</span><br><span class="line">            .select(<span class="string">&quot;god1&quot;</span>, <span class="string">&quot;god2&quot;</span>).by(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = node.toList();</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; map : maps) &#123;</span><br><span class="line">            map.forEach((key,value) -&gt; System.out.println(key + <span class="string">&quot;:&quot;</span> + value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意！！！！！！ 在上述新添加的<code>JanusGraphFirstTest</code>文件中<code>最上面</code>添加下面的注释，不然会因为不符合开源规则编译会报错！</strong></p><p><strong>并且！ 我们在源码分析过程中，添加了任何的文件或者修改了原有的文件，下面的注释都是必须要加在文件最上面并且不可以删除！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2020 JanusGraph Authors</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br></pre></td></tr></table></figure><p>运行上述单测，<code>前提保证hadoop、hbase、es都在启动状态！</code></p><h2 id="2-运行成功后"><a href="#2-运行成功后" class="headerlink" title="2. 运行成功后"></a>2. 运行成功后</h2><p>首先，<code>cmd</code>进入hbase的<code>bin</code>目录下，运行<code>hbase shell</code>命令，进入到hbase 的 shell界面：</p><p><strong>2.1 输入<code>list</code>命令，如下，可以发现存在一个叫做<code>janusgraph</code>的表，这就是我们刚才运行的单测生成的一个默认table，用来存储对应的图数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):005:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">janusgraph</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0070 seconds</span><br><span class="line">=&gt; [&quot;janusgraph&quot;]</span><br><span class="line">hbase(main):006:0&gt;</span><br></pre></td></tr></table></figure><p><strong>2.2 输入<code>desc &#39;janusgraph&#39;</code> 命令，如下，查看对应的table schema，我们可以看到表状态为<code>ENABLE</code>可用状态，并且下面跟着好大一坨列簇和列的信息</strong></p><p>其中的列簇<code>e\f\g\h\i\l\m\s\t</code>都存了对应的图信息，具体存了图的什么信息，我们下面的博文会分享，这里不做描述了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0* desc &#x27;janusgraph&#x27;</span><br><span class="line">Table janusgraph is ENABLED</span><br><span class="line">janusgraph</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &#x27;e&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEH</span><br><span class="line">AVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;false&#x27;,</span><br><span class="line"> DATA_BLOCK_ENCODING =&gt; &#x27;NONE&#x27;, TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATI</span><br><span class="line">ON_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN_MEMOR</span><br><span class="line">Y =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_BLOCKS_ON_OPEN =&gt; &#x27;fals</span><br><span class="line">e&#x27;, COMPRESSION =&gt; &#x27;GZ&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 省略了一部分...</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>单测中包含<code>GraphOfTheGodsFactory.load(graph)</code>代码，是将janusgraph自带的一个测试图导入到hbase中，供我们测试使用，首次运行单测成功后，我们要把这个语句<code>GraphOfTheGodsFactory.load(graph)</code>注释掉，不需要重新load这个测试图！</p><h1 id="五-底层存储使用berkeleyje数据库和es索引后端"><a href="#五-底层存储使用berkeleyje数据库和es索引后端" class="headerlink" title="五. 底层存储使用berkeleyje数据库和es索引后端"></a>五. 底层存储使用<code>berkeleyje</code>数据库和<code>es</code>索引后端</h1><p>我们只需要将上述单测代码中的配置文件路径配置文件修改为<code>相同位置</code>下的<code>janusgraph-berkeleyje-es.properties</code>即可，将对应配置的注释去掉！</p><p>然后，将对应的依赖放到<code>janusgraph-test</code>对应的pom文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-es<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-berkeleyje<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可！</p><p>本文所有的 <code>janusgraph源码项目文件 + hadoop安装包 + hadoop在windows的辅助安装包 + hbase安装包 + es安装包</code>全部整合放到了公众号“匠心Java”中，微信搜索“<code>匠心Java</code>”，回复“<code>图库资源</code>”四个字即可，也可通过微信公众号联系博主，一同探讨!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;源码分析&lt;/strong&gt; 的第一步就是要先编译好源代码，才能进行debug跟踪流程查看，本文总结了&lt;code&gt;janusgraph源码编译&lt;/code&gt;的全流程！&lt;/p&gt;
&lt;p&gt;大家好，我是洋仔，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~&lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解JanusGraph系列-生成Hbase file离线批量导入方案</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E7%94%9F%E6%88%90Hbase_file%E7%A6%BB%E7%BA%BF%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%96%B9%E6%A1%88.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-%E7%94%9F%E6%88%90Hbase_file%E7%A6%BB%E7%BA%BF%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E6%96%B9%E6%A1%88.html</id>
    <published>2021-03-03T07:26:22.348Z</published>
    <updated>2021-03-03T07:26:22.341Z</updated>
    
    <content type="html"><![CDATA[<p>源码分析github地址，包含图数据库序列化逻辑分析，下述介绍结合源码分析，应该可以减少大家对这种导入方式花费的时间;</p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（码文不易，求个star~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程</p><p>微信公众号：匠心Java</p><p>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>源码分析github地址，包含图数据库序列化逻辑分析，下述介绍结合源码分析，应该可以减少大家对这种导入方式花费的时间，github地址见上述；</p><p><strong>本文涉及以下部分：</strong></p><ol><li>离线导入的理论前提</li><li>离线导入的流程</li><li>离线导入数据的验证</li><li>离线导入的现状</li></ol><h2 id="一：离线导入的前提"><a href="#一：离线导入的前提" class="headerlink" title="一：离线导入的前提"></a>一：离线导入的前提</h2><h3 id="1、数据相关"><a href="#1、数据相关" class="headerlink" title="1、数据相关"></a>1、数据相关</h3><ul><li>大规模导入的情况下使用，过亿级别</li><li>针对要离线导入的数据要做充分数据探查</li><li>导入时，尽量导入相关联的数据；例如：user节点 + phone节点 + user_login_phone_number边 在同一批次导入；从而尽量保证相关联数据在同一分区</li></ul><h3 id="2、技术点"><a href="#2、技术点" class="headerlink" title="2、技术点"></a>2、技术点</h3><ul><li><p>id block的占用机制 ： 保证分布式id唯一性，具体可以看博客：<a href="https://liyangyang.blog.csdn.net/article/details/108000639">图解Janusgraph系列-分布式id生成策略分析</a></p></li><li><p>schema创建完成</p></li></ul><h2 id="二：离线导入流程"><a href="#二：离线导入流程" class="headerlink" title="二：离线导入流程"></a>二：离线导入流程</h2><ul><li>项目初始化阶段</li><li>数据准备阶段</li><li>序列化阶段</li><li>验证阶段</li></ul><h3 id="项目初始化阶段"><a href="#项目初始化阶段" class="headerlink" title="项目初始化阶段"></a>项目初始化阶段</h3><ol><li><p>调用API接口获取<code>JanusGraph</code>的图实例和当前图实例的<code>Transaction</code></p></li><li><p>调用janusgraph对应的API获取图库中所有的<code>label</code>节点的id，包括 节点label、边label、属性label、索引label；  并保存到内存中，等待使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryUtil.getVertices(consistentTx, BaseKey.SchemaName, typeName)</span><br></pre></td></tr></table></figure></li><li><p>保存属性和对应的索引之间的关系</p></li><li><p>占用id block；需要多少，占用多少，block size可以自己配置（数据库+号段模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partition 分区</span></span><br><span class="line"><span class="comment">// idNamespace id生成器的命名空间，包含多种，此处默认是NORMAL_VERTEX</span></span><br><span class="line"><span class="comment">// 超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IDBlock <span class="title">getIDBlock</span><span class="params">(<span class="keyword">int</span> partition, <span class="keyword">int</span> idNamespace, Duration timeout)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>上述，我们拿到了：</p><ul><li><p>schema所有label的节点值</p></li><li><p>属性和索引的对应关系</p></li><li><p>占用了一批id生成范围（避免离线导入和线上导入自动生成的id重复）</p></li></ul></blockquote><ol><li>获取该批次要导入Vertex的总数量vertex_num； 将相应id block缓存到本地vertexBlocks中；</li><li>获取该批次要导入Vertex中的property总量 ( 所有属性的的总数量 + vertex节点总数量*2) = property_num； 获取满足数量的统一partition中的连续的block；</li><li>获取该批次要导入Edge的总数量num； 将相应block缓存到本地edgeBlocks中；</li><li>打包成jar包上传到指定服务器，作为id生成器 和 序列化工具包</li><li>生成需要的vertex id数量，备用</li><li>生成需要的edge id数量，备用</li></ol><h3 id="数据准备阶段"><a href="#数据准备阶段" class="headerlink" title="数据准备阶段"></a>数据准备阶段</h3><ol><li><p>将节点数据和唯一vertex id整合；</p></li><li><p>对于节点，需要添加index值，index为从0开始；</p><ol><li>获取导入批次数据的最大属性个数num+2，作为step</li><li>将vertex id和 index+=step值和原始数据整合（注意： 此处的index需要对一批次数据所有节点统一赋值！ 统一赋值index后可分批序列化；）</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>:<span class="number">16878090</span>,</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>:<span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;propertyMap&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;create_time&quot;</span>:<span class="string">&quot;2016-12-09 02:29:26&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;productid&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;real_name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span>:<span class="string">&quot;4882374234234&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;vertexId&quot;</span>:<span class="number">197596753968</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>边数据和唯一edge id整合；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;edgeId&quot;</span>:<span class="number">17514510</span>,</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>:<span class="string">&quot;user_login_phone_number&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;propertyMap&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;productid&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;sourceId&quot;</span>:<span class="number">197596753968</span>,</span><br><span class="line">    <span class="attr">&quot;targetId&quot;</span>:<span class="number">40964208</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="序列化阶段"><a href="#序列化阶段" class="headerlink" title="序列化阶段"></a>序列化阶段</h3><blockquote><p>主要是抽取出源码中的序列化逻辑； 在序列化逻辑中使用到了上述的：schema所有label的节点值、属性和索引的对应关系、唯一id等</p></blockquote><ol><li>序列化节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonResult = &#123;ArrayList@<span class="number">1231</span>&#125;  size = <span class="number">8</span></span><br><span class="line"> <span class="number">0</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">2</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">0</span> <span class="number">1</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">44</span> -<span class="number">122</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">1</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">36</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">60</span> -<span class="number">115</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">48</span> -<span class="number">122</span> -<span class="number">1</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">2</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">80</span> -<span class="number">64</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span>-<span class="number">96</span> <span class="number">50</span> <span class="number">48</span> <span class="number">49</span> <span class="number">54</span> <span class="number">45</span> <span class="number">49</span> <span class="number">50</span> <span class="number">45</span> <span class="number">48</span> <span class="number">57</span> <span class="number">32</span> <span class="number">48</span> <span class="number">50</span> <span class="number">58</span> <span class="number">50</span> <span class="number">57</span> <span class="number">58</span> <span class="number">50</span> -<span class="number">74</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">52</span> -<span class="number">122</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">3</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">80</span> -<span class="number">96</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span>-<span class="number">96</span> -<span class="number">78</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">56</span> -<span class="number">122</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">4</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">81</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span>-<span class="number">96</span> <span class="number">85</span> <span class="number">95</span> <span class="number">51</span> <span class="number">53</span> <span class="number">50</span> <span class="number">49</span> <span class="number">57</span> <span class="number">48</span> -<span class="number">71</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">60</span> -<span class="number">122</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">5</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">83</span> -<span class="number">64</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">48</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">112</span> <span class="number">13</span> <span class="number">121</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span>-<span class="number">88</span> -<span class="number">27</span> -<span class="number">68</span> -<span class="number">96</span> -<span class="number">23</span> -<span class="number">94</span> -<span class="number">106</span> <span class="number">9</span> <span class="number">24</span> <span class="number">77</span> <span class="number">0</span> <span class="number">64</span> -<span class="number">122</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">6</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">103</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">0</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">111</span> -<span class="number">103</span> <span class="number">32</span> <span class="number">103</span> <span class="number">48</span> -<span class="number">119</span> -<span class="number">96</span> <span class="number">85</span> <span class="number">95</span> <span class="number">51</span> <span class="number">53</span> <span class="number">50</span> <span class="number">49</span> <span class="number">57</span> <span class="number">48</span> -<span class="number">71</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">5</span> <span class="number">96</span> <span class="number">13</span> <span class="number">60</span> <span class="number">96</span> -<span class="number">80</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">7</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">103</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">0</span> <span class="number">5</span> <span class="number">96</span> <span class="number">13</span> <span class="number">60</span> <span class="number">96</span> -<span class="number">80</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span>-<span class="number">73</span> -<span class="number">16</span> <span class="number">125</span> -<span class="number">9</span> <span class="number">68</span> -<span class="number">119</span> -<span class="number">88</span> -<span class="number">27</span> -<span class="number">68</span> -<span class="number">96</span> -<span class="number">23</span> -<span class="number">94</span> -<span class="number">106</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490235427</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">5</span> <span class="number">96</span> <span class="number">13</span> <span class="number">60</span> <span class="number">96</span> -<span class="number">80</span><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>101（边类型）：每个自定义属性、节点存在属性、节点和label的边</p><p>103（索引类型）：属性对应的索引</p></blockquote><ol start="2"><li>序列化边</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/3264a24831ef92456bc0dd97b541a4a5.png" alt="image-20200723155133550"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsonResult = &#123;ArrayList@<span class="number">1237</span>&#125;  size = <span class="number">2</span></span><br><span class="line"> <span class="number">0</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">121</span> -<span class="number">64</span> -<span class="number">96</span> <span class="number">19</span> <span class="number">68</span> <span class="number">32</span> <span class="number">112</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">112</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490669289</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">8</span> <span class="number">45</span> <span class="number">0</span> -<span class="number">114</span> -<span class="number">64</span> -<span class="number">96</span> -<span class="number">78</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"> <span class="number">1</span> = <span class="string">&quot;&#123;&quot;</span>family<span class="string">&quot;:&quot;</span><span class="number">101</span><span class="string">&quot;,&quot;</span>qualifier<span class="string">&quot;:&quot;</span><span class="number">121</span> -<span class="number">63</span> -<span class="number">128</span> <span class="number">32</span> <span class="number">112</span><span class="string">&quot;,&quot;</span>rowKey<span class="string">&quot;:&quot;</span><span class="number">112</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">19</span> -<span class="number">120</span> -<span class="number">128</span><span class="string">&quot;,&quot;</span>timestamp<span class="string">&quot;:&quot;</span><span class="number">1595490669289</span><span class="string">&quot;,&quot;</span>value<span class="string">&quot;:&quot;</span><span class="number">8</span> <span class="number">45</span> <span class="number">0</span> -<span class="number">114</span> -<span class="number">64</span> -<span class="number">96</span> -<span class="number">78</span><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>101（边类型）：出边、入边</p><p>103（索引类型）：属性对应的索引</p></blockquote><ol start="3"><li>将序列化后的数据根据rowkey，family，column 进行三级排序</li></ol><blockquote><p>为什么要进行排序？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fd071744b8453f3abe9587bc14b48d7f.png" alt="image-20200724144513449"></p><p>sorted by id：  rowkey</p><p>sorted by type： family（101  103）</p><p>sorted by sort key：  </p><p><img src="https://img-blog.csdnimg.cn/img_convert/afd04091075a95d1b4eb3dad320a8aab.png" alt="image-20200724144743522"></p></blockquote><ol start="4"><li><p>将序列化排序后的数据生成hfile</p></li><li><p>将生成的hfile导入到hbse中</p></li></ol><h3 id="离线导入验证阶段"><a href="#离线导入验证阶段" class="headerlink" title="离线导入验证阶段"></a>离线导入验证阶段</h3><ol><li><p>节点、边数量验证</p><ol><li>保留导入前的数量：节点、边的总数量；和导入数据同类型的边、节点总数量；</li><li>导入数据后查询：节点、边的总量；和导入数据同类型的边、节点总数量；</li><li>前后两次查询的相关数量和导入数据的数量，前后进行比对</li></ol></li><li><p>节点、边内容抽样抽样验证</p><ol><li>导入数据后，从导入的源数据中抽取部分数据，使用gremlin语句进行查询相对应的节点，并比对图中节点、边内容和源数据内容是否相同</li></ol></li><li><p>节点和边的对应关系验证</p><ol><li>抽样查询相应节点，并通过gremlin获取节点对应的边数据，和源数据进行比较</li><li>抽样查询相应的边，并通过gremlin获取边对应的节点数据，和源数据进行比较</li></ol></li><li><p>节点、边索引抽样验证</p><ol><li>使用节点对应的唯一索引查询数据，确保可以查询出对应数据并且数据内容和源数据相同</li><li>使用节点对应的唯一索引查询对应数量和内容，确保可以查询出对应数据并且数据内容和源数据相同</li><li>使用边对应的索引查询数据，确保可以查询出对应数据并且数据内容和源数据相同</li></ol></li></ol><h2 id="三：离线导入的验证"><a href="#三：离线导入的验证" class="headerlink" title="三：离线导入的验证"></a>三：离线导入的验证</h2><blockquote><p>前提：</p><ol><li>两个schema一致的图</li><li>图中通过janusgraph api 或者 离线导入相同的数据</li></ol></blockquote><ol><li>离线导入数据 对 线上图中已有数据是否有影响验证</li><li>通过janusgraph api导入数据 和 离线导入数据一致性验证</li><li>离线导入的节点的数量、内容、索引验证</li><li>离线导入的边的数量、内容、索引验证</li><li>离线导入的数据的 修改、删除验证</li><li>是否影响schema的相关操作验证</li></ol><h2 id="四：现状"><a href="#四：现状" class="headerlink" title="四：现状"></a>四：现状</h2><ul><li><p>只支持数据插入，不支持数据删除和修改</p></li><li><p>需要在图T+1更新时间段之外或者停止图线上的T+1数据更新之后，再离线的批量数据导入</p></li><li><p>当前不支持外部索引的添加</p></li></ul><blockquote><p>可以通过导入数据后，调用janusgraph的索引重建语句进行重建</p><p>获取es的索引的相关逻辑，直接调用es rest api插入</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;源码分析github地址，包含图数据库序列化逻辑分析，下述介绍结合源码分析，应该可以减少大家对这种导入方式花费的时间;&lt;/p&gt;
&lt;p&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解Janusgraph系列-查询图数据过程源码分析</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E6%9F%A5%E8%AF%A2%E5%9B%BE%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E6%9F%A5%E8%AF%A2%E5%9B%BE%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</id>
    <published>2021-03-03T07:26:15.139Z</published>
    <updated>2021-03-03T07:26:15.133Z</updated>
    
    <content type="html"><![CDATA[<p>查询流程可以大致分为三部分：组装查询语句、优化查询语句、执行算子链</p><p>大家好，我是洋仔，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（求star~~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="一：查询场景"><a href="#一：查询场景" class="headerlink" title="一：查询场景"></a>一：查询场景</h2><h3 id="1-1-图数据"><a href="#1-1-图数据" class="headerlink" title="1.1 图数据"></a>1.1 图数据</h3><p>使用JanusGraph官方提供的测试图<code>诸神之图</code>来测试，如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020081411121228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>具体的<code>诸神之图</code>的创建分析，请看《JanusGraph-官方测试图：诸神之图分析》文章</p><h3 id="1-2-查询语句"><a href="#1-2-查询语句" class="headerlink" title="1.2 查询语句"></a>1.2 查询语句</h3><p>查询语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取name为hercules节点</span></span><br><span class="line">    GraphTraversal&lt;Vertex, Vertex&gt; herculesVertex = graph.traversal().V().has(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hercules&quot;</span>);</span><br><span class="line">    <span class="comment">// hercules节点战斗（battled）过12次的怪兽（monster）</span></span><br><span class="line">    GraphTraversal&lt;Vertex, Vertex&gt; monsterVertices = herculesVertex.outE().has(T.label, <span class="string">&quot;battled&quot;</span>).dedup().has(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;12&quot;</span>).inV();</span><br><span class="line">    <span class="comment">// 获取monsterVertices节点对应的主人</span></span><br><span class="line">    GraphTraversal&lt;Vertex, Vertex&gt; plutoVertex = monsterVertices.inE(<span class="string">&quot;pet&quot;</span>).outV().has(<span class="string">&quot;age&quot;</span>, <span class="number">4000</span>);</span><br><span class="line">    <span class="keyword">if</span> (plutoVertex.hasNext())&#123;</span><br><span class="line">        Vertex next = plutoVertex.next();</span><br><span class="line">        <span class="comment">// 输出主人的姓名</span></span><br><span class="line">        System.out.println(next.property(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vp[name-&gt;pluto]</span><br></pre></td></tr></table></figure><p>我们查询就是<code>诸神之图</code>的左下角部分，包含了</p><ul><li>vertex的查找</li><li>edge的查找</li><li>property的过滤</li><li>signature key的过滤（time）</li><li>composite index的使用（name）</li><li>第三方索引支持的mixed index使用（age）</li></ul><h2 id="二：-查询流程分析"><a href="#二：-查询流程分析" class="headerlink" title="二： 查询流程分析"></a>二： 查询流程分析</h2><p>查询流程可以大致分为三部分：组装查询语句、优化查询语句、执行算子链</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>gremlin语句官网：<a href="http://kelvinlawrence.net/book/Gremlin-Graph-Guide.html">http://kelvinlawrence.net/book/Gremlin-Graph-Guide.html</a></p><p>在gremlin语句中，查询语句的类型其中包含三种哦：初始语句、中间语句、最终语句（触发执行查询语句）</p><ul><li>初始语句：代表开始gremlin的语句，类似于V()、E()两种</li><li>中间语句：不会触发<code>查询语句执行</code>的语句，类似于has()、outE()、inV()等，大部分都是中间语句</li><li>最终语句：也叫作触发语句，这些语句会触发查询语句的<code>执行</code>！  访问图库并进行图数据查询；类似于hasNext()、toList()等语句</li></ul><p>只有在执行到<code>最终语句</code>部分时，gremlin语句才会真正的执行！</p><h3 id="2-1-组装查询语句"><a href="#2-1-组装查询语句" class="headerlink" title="2.1 组装查询语句"></a>2.1 组装查询语句</h3><p>在<code>Janusgrahp</code>的查询中，首先做的就是组装查询对象； 根据我们写的Gremlin语句，将<code>gremlin</code>语句拆分成不同的<code>算子</code>；不同的语句组装成对应的算子步骤<code>step</code>对象保存，生成一个查询执行算子<code>step</code>链；</p><p>在组装查询语句时，所有的查询Gremlin语句，通常都是通过<code>.V()</code>或者<code>.E()</code>开头，在这两部分中会创建一个查询对象，用于存放之后的每一个查询<code>step</code>；</p><p>例如上述执行查询语句，当执行完成以下语句时，便是进行组装查询对象，不没有真正的去查询底层存储的数据！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取name为hercules节点</span></span><br><span class="line">  GraphTraversal&lt;Vertex, Vertex&gt; herculesVertex = graph.traversal().V().has(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hercules&quot;</span>);</span><br><span class="line">  <span class="comment">// hercules节点战斗（battled）过12次的怪兽（monster）</span></span><br><span class="line">  GraphTraversal&lt;Vertex, Vertex&gt; monsterVertices = herculesVertex.outE().has(T.label, <span class="string">&quot;battled&quot;</span>).dedup().has(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;12&quot;</span>).inV();</span><br><span class="line">  <span class="comment">// 获取monsterVertices节点对应的主人</span></span><br><span class="line">  GraphTraversal&lt;Vertex, Vertex&gt; plutoVertex = monsterVertices.inE(<span class="string">&quot;pet&quot;</span>).outV().has(<span class="string">&quot;age&quot;</span>, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>执行完成后，查看组装后的查询对象：<br><img src="https://img-blog.csdnimg.cn/20200814111244614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>其中包含：图实例对象、事务对象、查询步骤链等，我们看下最终的<code>查询步骤链</code>，在对象中<code>steps</code>的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5271</span>&#125;  size = <span class="number">10</span></span><br><span class="line"> <span class="number">0</span> = &#123;GraphStep@<span class="number">5350</span>&#125; <span class="string">&quot;GraphStep(vertex,[])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;HasStep@<span class="number">5351</span>&#125; <span class="string">&quot;HasStep([name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;VertexStep@<span class="number">5352</span>&#125; <span class="string">&quot;VertexStep(OUT,edge)&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;HasStep@<span class="number">5353</span>&#125; <span class="string">&quot;HasStep([~label.eq(battled)])&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;DedupGlobalStep@<span class="number">5354</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;HasStep@<span class="number">5355</span>&#125; <span class="string">&quot;HasStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;EdgeVertexStep@<span class="number">5356</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">7</span> = &#123;VertexStep@<span class="number">5357</span>&#125; <span class="string">&quot;VertexStep(IN,[pet],edge)&quot;</span></span><br><span class="line"> <span class="number">8</span> = &#123;EdgeVertexStep@<span class="number">5358</span>&#125; <span class="string">&quot;EdgeVertexStep(OUT)&quot;</span></span><br><span class="line"> <span class="number">9</span> = &#123;HasStep@<span class="number">5359</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><p>上述的<code>gremlin</code>查询语句主要被分为10个算子<code>step</code>执行；</p><h3 id="2-2-优化查询语句"><a href="#2-2-优化查询语句" class="headerlink" title="2.2 优化查询语句"></a>2.2 优化查询语句</h3><p>在<code>Gremlin</code>的查询优化中，存在由<code>策略模式</code>设计实现的19个执行策略类，包含：</p><ol><li>Connective Strategy：连接策略</li><li>Match Predicate Strategy：匹配谓词策略</li><li>Filter Ranking Strategy：过滤排名策略</li><li>Inline Filter Strategy：内联过滤策略</li><li>Incident To Adjacent Strategy：相邻策略事件</li><li>Adjacent To Incident Strategy：邻近事件策略</li><li>Early Limit Strategy：早期限制策略</li><li>Count Strategy：计数策略</li><li>Repeat Unroll Strategy：重复展开策略</li><li>Path Retraction Strategy：路径收回策略</li><li>Lazy Barrier Strategy：惰性屏障策略</li><li>Adjacent Vertex Has Id Optimizer Strategy：相邻顶点有Id优化器策略</li><li>Adjacent Vertex Is Optimizer Strategy：相邻顶点是优化器策略</li><li>Adjacent Vertex Filter Optimizer Strategy：相邻顶点过滤器优化器策略</li><li>JanusGraph Local Query Optimizer Strategy：JanusGraph局部查询优化器策略</li><li>JanusGraph Step Strategy：JanusGraph步骤策略</li><li>JanusGraphIo Registration Strategy：JanusGraphIo注册策略</li><li>Profile Strategy：配置文件策略</li><li>Standard Verification Strategy：标准验证策略</li></ol><p>将上述的查询<code>算子链</code>循环执行所有的19个策略，针对不同的策略进行不同的处理；</p><p>我们主要收一下上述的<code>Match Predicate Strategy</code>、：</p><h4 id="Filter-Ranking-Strategy"><a href="#Filter-Ranking-Strategy" class="headerlink" title="Filter Ranking Strategy"></a>Filter Ranking Strategy</h4><p>依据优先级调整<code>算子链</code>的<code>算子执行顺序</code>！ 采用while+for循环的方式，将所有的算子调整到对应的位置！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (modified) &#123;</span><br><span class="line">           modified = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">final</span> List&lt;Step&gt; steps = traversal.getSteps();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// do somthing</span></span><br><span class="line">               <span class="comment">// update modified！</span></span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级如下，数字越大，优先级越低，执行的时机越靠后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(step <span class="keyword">instanceof</span> FilterStep || step <span class="keyword">instanceof</span> OrderGlobalStep))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> IsStep || step <span class="keyword">instanceof</span> ClassFilterStep)</span><br><span class="line">    rank = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> HasStep)</span><br><span class="line">    rank = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> WherePredicateStep &amp;&amp; ((WherePredicateStep) step).getLocalChildren().isEmpty())</span><br><span class="line">    rank = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> TraversalFilterStep || step <span class="keyword">instanceof</span> NotStep)</span><br><span class="line">    rank = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> WhereTraversalStep)</span><br><span class="line">    rank = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> OrStep)</span><br><span class="line">    rank = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> AndStep)</span><br><span class="line">    rank = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> WherePredicateStep) <span class="comment">// has by()-modulation</span></span><br><span class="line">    rank = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> DedupGlobalStep)</span><br><span class="line">    rank = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (step <span class="keyword">instanceof</span> OrderGlobalStep)</span><br><span class="line">    rank = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>调整过后的算子链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5271</span>&#125;  size = <span class="number">10</span></span><br><span class="line"> <span class="number">0</span> = &#123;GraphStep@<span class="number">5350</span>&#125; <span class="string">&quot;GraphStep(vertex,[])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;HasStep@<span class="number">5351</span>&#125; <span class="string">&quot;HasStep([name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;VertexStep@<span class="number">5352</span>&#125; <span class="string">&quot;VertexStep(OUT,edge)&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;HasStep@<span class="number">5353</span>&#125; <span class="string">&quot;HasStep([~label.eq(battled)])&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;HasStep@<span class="number">5355</span>&#125; <span class="string">&quot;HasStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;DedupGlobalStep@<span class="number">5354</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;EdgeVertexStep@<span class="number">5356</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">7</span> = &#123;VertexStep@<span class="number">5357</span>&#125; <span class="string">&quot;VertexStep(IN,[pet],edge)&quot;</span></span><br><span class="line"> <span class="number">8</span> = &#123;EdgeVertexStep@<span class="number">5358</span>&#125; <span class="string">&quot;EdgeVertexStep(OUT)&quot;</span></span><br><span class="line"> <span class="number">9</span> = &#123;HasStep@<span class="number">5359</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Inline-Filter-Strategy"><a href="#Inline-Filter-Strategy" class="headerlink" title="Inline Filter Strategy"></a>Inline Filter Strategy</h4><p>将<code>同作用域</code>的<code>多个算子</code>内联为一个<code>一个算子</code>；</p><p><strong>相同作用域下，相同算子的内联整合：</strong></p><p>例如，下述语句的两个<code>has</code>会在第一部分的步骤生成两个<code>has算子</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">has(T.label,<span class="string">&quot;battled&quot;</span>).has(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;12&quot;</span>)</span><br></pre></td></tr></table></figure><p>两个<code>has</code>同时作用于<code>V()</code>在同一作用域，又是相同类型，所以在<code>Inline Filter Strategy</code>策略中，会将两个has内联为一个<code>has算子</code>；</p><p><strong>相同作用域下，不同算子的内联整合：</strong></p><p>包含好多种情况，也是举一个例子，如果一个<code>has算子</code>一个<code>vertex算子</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outE().has(label,<span class="string">&quot;battled&quot;</span>)</span><br></pre></td></tr></table></figure><p>满足以下三个条件：</p><ol><li>has算子的前置算子为vertex算子（也就是上述out()产生的算子类型）</li><li>前置的vertex算子返回的类型时edge类型，也就是outE、inE、bothE这三种</li><li>前置的vertex算子，也就是outE、inE、bothE这三种没有指定edge label</li></ol><p>的前提下，has算子的内容为过滤Edge的label；则可以将上述的两种组合成<code>一个vertex算子</code>，可以用以下语句表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outE().has(label,<span class="string">&quot;battled&quot;</span>) ==内联为==&gt;  outE(<span class="string">&quot;battled&quot;</span>)</span><br></pre></td></tr></table></figure><p>调整过后的算子链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5271</span>&#125;  size = <span class="number">9</span></span><br><span class="line"> <span class="number">0</span> = &#123;GraphStep@<span class="number">5350</span>&#125; <span class="string">&quot;GraphStep(vertex,[])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;HasStep@<span class="number">5351</span>&#125; <span class="string">&quot;HasStep([name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;VertexStep@<span class="number">5463</span>&#125; <span class="string">&quot;VertexStep(OUT,[battled],edge)&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;HasStep@<span class="number">5355</span>&#125; <span class="string">&quot;HasStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;DedupGlobalStep@<span class="number">5354</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;EdgeVertexStep@<span class="number">5356</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;VertexStep@<span class="number">5357</span>&#125; <span class="string">&quot;VertexStep(IN,[pet],edge)&quot;</span></span><br><span class="line"> <span class="number">7</span> = &#123;EdgeVertexStep@<span class="number">5358</span>&#125; <span class="string">&quot;EdgeVertexStep(OUT)&quot;</span></span><br><span class="line"> <span class="number">8</span> = &#123;HasStep@<span class="number">5359</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Incident-To-Adjacent-Strategy"><a href="#Incident-To-Adjacent-Strategy" class="headerlink" title="Incident To Adjacent Strategy"></a>Incident To Adjacent Strategy</h4><p>作用也是合并算子，但是合并的是vertex算子（outE、inE、bothE）和edge算子（outV、inV、bothV）；</p><p>举个例子，如下语句，包含一个<code>vertex算子（inE）</code>和一个<code>edge算子(outV)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inE(<span class="string">&quot;pet&quot;</span>).outV()</span><br></pre></td></tr></table></figure><p>这个策略的作用就是将这两个算子合成一个<code>in(&quot;pet&quot;)</code>算子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inE(<span class="string">&quot;pet&quot;</span>).outV() ==合并==&gt; in(<span class="string">&quot;pet&quot;</span>)</span><br></pre></td></tr></table></figure><p>调整后的算子链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5271</span>&#125;  size = <span class="number">8</span></span><br><span class="line"> <span class="number">0</span> = &#123;GraphStep@<span class="number">5350</span>&#125; <span class="string">&quot;GraphStep(vertex,[])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;HasStep@<span class="number">5351</span>&#125; <span class="string">&quot;HasStep([name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;VertexStep@<span class="number">5463</span>&#125; <span class="string">&quot;VertexStep(OUT,[battled],edge)&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;HasStep@<span class="number">5355</span>&#125; <span class="string">&quot;HasStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;DedupGlobalStep@<span class="number">5354</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;EdgeVertexStep@<span class="number">5356</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;VertexStep@<span class="number">5514</span>&#125; <span class="string">&quot;VertexStep(IN,[pet],vertex)&quot;</span></span><br><span class="line"> <span class="number">7</span> = &#123;HasStep@<span class="number">5359</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JanusGraph-Step-Strategy"><a href="#JanusGraph-Step-Strategy" class="headerlink" title="JanusGraph Step Strategy"></a>JanusGraph Step Strategy</h4><p>获取GraphStep算子，也就是V()、E()等对应产生的算子；  将Gremlin的<code>GraphStep算子</code>转换为图库自身的<code>JanusGraphStep算子</code>对象；</p><p>JanusGraphStep算子对象中包含<code>查询图库获取数据</code>的lambda语句；在下一部分<code>执行查询</code>中通过调用<code>get()</code>来进行图库数据查询！</p><p>调整后的算子链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5291</span>&#125;  size = <span class="number">7</span></span><br><span class="line"> <span class="number">0</span> = &#123;JanusGraphStep@<span class="number">5630</span>&#125; <span class="string">&quot;JanusGraphStep([],[name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;JanusGraphVertexStep@<span class="number">5610</span>&#125; <span class="string">&quot;JanusGraphVertexStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;DedupGlobalStep@<span class="number">5341</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;EdgeVertexStep@<span class="number">5343</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;JanusGraphVertexStep@<span class="number">5611</span>&#125; <span class="string">&quot;JanusGraphVertexStep(IN,[pet],vertex)&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;NoOpBarrierStep@<span class="number">5513</span>&#125; <span class="string">&quot;NoOpBarrierStep(2500)&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;HasStep@<span class="number">5346</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>策略共19种，每一种都有自己的作用；优化算子链、优化调整index的使用、count语句的优化、repeat多度路径查询的优化等等</p><p>此<code>查询语句优化</code>部分，对用户自定义的<code>gremlin</code>语句进行<code>正确性验证</code>和<code>优化查询过程的算子链</code>两个作用；</p><p>最终，执行到第优化后的算子链为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steps = &#123;ArrayList@<span class="number">5271</span>&#125;  size = <span class="number">7</span></span><br><span class="line"> <span class="number">0</span> = &#123;JanusGraphStep@<span class="number">6302</span>&#125; <span class="string">&quot;JanusGraphStep([],[name.eq(hercules)])&quot;</span></span><br><span class="line"> <span class="number">1</span> = &#123;JanusGraphVertexStep@<span class="number">6124</span>&#125; <span class="string">&quot;JanusGraphVertexStep([time.eq(12)])&quot;</span></span><br><span class="line"> <span class="number">2</span> = &#123;DedupGlobalStep@<span class="number">5354</span>&#125; <span class="string">&quot;DedupGlobalStep&quot;</span></span><br><span class="line"> <span class="number">3</span> = &#123;EdgeVertexStep@<span class="number">5356</span>&#125; <span class="string">&quot;EdgeVertexStep(IN)&quot;</span></span><br><span class="line"> <span class="number">4</span> = &#123;JanusGraphVertexStep@<span class="number">6125</span>&#125; <span class="string">&quot;JanusGraphVertexStep(IN,[pet],vertex)&quot;</span></span><br><span class="line"> <span class="number">5</span> = &#123;NoOpBarrierStep@<span class="number">5857</span>&#125; <span class="string">&quot;NoOpBarrierStep(2500)&quot;</span></span><br><span class="line"> <span class="number">6</span> = &#123;HasStep@<span class="number">5359</span>&#125; <span class="string">&quot;HasStep([age.eq(4000)])&quot;</span></span><br></pre></td></tr></table></figure><p><strong>扩展：</strong></p><p>Gremlin查询语句执行过程，把执行语句转为由多个step组成对应的算子链，经过优化策略优化调整转化为确定最终可执行算子链。</p><p>Gremlin语言执行过程：</p><ul><li>[D] ecoration-应用级的迭代逻辑上迭代策略</li><li>[O]ptimization在ThinkPop图架构级别上高效迭代策略</li><li>[P]rovider optimization 从系统，语言，驱动级别优化</li><li>[F]inalization 对以上策略做调整确定最终执行策略</li><li>[V]erification:迭代策略做迭代引擎的验证<br>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201202104014468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="2-3-执行算子链"><a href="#2-3-执行算子链" class="headerlink" title="2.3 执行算子链"></a>2.3 执行算子链</h3><p>执行<code>算子链</code>的触发时机在<code>最终语句</code>时进行触发；也就是我们示例语句中下述语句的<code>hasNext()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plutoVertex.hasNext()</span><br></pre></td></tr></table></figure><p>对于<code>hasNext</code>的源码伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.nextEnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.nextEnd = <span class="keyword">this</span>.processNextStart();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.nextEnd.get() &amp;&amp; <span class="number">0</span> != <span class="keyword">this</span>.nextEnd.bulk())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">this</span>.nextEnd = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchElementException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数据执行调用<code>get()</code>触发lambda表达式内容；</p><p>针对不同的算子针对中间结果进行顺序遍历；</p><h2 id="三：源码分析"><a href="#三：源码分析" class="headerlink" title="三：源码分析"></a>三：源码分析</h2><p>源码分析已经push到github：<a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p><h2 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h2><p>整体流程如下：<br><img src="https://img-blog.csdnimg.cn/20200814111228860.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;查询流程可以大致分为三部分：组装查询语句、优化查询语句、执行算子链&lt;/p&gt;
&lt;p&gt;大家好，我是洋仔，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~&lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解Janusgraph系列-官方测试图：诸神之图（Graph of the gods）分析</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%AE%98%E6%96%B9%E6%B5%8B%E8%AF%95%E5%9B%BE%EF%BC%9A%E8%AF%B8%E7%A5%9E%E4%B9%8B%E5%9B%BE%EF%BC%88Graph_of_the_gods%EF%BC%89%E5%88%86%E6%9E%90.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%AE%98%E6%96%B9%E6%B5%8B%E8%AF%95%E5%9B%BE%EF%BC%9A%E8%AF%B8%E7%A5%9E%E4%B9%8B%E5%9B%BE%EF%BC%88Graph_of_the_gods%EF%BC%89%E5%88%86%E6%9E%90.html</id>
    <published>2021-03-03T07:26:00.356Z</published>
    <updated>2021-03-03T07:26:00.351Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Janusgraph</code>中提供了一个用于<code>测试</code>的图，美名其曰“<code>诸神之图</code>”！英文名：<code>Graph of the gods</code>； 响当当的名字哈哈~~</p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（码文不易，求个star~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="诸神之图"><a href="#诸神之图" class="headerlink" title="诸神之图"></a>诸神之图</h2><p>在<code>Janusgraph</code>中提供了一个用于<code>测试</code>的图，美名其曰“<code>诸神之图</code>”！英文名：<code>Graph of the gods</code>； 响当当的名字哈哈~~</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4fe133d07e151893901d1bbb0667ed7b.png" alt="1"></p><p><strong>图中，对应的类型解释如下：</strong><br>| 符号类型         | 含义                                           |<br>| —————- | ———————————————- |<br>| 粗体key          | 图索引键                                       |<br>| 加粗 加星号的key | 图唯一索引键                                   |<br>| 下划线key        | 顶点为中心的索引键，vertex-centric index       |<br>| 空心箭头edge     | 不可重复边，两个节点之间最多只能有一个该类型边 |<br>| 实心箭头edge     | 单向边，只能A–&gt;B，不可以B–&gt;A                 |</p><h3 id="包含类型"><a href="#包含类型" class="headerlink" title="包含类型"></a>包含类型</h3><p><strong>主要包含6种节点类型：</strong></p><ul><li>location：位置（sky：天空，sea：海，tartarus：塔耳塔洛斯）</li><li>titan：巨人（saturn：罗马神话中的农神）</li><li>god：神（jupiter，neptune，pluto）</li><li>demigod：半神（hercules）</li><li>human：人类（alcmene）</li><li>monster：怪物（nemean，hydra，cerberus）</li></ul><p><strong>主要包含6中边类型：</strong></p><ul><li>father：父亲</li><li>mother：母亲</li><li>brother：兄弟</li><li>battled：战斗</li><li>lives：生活在</li><li>pet：宠物</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码在<code>GraphOfTheGodsFactory</code>类的下述方法中： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> JanusGraph graph, String mixedIndexName, <span class="keyword">boolean</span> uniqueNameCompositeIndex)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们接下来分析一下，创建语句源码，具体分析一下图中的组成：</p><blockquote><p>详细解释，已经在代码中注释</p></blockquote><h3 id="1、获取图管理对象实例"><a href="#1、获取图管理对象实例" class="headerlink" title="1、获取图管理对象实例"></a>1、获取图管理对象实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (graph <span class="keyword">instanceof</span> StandardJanusGraph) &#123;</span><br><span class="line">    Preconditions.checkState(mixedIndexNullOrExists((StandardJanusGraph)graph, mixedIndexName), </span><br><span class="line">            ERR_NO_INDEXING_BACKEND, mixedIndexName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Schema</span></span><br><span class="line">JanusGraphManagement management = graph.openManagement();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、创建属性和对应索引"><a href="#2、创建属性和对应索引" class="headerlink" title="2、创建属性和对应索引"></a>2、创建属性和对应索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ===创建name属性； String、唯一CompositeIndex、锁机制保证name的强一致性</span></span><br><span class="line"><span class="keyword">final</span> PropertyKey name = management.makePropertyKey(<span class="string">&quot;name&quot;</span>).dataType(String.class).make();</span><br><span class="line">JanusGraphManagement.IndexBuilder nameIndexBuilder = management.buildIndex(<span class="string">&quot;name&quot;</span>, Vertex.class).addKey(name);</span><br><span class="line"><span class="keyword">if</span> (uniqueNameCompositeIndex)</span><br><span class="line">    nameIndexBuilder.unique();</span><br><span class="line">JanusGraphIndex nameIndex = nameIndexBuilder.buildCompositeIndex();</span><br><span class="line"><span class="comment">// 此处的LOCK，在name索引上添加了LOCK标识，标识这在并发修改相同的name属性时，必须通过锁机制（本地锁+分布式锁）保证并发修改；</span></span><br><span class="line">management.setConsistency(nameIndex, ConsistencyModifier.LOCK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===创建age属性；Integer、mixed index</span></span><br><span class="line"><span class="keyword">final</span> PropertyKey age = management.makePropertyKey(<span class="string">&quot;age&quot;</span>).dataType(Integer.class).make();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != mixedIndexName)</span><br><span class="line">    management.buildIndex(<span class="string">&quot;vertices&quot;</span>, Vertex.class).addKey(age).buildMixedIndex(mixedIndexName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===创建time属性</span></span><br><span class="line"><span class="keyword">final</span> PropertyKey time = management.makePropertyKey(<span class="string">&quot;time&quot;</span>).dataType(Integer.class).make();</span><br><span class="line"><span class="comment">// ===创建reason属性</span></span><br><span class="line"><span class="keyword">final</span> PropertyKey reason = management.makePropertyKey(<span class="string">&quot;reason&quot;</span>).dataType(String.class).make();</span><br><span class="line"><span class="comment">// ===创建place属性</span></span><br><span class="line"><span class="keyword">final</span> PropertyKey place = management.makePropertyKey(<span class="string">&quot;place&quot;</span>).dataType(Geoshape.class).make();</span><br><span class="line"><span class="comment">// 为reason 和 place属性创建mixed index索引edges</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != mixedIndexName)</span><br><span class="line">    management.buildIndex(<span class="string">&quot;edges&quot;</span>, Edge.class).addKey(reason).addKey(place).buildMixedIndex(mixedIndexName);</span><br></pre></td></tr></table></figure><h3 id="3、创建edge类型和对应索引"><a href="#3、创建edge类型和对应索引" class="headerlink" title="3、创建edge类型和对应索引"></a>3、创建edge类型和对应索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建边类型：father， many to one</span></span><br><span class="line">management.makeEdgeLabel(<span class="string">&quot;father&quot;</span>).multiplicity(Multiplicity.MANY2ONE).make();</span><br><span class="line"><span class="comment">// 创建边类型：mother， many to one</span></span><br><span class="line">management.makeEdgeLabel(<span class="string">&quot;mother&quot;</span>).multiplicity(Multiplicity.MANY2ONE).make();</span><br><span class="line"><span class="comment">// 创建边类型：battled， 签名密匙为time:争斗次数，</span></span><br><span class="line">EdgeLabel battled = management.makeEdgeLabel(<span class="string">&quot;battled&quot;</span>).signature(time).make();</span><br><span class="line"><span class="comment">// 为battled边创建一个以顶点为中心的 中心索引（vertex-centric index），索引属性time； 双向索引，可以从 神-&gt;怪物 也可以 怪物-&gt;神</span></span><br><span class="line"><span class="comment">// 将查询节点对应的 battled 边时，可以使用这个vertex-centric索引，索引属性为 time；</span></span><br><span class="line"><span class="comment">// vertex-centric index为了解决大节点问题，一个节点存在过多的边！</span></span><br><span class="line">management.buildEdgeIndex(battled, <span class="string">&quot;battlesByTime&quot;</span>, Direction.BOTH, Order.desc, time);</span><br><span class="line"><span class="comment">// 创建边类型：lives，签名密匙为reason</span></span><br><span class="line">management.makeEdgeLabel(<span class="string">&quot;lives&quot;</span>).signature(reason).make();</span><br><span class="line"><span class="comment">// 创建边类型：pet</span></span><br><span class="line">management.makeEdgeLabel(<span class="string">&quot;pet&quot;</span>).make();</span><br><span class="line"><span class="comment">// 创建边类型：brother</span></span><br><span class="line">management.makeEdgeLabel(<span class="string">&quot;brother&quot;</span>).make();</span><br></pre></td></tr></table></figure><h3 id="4、创建vertex类型"><a href="#4、创建vertex类型" class="headerlink" title="4、创建vertex类型"></a>4、创建vertex类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点label</span></span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;titan&quot;</span>).make();</span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;location&quot;</span>).make();</span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;god&quot;</span>).make();</span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;demigod&quot;</span>).make();</span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;human&quot;</span>).make();</span><br><span class="line">management.makeVertexLabel(<span class="string">&quot;monster&quot;</span>).make();</span><br></pre></td></tr></table></figure><h3 id="5、提交创建的schema数据"><a href="#5、提交创建的schema数据" class="headerlink" title="5、提交创建的schema数据"></a>5、提交创建的schema数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.commit();</span><br></pre></td></tr></table></figure><h3 id="6、插入数据"><a href="#6、插入数据" class="headerlink" title="6、插入数据"></a>6、插入数据</h3><p><strong>获取图事务对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JanusGraphTransaction tx = graph.newTransaction();</span><br></pre></td></tr></table></figure><p><strong>插入节点数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line">Vertex saturn = tx.addVertex(T.label, <span class="string">&quot;titan&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;saturn&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">Vertex sky = tx.addVertex(T.label, <span class="string">&quot;location&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">Vertex sea = tx.addVertex(T.label, <span class="string">&quot;location&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;sea&quot;</span>);</span><br><span class="line">Vertex jupiter = tx.addVertex(T.label, <span class="string">&quot;god&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;jupiter&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">Vertex neptune = tx.addVertex(T.label, <span class="string">&quot;god&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;neptune&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">4500</span>);</span><br><span class="line">Vertex hercules = tx.addVertex(T.label, <span class="string">&quot;demigod&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;hercules&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">Vertex alcmene = tx.addVertex(T.label, <span class="string">&quot;human&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;alcmene&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">45</span>);</span><br><span class="line">Vertex pluto = tx.addVertex(T.label, <span class="string">&quot;god&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;pluto&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">4000</span>);</span><br><span class="line">Vertex nemean = tx.addVertex(T.label, <span class="string">&quot;monster&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;nemean&quot;</span>);</span><br><span class="line">Vertex hydra = tx.addVertex(T.label, <span class="string">&quot;monster&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;hydra&quot;</span>);</span><br><span class="line">Vertex cerberus = tx.addVertex(T.label, <span class="string">&quot;monster&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;cerberus&quot;</span>);</span><br><span class="line">Vertex tartarus = tx.addVertex(T.label, <span class="string">&quot;location&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tartarus&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>插入边数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入边数据</span></span><br><span class="line">jupiter.addEdge(<span class="string">&quot;father&quot;</span>, saturn);</span><br><span class="line">jupiter.addEdge(<span class="string">&quot;lives&quot;</span>, sky, <span class="string">&quot;reason&quot;</span>, <span class="string">&quot;loves fresh breezes&quot;</span>);</span><br><span class="line">jupiter.addEdge(<span class="string">&quot;brother&quot;</span>, neptune);</span><br><span class="line">jupiter.addEdge(<span class="string">&quot;brother&quot;</span>, pluto);</span><br><span class="line"></span><br><span class="line">neptune.addEdge(<span class="string">&quot;lives&quot;</span>, sea).property(<span class="string">&quot;reason&quot;</span>, <span class="string">&quot;loves waves&quot;</span>);</span><br><span class="line">neptune.addEdge(<span class="string">&quot;brother&quot;</span>, jupiter);</span><br><span class="line">neptune.addEdge(<span class="string">&quot;brother&quot;</span>, pluto);</span><br><span class="line"></span><br><span class="line">hercules.addEdge(<span class="string">&quot;father&quot;</span>, jupiter);</span><br><span class="line">hercules.addEdge(<span class="string">&quot;mother&quot;</span>, alcmene);</span><br><span class="line">hercules.addEdge(<span class="string">&quot;battled&quot;</span>, nemean, <span class="string">&quot;time&quot;</span>, <span class="number">1</span>, <span class="string">&quot;place&quot;</span>, Geoshape.point(<span class="number">38.1f</span>, <span class="number">23.7f</span>));</span><br><span class="line">hercules.addEdge(<span class="string">&quot;battled&quot;</span>, hydra, <span class="string">&quot;time&quot;</span>, <span class="number">2</span>, <span class="string">&quot;place&quot;</span>, Geoshape.point(<span class="number">37.7f</span>, <span class="number">23.9f</span>));</span><br><span class="line">hercules.addEdge(<span class="string">&quot;battled&quot;</span>, cerberus, <span class="string">&quot;time&quot;</span>, <span class="number">12</span>, <span class="string">&quot;place&quot;</span>, Geoshape.point(<span class="number">39f</span>, <span class="number">22f</span>));</span><br><span class="line"></span><br><span class="line">pluto.addEdge(<span class="string">&quot;brother&quot;</span>, jupiter);</span><br><span class="line">pluto.addEdge(<span class="string">&quot;brother&quot;</span>, neptune);</span><br><span class="line">pluto.addEdge(<span class="string">&quot;lives&quot;</span>, tartarus, <span class="string">&quot;reason&quot;</span>, <span class="string">&quot;no fear of death&quot;</span>);</span><br><span class="line">pluto.addEdge(<span class="string">&quot;pet&quot;</span>, cerberus);</span><br><span class="line"></span><br><span class="line">cerberus.addEdge(<span class="string">&quot;lives&quot;</span>, tartarus);</span><br></pre></td></tr></table></figure><p><strong>提交事务，持久化数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交事务，持久化提交的数据到磁盘</span></span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><blockquote><p>码字不易，求个赞和star~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;code&gt;Janusgraph&lt;/code&gt;中提供了一个用于&lt;code&gt;测试&lt;/code&gt;的图，美名其曰“&lt;code&gt;诸神之图&lt;/code&gt;”！英文名：&lt;code&gt;Graph of the gods&lt;/code&gt;； 响当当的名字哈哈~~&lt;/p&gt;
&lt;p&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解Janusgraph系列-图数据底层序列化源码分析（Data Serialize）</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Data_Serialize%EF%BC%89.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%95%E5%B1%82%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Data_Serialize%EF%BC%89.html</id>
    <published>2021-03-03T07:25:53.125Z</published>
    <updated>2021-03-03T07:25:53.120Z</updated>
    
    <content type="html"><![CDATA[<p>JanusGraph的数据导入过程主要分为三阶段：prepare（准备）、serialize（序列化）、commit（提交）；不同阶段有不同的作用</p><p>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（码文不易，求个star~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JanusGraph的数据导入过程主要分为三阶段：prepare（准备）、serialize（序列化）、commit（提交）；不同阶段有不同的作用，如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/edc2a4a60a688c22131613f08e71acdd.png" alt="1"></p><p>下面我们分别从导入<code>vertex</code>节点和<code>edge</code>边两部分来分析写流程</p><blockquote><p>建议依据源码同步看本文章，便于理解！</p></blockquote><h2 id="一：vertex数据写流程"><a href="#一：vertex数据写流程" class="headerlink" title="一：vertex数据写流程"></a>一：vertex数据写流程</h2><p>下面<code>vertex</code>节点数据的导入，</p><h3 id="prepare阶段"><a href="#prepare阶段" class="headerlink" title="prepare阶段"></a>prepare阶段</h3><p>主要是依据当前给定的参数，组装出对应的vertex 或者 edge 对象；对象中包含对应的id、索引信息、属性信息和锁信息等；</p><p>过程中包含以下几种作用：</p><ul><li>默认添加<code>vertex exist</code>属性，值为true，标识当前节点是否存在</li><li>默认添加<code>label edge</code>边，标识当前的节点 或者 边是什么label</li><li>生成<code>vertex</code>、<code>edge</code>、<code>property</code>的全局分布式唯一id</li><li>自定义属性验证是否满足唯一性约束</li></ul><p>主要流程如下图（建议依照源码一块查看，上述github地址已给出）：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/353ddca54a801017afb32be1af028f85.png" alt="2"></p><h3 id="serialize阶段"><a href="#serialize阶段" class="headerlink" title="serialize阶段"></a>serialize阶段</h3><p>主要是对上述<code>prepare</code>阶段准备好的数据进行序列化为二进制数据，为存储二进制数据到<code>backend storage</code>做准备； 另外获取本地锁 + 分布式锁数据插入（此处只是将数据插入到Hbase，插入成功并不代表获取成功）</p><p>过程中包含以下几种作用：</p><ul><li>序列化所有<code>relation</code>数据并存储，包含属性、label edge、normal edge</li><li>获取属性对应<code>index</code>需要更新的数据，并序列化存储； 包含<code>组合索引和mixed index</code>的处理</li><li>获取基于图实例的本地锁</li><li>获取了本地锁的前提前，获取<code>edge lock</code> 和 <code>index lock</code>分布式锁（此处的获取锁只是将对应的KLV存储到Hbase中！存储成功并不代表获取锁成功，在commit阶段才会去检查是不是获取分布式锁成功！）</li></ul><p>主要流程如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5367c8541ee4cea92c9e651dde2a035f.png" alt="3"></p><h3 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h3><p>主要是获取<code>本地锁</code>+<code>分布式锁</code>成功后，将对应<code>序列化</code>后的数据添加到对应的<code>backend storage</code>中；完成图数据插入过程！ 在此阶段才会对图库中的真实数据开始影响，才会涉及到事务的回滚机制；</p><p>过程中包含以下几种作用：</p><ul><li>判断分布式锁的状态，获取成功则进行数据持久化；不成功则失败</li><li>持久化<code>relation</code>数据</li><li>持久化<code>index</code>数据，包含组合索引存储到第三方存储；<code>mixed index</code>存储到第三方索引库中</li><li>删除对应的本地锁 和 分布式锁的占用</li></ul><p>主要流程如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/32e6e8224aa2d1bc5e5a9d6eadf66a53.png" alt="4"></p><h2 id="二：edge数据写流程"><a href="#二：edge数据写流程" class="headerlink" title="二：edge数据写流程"></a>二：edge数据写流程</h2><p>针对于<code>edge</code>的写数据流程，整体的流程和<code>vertex</code>节点的数据写入相同，有几点不同，下面一一列出：</p><p><strong>1、生成分布式唯一id的过程</strong></p><p>导入Edge数据在生成edge的唯一id时，<code>partition id</code>的获取不再是<code>随机获取</code>，而是尝试获取边对应的<code>out vertex</code>的<code>partition id</code>；  id的组成部分也不同，没有<code>idPadding</code>部分；</p><p>具体解释请看：《JanusGraph-分布式id生成策略》文章</p><p><strong>2、在<code>edge</code>的导入中，没有同<code>vertex</code>数据导入，添加默认的<code>节点是否存在属性</code>和<code>节点和节点对应label的边</code></strong></p><p><strong>3、获取<code>edge</code>对应的属性的index update时不同</strong></p><p>在导入<code>vertex</code>数据时，将节点对应的属性作为relation存放在addRelation中，然后收集所有的属性relation循环获取index uodate；如下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (InternalRelation add : Iterables.filter(addedRelations,filter)) &#123;        </span><br><span class="line"><span class="keyword">if</span> (add.isProperty()) mutatedProperties.put(vertex,add); <span class="comment">// 此处只操作属性类型的</span></span><br><span class="line">    mutations.put(vertex.longId(), add);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处，收集节点对应属性对应的索引需要更新的数据、增加或删除节点时才有作用； 针对于插入edge的操作，不涉及此处</span></span><br><span class="line"><span class="keyword">for</span> (InternalVertex v : mutatedProperties.keySet()) &#123;</span><br><span class="line">    indexUpdates.addAll(indexSerializer.getIndexUpdates(v,mutatedProperties.get(v)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>edge</code>数据导入中，只将edge这条边作为relation插入到addRelation中，所以无法获取属性relation，转而通过收集过程中，对每个edge对应的所有属性进行分别获取；如下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (InternalRelation add : Iterables.filter(addedRelations,filter)) &#123;</span><br><span class="line"><span class="keyword">if</span> (add.isProperty()) mutatedProperties.put(vertex,add); <span class="comment">// 此处只操作属性类型的</span></span><br><span class="line">    mutations.put(vertex.longId(), add);</span><br><span class="line">    <span class="comment">// 获取边包含的属性；在节点插入时没有作用，插入边数据时，获取边上的属性对应的索引； 只有edge操作中包含边属性，并且包含索引！</span></span><br><span class="line">    indexUpdates.addAll(indexSerializer.getIndexUpdates(add));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、<code>edge</code>对应的relation数据，也就是当前插入的这个边，需要被序列化两次</strong></p><p>一次是源节点+边关系，一次是目标节点+边关系（因为jansugraph是通过edge cut方式存储图数据的）</p><p><strong>5、<code>edge</code>的数据插入过程中，edge的序列化组成部分不同于vertex的序列化组成部分；</strong></p><p>不同点请看《Janusgraph-存储结构》文章</p><p><strong>6、<code>edge</code>的数据插入中，edge的property和vertex的property组成不同！</strong> </p><p><code>edge</code>中针对于<code>sort key</code>和<code>signature key</code>配置的属性，只将<code>property value</code>存储在对应位置。其他未被配置的属性值包含<code>proeprty key label id + property value</code>； </p><p> 不同于vertex数据中的属性组成包含：<code>proeprty key label id + property 唯一id +property value</code></p><h2 id="三：源码分析"><a href="#三：源码分析" class="headerlink" title="三：源码分析"></a>三：源码分析</h2><p>源码分析已经push到github：<a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p><p>数据写入的流程源码过多，就不在文章中给出分析了，具体请看github中源码分析注释吧</p><h2 id="四：应用"><a href="#四：应用" class="headerlink" title="四：应用"></a>四：应用</h2><p>基于数据序列化导入的源码博主将图数据的序列化逻辑抽取出来，生成一个工具包；</p><p>主要用于图数据的迁移和图数据库的初始化，适用于大数据量的导入，主要流程如下：</p><ol><li>生成schema到图中</li><li>获取schema信息，缓存到内存中</li><li>调用api占用对应的id blocker，用于离线数据的分布式唯一id生成</li><li>调用抽取的序列化逻辑序列化节点和边数据</li><li>生成Hfile</li><li>将hfile导入到Hbase中</li></ol><p>上述流程已经经过严格的验证并在生产环境中使用，具体之后会再出一篇文章介绍一下详细的设计与流程</p><h2 id="五：总结"><a href="#五：总结" class="headerlink" title="五：总结"></a>五：总结</h2><p>对于JanusGraph图数据的写入，主要分为3部分：</p><ul><li>schema的创建</li><li>vertex节点数据的导入</li><li>edge边数据的导入</li></ul><p>上述主要分析了<code>vertex</code>和<code>edge</code>的数据导入，大致流程相似；也分析了两部分导入数据的差异；</p><p>其中涉及的<code>分布式唯一id</code>的生成逻辑 和 <code>锁机制获取</code>的逻辑，请看《图解Janusgraph系列-Lock锁机制(本地锁+分布式锁)分析》和《图解Janusgraph系列-分布式id生成策略分析》两篇文章！</p><p>针对于第三方索引的序列化存储逻辑，逻辑相对简单，此处没有给出，具体读者可以自主分析一下源码</p><blockquote><p>码字不易，求个赞和star~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;JanusGraph的数据导入过程主要分为三阶段：prepare（准备）、serialize（序列化）、commit（提交）；不同阶段有不同的作用&lt;/p&gt;
&lt;p&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解Janusgraph系列-分布式id生成策略分析</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3Janusgraph%E7%B3%BB%E5%88%97-%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90.html</id>
    <published>2021-03-03T07:25:45.779Z</published>
    <updated>2021-03-03T07:25:45.773Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍JanusGraph的分布式id生成逻辑；</p><p>大家好，我是洋仔，JanusGraph图解系列文章，<code>实时更新</code>~</p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>**<code>源码分析相关可查看github（求star~~）</code>**： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><blockquote><p>下述流程高清大图地址：<a href="https://www.processon.com/view/link/5f471b2e7d9c086b9903b629">https://www.processon.com/view/link/5f471b2e7d9c086b9903b629</a></p></blockquote><blockquote><p>版本：JanusGraph-0.5.2</p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程<br>微信公众号：匠心Java<br>原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在介绍JanusGraph的分布式ID生成策略之前，我们来简单分析一下<code>分布式ID</code>应该满足哪些特征？</p><ul><li><strong>全局唯一</strong>：必须保证ID是分布式环境中全局性唯一的，这是基本要求</li><li><strong>高性能</strong>：高可用低延时，ID生成响应快；否则可能会成为业务瓶颈</li><li><strong>高可用</strong>：提供分布式id的生成的服务要保证高可用，不能随随便便就挂掉了，会对业务产生影响</li><li><strong>趋势递增</strong>：主要看业务场景，类似于图存储中节点的唯一id就尽量保持趋势递增；但是如果类似于电商订单就尽量不要趋势递增，因为趋势递增会被恶意估算出当天的订单量和成交量，泄漏公司信息</li><li><strong>接入方便</strong>：如果是中间件，要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li></ul><h2 id="一：常用分布式id生成策略"><a href="#一：常用分布式id生成策略" class="headerlink" title="一：常用分布式id生成策略"></a>一：常用分布式id生成策略</h2><p>当前<code>常用的</code>分布式id的生成策略主要分为以下四种：</p><ul><li>UUID</li><li>数据库+号段模式（优化：数据库+号段+双buffer）</li><li>基于Redis实现</li><li>雪花算法（SnowFlake）</li></ul><p>还有一些其他的比如：基于数据库自增id、数据库多主模式等，这些在小并发的情况下可以使用，大并发的情况下就不太ok了</p><p>市面上有一些生成分布式id的开源组件，包括滴滴基于<code>数据库+号段</code>实现的<code>TinyID</code> 、百度基于<code>SnowFlake</code>的<code>Uidgenerator</code>、美团支持<code>号段</code>和<code>SnowFlake</code>的<code>Leaf</code>等</p><p>那么，在JanusGraph中分布式id的生成是采用的什么方式呢？ </p><h2 id="二：JanusGraph的分布式id策略"><a href="#二：JanusGraph的分布式id策略" class="headerlink" title="二：JanusGraph的分布式id策略"></a>二：JanusGraph的分布式id策略</h2><p>在JanusGraph中，分布式id的生成采用的是<code>数据库+号段+双buffer优化</code>的模式； 下面我们来具体分析一下：</p><p>分布式id生成使用的数据库就是JanusGraph当前使用的第三方存储后端，这里我们以使用的存储后端<code>Hbase</code>为例；</p><p><strong>JanusGraph分布式id生成所需元数据存储位置：</strong></p><p>在Hbase中有<code>column family 列族</code>的概念； JanusGraph在初始化Hbase表时默认创建了9大列族，用于存储不同的数据， 具体看《图解图库JanusGraph系列-一文知晓图数据底层存储结构》；</p><p>其中有一个列族<code>janusgraph_ids</code>简写为<code>i</code>这个列族，主要存储的就是JanusGraph分布式id生成所需要的元数据！</p><p><strong>JanusGraph的分布式id的组成结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码中有一句话体现</span></span><br><span class="line">   <span class="comment">/*--- JanusGraphElement id bit format ---</span></span><br><span class="line"><span class="comment">    *  [ 0 | count | partition | ID padding (if any) ]</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>主要分为4部分：<code>0、count、partition、ID padding（每个类型是固定值）</code>；</p><p>其实这4部分的顺序在序列化为二进制数据时，顺序会有所改变；这里只是标明了id的组成部分！</p><p>上述部分的<code>partition</code> + <code>count</code>来保证分布式节点的唯一性；</p><ul><li>partition id：分区id值，JanusGraph默认分了32个逻辑分区；节点分到哪个分区采用的是<code>随机分配</code>;</li><li>count：每个partition都有对应的一个count范围：0-2的55次幂；JanusGraph每次拉取一部分的范围作为节点的count取值；JanusGraph保证了针对相同的partition，不会重复获取同一个count值！</li></ul><p>保证count在partition维度保持全局唯一性，就保证了生成的最终id的全局唯一性！！</p><p><em>则分布式id的唯一性保证，就在于<code>count</code>基于<code>partition</code>维度的唯一性！下面我们的分析也是着重在<code>count</code>的获取！</em></p><p><strong>JanusGraph分布式id生成的主要逻辑流程如下图所示：（推荐结合源码分析观看！）</strong></p><blockquote><p>分析过程中有一个概念为<code>id block</code>：指当前获取的号段范围</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200814111515476.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>JanusGraph主要使用``PartitionIDPool <code>类来存储不同类型的</code>StandardIDPool<code>； 在</code>StandardIDPool`中主要包含两个id Block：</p><ul><li>current block：当前生成id使用的block</li><li>next block：double buffer中的另一个已经准备好的block</li></ul><p><strong>为什么要有两个block呢？</strong> </p><p>主要是如果只有一个block的话，当我们在使用完当前的block时，需要阻塞等待区获取下一个block，这样便会导致分布式id生成较长时间的阻塞等待block的获取；</p><p>怎么优化上述问题呢？ <code>double buffer</code>； </p><p>除了当前使用的block，我们再存储一个<code>next block</code>；当正在使用的block假设已经使用了50%，触发<code>next block</code>的异步获取，如上图的蓝色部分所示；</p><p>这样当<code>current block</code>使用完成后可以直接无延迟的切换到<code>next block</code>如上图中绿色部分所示； </p><p><strong>在执行过程中可能会因为一些异常导致节点id获取失败，则会进行重试；重试次数默认为1000次；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PARTITION_RENEW_ATTEMPTS = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> attempt = <span class="number">0</span>; attempt &lt; MAX_PARTITION_RENEW_ATTEMPTS; attempt++) &#123;</span><br><span class="line">   <span class="comment">// 获取id的过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：上述所说的IDPool和block是基于当前<code>图实例</code>维度共用的！</p></blockquote><h2 id="三：源码分析"><a href="#三：源码分析" class="headerlink" title="三：源码分析"></a>三：源码分析</h2><p>在JanusGraph的源码中，主要包含两大部分和其他的一些组件：</p><ul><li>Graph相关类：用于对节点、属性、边的操作</li><li>Transaction相关类：用于在对数据或者Schema进行CURD时，进行事务处理</li><li>其他一些：分布式节点id生成类；序列化类；第三方索引操作类等等</li></ul><p>Graph和Transaction相关类的类图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200814111528298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>分布式id涉及到id生成的类图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200814111541787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>初始数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertexTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; godProperties = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    godProperties.add(T.label);</span><br><span class="line">    godProperties.add(<span class="string">&quot;god&quot;</span>);</span><br><span class="line"></span><br><span class="line">    godProperties.add(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    godProperties.add(<span class="string">&quot;lyy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    godProperties.add(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    godProperties.add(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    JanusGraphVertex godVertex = graph.addVertex(godProperties.toArray());</span><br><span class="line"></span><br><span class="line">    assertNotNull(godVertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>诸神之图</code>中添加一个name为<code>lyy</code>节点；看下执行流程，注意，此处主要分析的节点的分布式id生成代码！</p><p><strong>1、调用<code>JanusGraphBlueprintsGraph</code>类的<code>AddVertex方法</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphVertex <span class="title">addVertex</span><span class="params">(Object... keyValues)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="keyword">return</span> getAutoStartTx().addVertex(keyValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、调用<code>JanusGraphBlueprintsTransaction</code>的<code>addVertex</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphVertex <span class="title">addVertex</span><span class="params">(Object... keyValues)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 。。。省略了其他的处理</span></span><br><span class="line">     <span class="comment">// 该处生成节点对象，包含节点的唯一id生成逻辑</span></span><br><span class="line">     <span class="keyword">final</span> JanusGraphVertex vertex = addVertex(id, label); </span><br><span class="line">     <span class="comment">// 。。。省略了其他的处理</span></span><br><span class="line">     <span class="keyword">return</span> vertex;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>3、调用<code>StandardJanusGraphTx</code>的<code>addVertex</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JanusGraphVertex <span class="title">addVertex</span><span class="params">(Long vertexId, VertexLabel label)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 。。。省略了其他的处理</span></span><br><span class="line">    <span class="keyword">if</span> (vertexId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        vertex.setId(vertexId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.hasAssignIDsImmediately() || label.isPartitioned()) &#123;</span><br><span class="line">        graph.assignID(vertex,label);  <span class="comment">// 为节点分配正式的节点id！</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 。。。省略了其他的处理</span></span><br><span class="line">    <span class="keyword">return</span> vertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、调用<code>VertexIDAssigner</code>的<code>assignID(InternalElement element, IDManager.VertexIDType vertexIDType)</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignID</span><span class="params">(InternalElement element, IDManager.VertexIDType vertexIDType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始获取节点分布式唯一id</span></span><br><span class="line">    <span class="comment">// 因为一些异常导致获取节点id失败，进行重试，重试此为默认为1000次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> attempt = <span class="number">0</span>; attempt &lt; MAX_PARTITION_RENEW_ATTEMPTS; attempt++) &#123;</span><br><span class="line">        <span class="comment">// 初始化一个partiiton id</span></span><br><span class="line">        <span class="keyword">long</span> partitionID = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取一个partition id</span></span><br><span class="line">        <span class="comment">// 不同类型的数据，partition id的获取方式也有所不同</span></span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> JanusGraphSchemaVertex) &#123;</span><br><span class="line">            <span class="comment">// 为partition id赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 正式分配节点id， 依据partition id 和 节点类型</span></span><br><span class="line">            assignID(element, partitionID, vertexIDType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IDPoolExhaustedException e) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//try again on a different partition</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> element.hasId();</span><br><span class="line">        <span class="comment">// 。。。省略了其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、调用了<code>VertexIDAssigner</code>的<code>assignID(final InternalElement element, final long partitionIDl, final IDManager.VertexIDType userVertexIDType)</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignID</span><span class="params">(<span class="keyword">final</span> InternalElement element, <span class="keyword">final</span> <span class="keyword">long</span> partitionIDl, <span class="keyword">final</span> IDManager.VertexIDType userVertexIDType)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> partitionID = (<span class="keyword">int</span>) partitionIDl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count为分布式id组成中的一部分，占55个字节</span></span><br><span class="line">    <span class="comment">// 分布式id的唯一性保证，就在于`count`基于`partition`维度的唯一性</span></span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">if</span> (element <span class="keyword">instanceof</span> JanusGraphSchemaVertex) &#123; <span class="comment">// schema节点处理</span></span><br><span class="line">        Preconditions.checkArgument(partitionID==IDManager.SCHEMA_PARTITION);</span><br><span class="line">        count = schemaIdPool.nextID();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userVertexIDType==IDManager.VertexIDType.PartitionedVertex) &#123; <span class="comment">// 配置的热点节点，类似于`makeVertexLabel(&#x27;product&#x27;).partition()`的处理</span></span><br><span class="line">        count = partitionVertexIdPool.nextID();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 普通节点和边类型的处理</span></span><br><span class="line">        <span class="comment">// 首先获取当前partition敌营的idPool</span></span><br><span class="line">        PartitionIDPool partitionPool = idPools.get(partitionID);</span><br><span class="line">        <span class="comment">// 如果当前分区对应的IDPool为空，则创建一个默认的IDPool，默认size = 0</span></span><br><span class="line">        <span class="keyword">if</span> (partitionPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在PartitionIDPool中包含多种类型对应的StandardIDPool类型</span></span><br><span class="line">            <span class="comment">// StandardIDPool中包含对应的block信息和count信息</span></span><br><span class="line">            partitionPool = <span class="keyword">new</span> PartitionIDPool(partitionID, idAuthority, idManager, renewTimeoutMS, renewBufferPercentage);</span><br><span class="line">            <span class="comment">// 缓存下来</span></span><br><span class="line">            idPools.putIfAbsent(partitionID,partitionPool);</span><br><span class="line">            <span class="comment">// 从缓存中再重新拿出</span></span><br><span class="line">            partitionPool = idPools.get(partitionID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保partitionPool不为空</span></span><br><span class="line">        Preconditions.checkNotNull(partitionPool);</span><br><span class="line">        <span class="comment">// 判断当前分区的IDPool是否枯竭；已经被用完</span></span><br><span class="line">        <span class="keyword">if</span> (partitionPool.isExhausted()) &#123;</span><br><span class="line">            <span class="comment">// 如果被用完，则将该分区id放到对应的缓存中，避免之后获取分区id再获取到该分区id</span></span><br><span class="line">            placementStrategy.exhaustedPartition(partitionID);</span><br><span class="line">            <span class="comment">// 抛出IDPool异常， 最外层捕获，然后进行重试获取节点id</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IDPoolExhaustedException(<span class="string">&quot;Exhausted id pool for partition: &quot;</span> + partitionID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储当前类型对应的IDPool，因为partitionPool中保存好几个类型的IDPool</span></span><br><span class="line">        IDPool idPool;</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> JanusGraphRelation) &#123;</span><br><span class="line">            idPool = partitionPool.getPool(PoolType.RELATION);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Preconditions.checkArgument(userVertexIDType!=<span class="keyword">null</span>);</span><br><span class="line">            idPool = partitionPool.getPool(PoolType.getPoolTypeFor(userVertexIDType));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重要！！！！ 依据给定的IDPool获取count值！！！！</span></span><br><span class="line">            <span class="comment">// 在此语句中设计 block的初始化 和 double buffer block的处理！</span></span><br><span class="line">            count = idPool.nextID();</span><br><span class="line">            partitionPool.accessed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IDPoolExhaustedException e) &#123; <span class="comment">// 如果该IDPool被用完，抛出IDPool异常， 最外层捕获，然后进行重试获取节点id</span></span><br><span class="line">            log.debug(<span class="string">&quot;Pool exhausted for partition id &#123;&#125;&quot;</span>, partitionID);</span><br><span class="line">            placementStrategy.exhaustedPartition(partitionID);</span><br><span class="line">            partitionPool.exhaustedIdPool();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装最终的分布式id：[count + partition id + ID padding]</span></span><br><span class="line">    <span class="keyword">long</span> elementId;</span><br><span class="line">    <span class="keyword">if</span> (element <span class="keyword">instanceof</span> InternalRelation) &#123;</span><br><span class="line">        elementId = idManager.getRelationID(count, partitionID);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> PropertyKey) &#123;</span><br><span class="line">        elementId = IDManager.getSchemaId(IDManager.VertexIDType.UserPropertyKey,count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> EdgeLabel) &#123;</span><br><span class="line">        elementId = IDManager.getSchemaId(IDManager.VertexIDType.UserEdgeLabel, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> VertexLabel) &#123;</span><br><span class="line">        elementId = IDManager.getSchemaId(IDManager.VertexIDType.VertexLabel, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">instanceof</span> JanusGraphSchemaVertex) &#123;</span><br><span class="line">        elementId = IDManager.getSchemaId(IDManager.VertexIDType.GenericSchemaType,count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementId = idManager.getVertexID(count, partitionID, userVertexIDType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkArgument(elementId &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 对节点对象赋值其分布式唯一id</span></span><br><span class="line">    element.setId(elementId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，我们拿到了对应的IdPool，有两种情况：</p><ul><li>第一次获取分布式id时，分区对应的IDPool初始化为默认的size = 0的IDPool</li><li>分区对应的IDPool不是初次获取</li></ul><p>这两种情况的处理，都在代码<code>count = idPool.nextID()</code>的<code>StandardIDPool</code>类中的<code>nextID()</code>方法中被处理！</p><p><strong>在分析该代码之前，我们需要知道 <code>PartitionIDPool </code>和<code>StandardIDPool</code>的关系：</strong></p><p>每个partition都有一个对应的<code>PartitionIDPool extends EnumMap&lt;PoolType,IDPool&gt; </code> 是一个枚举map类型；</p><p>每一个<code>PartitionIDPool </code>都有对应的不同类型的<code>StandardIDPool</code>：</p><ul><li>NORMAL_VERTEX：用于vertex id的分配</li><li>UNMODIFIABLE_VERTEX：用于schema label id的分配</li><li>RELATION：用于edge id的分配</li></ul><p>在<code>StandardIDPool</code>中包含多个字段，分别代表不同的含义，抽取几个重要的字段进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RENEW_ID_COUNT = <span class="number">100</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> idUpperBound; <span class="comment">// Block的最大值，默认为2的55次幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition; <span class="comment">// 当前pool对应的分区</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> idNamespace; <span class="comment">// 标识pool为那种类型的pool，上述的三种类型NORMAL_VERTEX、UNMODIFIABLE_VERTEX、RELATION；值为当前枚举值在枚举中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Duration renewTimeout;<span class="comment">// 重新获取block的超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> renewBufferPercentage;<span class="comment">// 双buffer中，当第一个buffer block使用的百分比，到达配置的百分比则触发other buffer block的获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IDBlock currentBlock; <span class="comment">// 当前的block</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> currentIndex; <span class="comment">// 标识当前block使用到那一个位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> renewBlockIndex; <span class="comment">// 依据currentBlock.numIds()*renewBufferPercentage来获取这个值，主要用于在当前的block在消费到某个index的时候触发获取下一个buffer block</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> IDBlock nextBlock;<span class="comment">// 双buffer中的另外一个block</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor exec;<span class="comment">// 异步获取双buffer的线程池</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6、调用了<code>StandardIDPool</code>类中的<code>nextID</code>方法</strong></p><p>经过上述分析，我们知道，分布式唯一id的唯一性是由在partition维度下的count的值的唯一性来保证的；</p><p>上述代码通过调用IDPool的nextId来获取count值； </p><p>下述代码就是获取count的逻辑；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentIndex标识当前的index小于current block的最大值</span></span><br><span class="line">    <span class="keyword">assert</span> currentIndex &lt;= currentBlock.numIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处涉及两种情况：</span></span><br><span class="line">    <span class="comment">// 1、分区对应的IDPool是第一次被初始化；则currentIndex = 0； currentBlock.numIds() = 0；</span></span><br><span class="line">    <span class="comment">// 2、分区对应的该IDPool不是第一次，但是此次的index正好使用到了current block的最后一个count</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == currentBlock.numIds()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将current block赋值为next block</span></span><br><span class="line">            <span class="comment">// next block置空 并计算renewBlockIndex</span></span><br><span class="line">            nextBlock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JanusGraphException(<span class="string">&quot;Could not renew id block due to interruption&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在使用current block的过程中，当current index  ==  renewBlockIndex时，触发double buffer next block的异步获取！！！！</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex == renewBlockIndex) &#123;</span><br><span class="line">        <span class="comment">// 异步获取next block</span></span><br><span class="line">        startIDBlockGetter();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成最终的count</span></span><br><span class="line">    <span class="keyword">long</span> returnId = currentBlock.getId(currentIndex);</span><br><span class="line">    <span class="comment">// current index + 1</span></span><br><span class="line">    currentIndex++;</span><br><span class="line">    <span class="keyword">if</span> (returnId &gt;= idUpperBound) <span class="keyword">throw</span> <span class="keyword">new</span> IDPoolExhaustedException(<span class="string">&quot;Reached id upper bound of &quot;</span> + idUpperBound);</span><br><span class="line">    log.trace(<span class="string">&quot;partition(&#123;&#125;)-namespace(&#123;&#125;) Returned id: &#123;&#125;&quot;</span>, partition, idNamespace, returnId);</span><br><span class="line">    <span class="comment">// 返回最终获取的分区维度的全局唯一count</span></span><br><span class="line">    <span class="keyword">return</span> returnId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中进行了两次判断：</p><ul><li>currentIndex == currentBlock.numIds()：<ul><li>第一次生成分布式id：此处判断即为 0==0；然后生成新的block</li><li>非第一次生成分布式id：等于情况下标识当前的block已经使用完了，需要切换为next block</li></ul></li><li>currentIndex == renewBlockIndex<ul><li>renew index：标识index使用多少后开始获取下一个double buffer 的next block；有一个默认值100，主要为了兼容第一次分布式id的生成；相等则会触发异步获取下一个next block</li></ul></li></ul><p>下面我们分别对<code>nextBlock();</code>逻辑和<code>startIDBlockGetter();</code>进行分析；</p><p><strong>7、调用了<code>StandardIDPool</code>类中的<code>nextBlock</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">nextBlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 在分区对应的IDPool第一次使用时，double buffer的nextBlock为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == nextBlock &amp;&amp; <span class="keyword">null</span> == idBlockFuture) &#123;</span><br><span class="line">        <span class="comment">// 异步启动 获取id block</span></span><br><span class="line">        startIDBlockGetter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是在分区对应的IDPool第一次使用时，因为上述为异步获取，所以在执行到这一步时nextBlock可能还没拿到</span></span><br><span class="line">    <span class="comment">// 所以需要阻塞等待block的获取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == nextBlock) &#123;</span><br><span class="line">        waitForIDBlockGetter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前使用block指向next block</span></span><br><span class="line">    currentBlock = nextBlock;</span><br><span class="line">    <span class="comment">// index清零</span></span><br><span class="line">    currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// nextBlock置空</span></span><br><span class="line">    nextBlock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// renewBlockIndex用于双buffer中，当第一个buffer block使用的百分比，到达配置的百分比则触发other buffer block的获取</span></span><br><span class="line">    <span class="comment">// 值current block 对应的count数量 - （值current block 对应的count数量 * 为renewBufferPercentage配置的剩余空间百分比）</span></span><br><span class="line">    <span class="comment">// 在使用current block的时候，当current index  ==  renewBlockIndex时，触发double buffer next block的异步获取！！！！</span></span><br><span class="line">    renewBlockIndex = Math.max(<span class="number">0</span>,currentBlock.numIds()-Math.max(RENEW_ID_COUNT, Math.round(currentBlock.numIds()*renewBufferPercentage)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是做了三件事：</p><ul><li>1、block是否为空，为空的话则异步获取一个block</li><li>2、nextBlock不为空的情况下：next赋值到current、next置空、index置零</li><li>3、计算获取下一个nextBlock的触发index renewBlockIndex值</li></ul><p><strong>8、调用了<code>StandardIDPool</code>类中的<code>startIDBlockGetter</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startIDBlockGetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(idBlockFuture == <span class="keyword">null</span>, idBlockFuture);</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">return</span>; <span class="comment">//Don&#x27;t renew anymore if closed</span></span><br><span class="line">    <span class="comment">//Renew buffer</span></span><br><span class="line">    log.debug(<span class="string">&quot;Starting id block renewal thread upon &#123;&#125;&quot;</span>, currentIndex);</span><br><span class="line">    <span class="comment">// 创建一个线程对象，包含给定的权限控制类、分区、命名空间、超时时间</span></span><br><span class="line">    idBlockGetter = <span class="keyword">new</span> IDBlockGetter(idAuthority, partition, idNamespace, renewTimeout);</span><br><span class="line">    <span class="comment">// 提交获取double buffer的线程任务，异步执行</span></span><br><span class="line">    idBlockFuture = exec.submit(idBlockGetter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建一个线程任务，提交到线程池<code>exec</code>进行异步执行；</p><p>下面看下，线程类的<code>call</code>方法主要是调用了<code> idAuthority.getIDBlock</code>方法，这个方法主要是基于Hbase来获取还未使用的block；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取double buffer block的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IDBlockGetter</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">IDBlock</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDBlock <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stopwatch running = Stopwatch.createStarted();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处调用idAuthority 调用HBase进行占用获取Block</span></span><br><span class="line">            IDBlock idBlock = idAuthority.getIDBlock(partition, idNamespace, renewTimeout);</span><br><span class="line">            <span class="keyword">return</span> idBlock;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BackendException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、调用<code>ConsistentKeyIDAuthority</code>类的<code>getIDBlock</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> IDBlock <span class="title">getIDBlock</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> partition, <span class="keyword">final</span> <span class="keyword">int</span> idNamespace, Duration timeout)</span> <span class="keyword">throws</span> BackendException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">final</span> Timer methodTime = times.getTimer().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前命名空间配置的blockSize，默认值10000；可自定义配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> blockSize = getBlockSize(idNamespace);</span><br><span class="line">    <span class="comment">// 获取当前命名空间配置的最大id值idUpperBound；值为：2的55次幂大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idUpperBound = getIdUpperBound(idNamespace);</span><br><span class="line">    <span class="comment">// uniqueIdBitWidth标识uniqueId占用的位数；uniqueId为了兼容“关闭分布式id唯一性保障”的开关情况，uniqueIdBitWidth默认值=4</span></span><br><span class="line">    <span class="comment">// 值：64-1(默认0)-5（分区占用位数）-3（ID Padding占用位数）-4（uniqueIdBitWidth） = 51；标识block中的上限为2的51次幂大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxAvailableBits = (VariableLong.unsignedBitLength(idUpperBound)-<span class="number">1</span>)-uniqueIdBitWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识block中的上限为2的51次幂大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idBlockUpperBound = (<span class="number">1L</span> &lt;&lt;maxAvailableBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UniquePID用尽的UniquePID集合，默认情况下，randomUniqueIDLimit = 0；</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; exhaustedUniquePIDs = <span class="keyword">new</span> ArrayList&lt;&gt;(randomUniqueIDLimit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认0.3秒  用于处理TemporaryBackendException异常情况（后端存储出现问题）下：阻塞一断时间，然后进行重试</span></span><br><span class="line">    Duration backoffMS = idApplicationWaitMS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从开始获取IDBlock开始，持续超时时间（默认2分钟）内重试获取IDBlock</span></span><br><span class="line">    <span class="keyword">while</span> (methodTime.elapsed().compareTo(timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> uniquePID = getUniquePartitionID(); <span class="comment">// 获取uniquePID，默认情况下“开启分布式id唯一性控制”，值 = 0； 当“关闭分布式id唯一性控制”时为一个随机值</span></span><br><span class="line">        <span class="keyword">final</span> StaticBuffer partitionKey = getPartitionKey(partition,idNamespace,uniquePID); <span class="comment">// 依据partition + idNamespace + uniquePID组装一个RowKey</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nextStart = getCurrentID(partitionKey); <span class="comment">// 从Hbase中获取当前partition对应的IDPool中被分配的最大值，用来作为当前申请新的block的开始值</span></span><br><span class="line">            <span class="keyword">if</span> (idBlockUpperBound - blockSize &lt;= nextStart) &#123; <span class="comment">// 确保还未被分配的id池中的id个数，大于等于blockSize</span></span><br><span class="line">                <span class="comment">// 相应处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> nextEnd = nextStart + blockSize; <span class="comment">// 获取当前想要获取block的最大值</span></span><br><span class="line">            StaticBuffer target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// attempt to write our claim on the next id block</span></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Timer writeTimer = times.getTimer().start(); <span class="comment">// ===开始：开始进行插入自身的block需求到Hbase</span></span><br><span class="line">                target = getBlockApplication(nextEnd, writeTimer.getStartTime()); <span class="comment">// 组装对应的Column: -nextEnd +  当前时间戳 + uid（唯一标识当前图实例）</span></span><br><span class="line">                <span class="keyword">final</span> StaticBuffer finalTarget = target; <span class="comment">// copy for the inner class</span></span><br><span class="line">                BackendOperation.execute(txh -&gt; &#123; <span class="comment">// 异步插入当前生成的RowKey 和 Column</span></span><br><span class="line">                    idStore.mutate(partitionKey, Collections.singletonList(StaticArrayEntry.of(finalTarget)), KeyColumnValueStore.NO_DELETIONS, txh);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;,<span class="keyword">this</span>,times);</span><br><span class="line">                writeTimer.stop(); <span class="comment">// ===结束：插入完成</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> distributed = manager.getFeatures().isDistributed();</span><br><span class="line">                Duration writeElapsed = writeTimer.elapsed(); <span class="comment">// ===获取方才插入的时间耗时</span></span><br><span class="line">                <span class="keyword">if</span> (idApplicationWaitMS.compareTo(writeElapsed) &lt; <span class="number">0</span> &amp;&amp; distributed) &#123; <span class="comment">// 判断是否超过配置的超时时间，超过则报错TemporaryBackendException，然后等待一断时间进行重试</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryBackendException(<span class="string">&quot;Wrote claim for id block [&quot;</span> + nextStart + <span class="string">&quot;, &quot;</span> + nextEnd + <span class="string">&quot;) in &quot;</span> + (writeElapsed) + <span class="string">&quot; =&gt; too slow, threshold is: &quot;</span> + idApplicationWaitMS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">assert</span> <span class="number">0</span> != target.length();</span><br><span class="line">                    <span class="keyword">final</span> StaticBuffer[] slice = getBlockSlice(nextEnd); <span class="comment">// 组装下述基于上述Rowkey的Column的查找范围：(-nextEnd + 0 : 0nextEnd + 最大值)      </span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> List&lt;Entry&gt; blocks = BackendOperation.execute( <span class="comment">// 异步获取指定Rowkey和指定Column区间的值</span></span><br><span class="line">                        (BackendOperation.Transactional&lt;List&lt;Entry&gt;&gt;) txh -&gt; idStore.getSlice(<span class="keyword">new</span> KeySliceQuery(partitionKey, slice[<span class="number">0</span>], slice[<span class="number">1</span>]), txh),<span class="keyword">this</span>,times);</span><br><span class="line">                    <span class="keyword">if</span> (blocks == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryBackendException(<span class="string">&quot;Could not read from storage&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (blocks.isEmpty())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> PermanentBackendException(<span class="string">&quot;It seems there is a race-condition in the block application. &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;If you have multiple JanusGraph instances running on one physical machine, ensure that they have unique machine idAuthorities&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (target.equals(blocks.get(<span class="number">0</span>).getColumnAs(StaticBuffer.STATIC_FACTORY))) &#123; <span class="comment">// 如果获取的集合中，当前的图实例插入的数据是第一条，则表示获取block; 如果不是第一条，则获取Block失败</span></span><br><span class="line">                        <span class="comment">// 组装IDBlock对象</span></span><br><span class="line">                        ConsistentKeyIDBlock idBlock = <span class="keyword">new</span> ConsistentKeyIDBlock(nextStart,blockSize,uniqueIdBitWidth,uniquePID);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                                idBlock, partition, idNamespace, uid);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> idBlock; <span class="comment">// 返回</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!success &amp;&amp; <span class="keyword">null</span> != target) &#123; <span class="comment">// 在获取Block失败后，删除当前的插入； 如果没有失败，则保留当前的插入，在hbase中标识该Block已经被占用</span></span><br><span class="line">                    <span class="comment">//Delete claim to not pollute id space</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> attempt = <span class="number">0</span>; attempt &lt; ROLLBACK_ATTEMPTS; attempt++) &#123; <span class="comment">// 回滚：删除当前插入，尝试次数5次</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UniqueIDExhaustedException e) &#123;</span><br><span class="line">            <span class="comment">// No need to increment the backoff wait time or to sleep</span></span><br><span class="line">            log.warn(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TemporaryBackendException e) &#123;</span><br><span class="line">            backoffMS = Durations.min(backoffMS.multipliedBy(<span class="number">2</span>), idApplicationWaitMS.multipliedBy(<span class="number">32</span>));</span><br><span class="line">            sleepAndConvertInterrupts(backoffMS); \</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TemporaryLockingException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的逻辑就是：</p><ul><li><code>组装Rowkey</code>：partition + idNameSpace+unquePId</li><li><code>组装Column</code>：-nextEnd+now time+uid</li><li>将<code>RowKey+Column</code>插入Hbase</li><li>获取的上述组装的RowKey 基于(-nextEnd + 0 : -nextEnd + max)范围的所有Column集合</li><li>判断集合的第一个Column是不是当前插入的Column，是的话则占用block成功，不是的话则占用失败，删除刚才占用并进行重试</li></ul><p><strong>最终：异步获取到了唯一占用的Block，然后生成对应的唯一count，组装最后的唯一id</strong></p><p>整体的调用流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200827102235569.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="四：其他类型的id生成"><a href="#四：其他类型的id生成" class="headerlink" title="四：其他类型的id生成"></a>四：其他类型的id生成</h2><p>上述我们主要依据生成节点id（vertex id）的过程来进行分析</p><p>在<code>JanusGraph</code>中还包含<code>edge id</code>、<code>property id</code>、<code>schema label id</code>等几种的分布式id生成</p><p>所有类型的分布式id的生成主要思想和逻辑都几乎相同，只是一些具体的逻辑可能有所不同，我们理解了<code>vertex id</code>的分布式id生成流程，其他的也可以理解了。</p><h3 id="1、property-id的生成"><a href="#1、property-id的生成" class="headerlink" title="1、property id的生成"></a>1、property id的生成</h3><p>在JanusGraph中的<code>property</code>的分布式唯一id的生成，整体逻辑和<code>vertex id</code>的生成逻辑大体相同；</p><p><strong><code>property id</code>的 生成和 <code>vertex id</code>有两点不同：</strong></p><ul><li>ID的组成部分：  在<code>vertex id</code>中组成部分包含<code>count</code>+<code>partition</code>+<code>ID Padding</code>； 而在<code>property id</code>中没有<code>ID Padding</code>部分，其组成为<code>count + partition</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> id = (count&lt;&lt;partitionBits)+partition;</span><br><span class="line"><span class="keyword">if</span> (type!=<span class="keyword">null</span>) id = type.addPadding(id); <span class="comment">// 此时，type = null</span></span><br><span class="line"><span class="keyword">return</span> id;</span><br></pre></td></tr></table></figure><ul><li>partition id的获取方式：在生成<code>vertex id</code>时，partition id是随机获取的；而在生成<code>property id</code>时，partition id是获取的当前节点对应的partition id，如果节点获取不到分区id，则随机生成一个； </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element <span class="keyword">instanceof</span> InternalRelation) &#123; <span class="comment">// 属性 + 边</span></span><br><span class="line">    InternalRelation relation = (InternalRelation)element;</span><br><span class="line">    <span class="keyword">if</span> (attempt &lt; relation.getLen()) &#123; </span><br><span class="line">        InternalVertex incident = relation.getVertex(attempt);</span><br><span class="line">        Preconditions.checkArgument(incident.hasId());</span><br><span class="line">        <span class="keyword">if</span> (!IDManager.VertexIDType.PartitionedVertex.is(incident.longId()) || relation.isProperty()) &#123; <span class="comment">// 获取对应节点已有的partition id</span></span><br><span class="line">            partitionID = getPartitionID(incident);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果对应的节点都没有，则随机获取一个partition id</span></span><br><span class="line">        partitionID = placementStrategy.getPartition(element);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2、Edge-id的生成"><a href="#2、Edge-id的生成" class="headerlink" title="2、Edge id的生成"></a>2、Edge id的生成</h3><p>在JanusGraph中的<code>edge</code>的分布式唯一id的生成，整体逻辑和<code>vertex id</code>的生成逻辑大体相同；</p><p><strong><code>edge id</code>的 生成和 <code>vertex id</code>有两点不同：</strong></p><ul><li>ID的组成部分：  在<code>vertex id</code>中组成部分包含<code>count</code>+<code>partition</code>+<code>ID Padding</code>； 而在<code>edge id</code>中没有<code>ID Padding</code>部分，其组成为<code>count + partition</code>，代码同<code>property id</code>的生成代码</li><li>partition id的获取方式：在生成<code>vertex id</code>时，partition id是随机获取的；而在生成<code>edge id</code>时，partition id是获取的当前<code>source vertex</code> 或者 <code>target vertex</code>对应的partition id，如果节点获取不到分区id，则随机生成一个，代码同<code>property id</code>的生成代码； </li></ul><h3 id="3、Schema相关id的生成"><a href="#3、Schema相关id的生成" class="headerlink" title="3、Schema相关id的生成"></a>3、Schema相关id的生成</h3><p>在JanusGraph中的<code>schema相关id</code>的分布式唯一id的生成，整体逻辑和<code>vertex id</code>的生成逻辑大体相同；</p><p>schema相关id的生成分为四种：<code>PropertyKey</code>、<code>EdgeLabel</code>、<code>VertexLabel</code>、<code>JanusGraphSchemaVertex</code></p><ul><li>ID的组成部分：  在<code>vertex id</code>中组成部分包含<code>count</code>+<code>partition</code>+<code>ID Padding</code>； 在<code>schema</code>对应的id生成，这四种产生的id对应的结构都是一样的：<code>count + 对应类型的固定后缀</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (count &lt;&lt; offset()) | suffix();</span><br></pre></td></tr></table></figure><ul><li>partition id的获取方式：在生成<code>vertex id</code>时，partition id是随机获取的；而在生成<code>schema id</code>时，partition id是默认的<code>partition id = 0</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEMA_PARTITION = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (element <span class="keyword">instanceof</span> JanusGraphSchemaVertex) &#123;</span><br><span class="line">                partitionID = IDManager.SCHEMA_PARTITION; <span class="comment">// 默认分区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文总结了<code>JanusGraph</code>的分布式唯一id的生成逻辑，也进行的源码分析； </p><blockquote><p>下一篇，JanusGraph的锁机制分析，包含本地锁和分布式锁相关的分析，我是“洋仔”，我们下期见~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍JanusGraph的分布式id生成逻辑；&lt;/p&gt;
&lt;p&gt;大家好，我是洋仔，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~&lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>图解JanusGraph系列-JanusGraph指标监控报警（Monitoring JanusGraph）</title>
    <link href="http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-JanusGraph%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%EF%BC%88Monitoring_JanusGraph%EF%BC%89.html"/>
    <id>http://coderstudy.vip/article/%E5%9B%BE%E8%A7%A3JanusGraph%E7%B3%BB%E5%88%97-JanusGraph%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%EF%BC%88Monitoring_JanusGraph%EF%BC%89.html</id>
    <published>2021-03-03T07:25:29.126Z</published>
    <updated>2021-03-03T07:25:29.119Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍JanusGraph的监控机制；<br>大家好，我是<code>洋仔</code>，JanusGraph图解系列文章，<code>实时更新</code>~  </p><span id="more"></span><h4 id="图数据库文章总目录："><a href="#图数据库文章总目录：" class="headerlink" title="图数据库文章总目录："></a>图数据库文章总目录：</h4><ul><li><strong>整理所有图相关文章，请移步(超链)：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">图数据库系列-文章总目录 </a>    </li><li><strong>地址：</strong><a href="https://liyangyang.blog.csdn.net/article/details/111031257">https://liyangyang.blog.csdn.net/article/details/111031257</a></li></ul><blockquote><p>源码分析相关可查看<strong>github</strong>（<code>码文不易，求个star~</code>）： <a href="https://github.com/YYDreamer/janusgraph">https://github.com/YYDreamer/janusgraph</a></p></blockquote><p> <strong>转载文章请保留以下声明：</strong></p><blockquote><p>作者：洋仔聊编程、微信公众号：匠心Java、原文地址：<a href="https://liyangyang.blog.csdn.net/">https://liyangyang.blog.csdn.net/</a></p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JanusGraph框架提供了一些可监控的指标，用于我们在使用janus图数据库时可以对一些指标进行监控，下面我们看下如何配置使用Janusgraph监控！</p><p><strong>本文主要讲解了3部分：</strong></p><ol><li> 监控的指标类型和配置</li><li> 监控指标数据展示存储的位置（Reporter）</li><li> 实战应用案例，并对打印出的指标进行了分析</li><li>最后给出一个监控设计的架构图</li></ol><h2 id="一：监控的底层实现"><a href="#一：监控的底层实现" class="headerlink" title="一：监控的底层实现"></a>一：监控的底层实现</h2><p><strong>JanusGraph通过支持Metrics来实现指标数据收集，什么是<code>Metrics</code>?</strong></p><p>Metrics是框架Dropwizard提供的一个lib包，主要用于项目指标的收集作用，JanusGraph就是基于Metrics这个组件开发的指标收集模块；</p><p>Dropwizard是一个Java框架，用于开发对操作友好的高性能RESTful Web服务，将来自Java生态系统的稳定，成熟的库汇集到一个简单的程序包中，使我们可以专注于完成工作。</p><p>Dropwizard对复杂的配置，应用程序指标，日志记录，操作工具等提供了开箱即用的支持；</p><h2 id="二：JanusGraph中的指标"><a href="#二：JanusGraph中的指标" class="headerlink" title="二：JanusGraph中的指标"></a>二：JanusGraph中的指标</h2><p>JanusGraph可以收集以下指标：</p><ul><li>begin，commit和 roll back的事务数</li><li>每种存储后端操作类型的 请求次数 和 失败次数</li><li>每种存储后端操作类型的响应时间分布</li></ul><h3 id="2-1-配置指标收集"><a href="#2-1-配置指标收集" class="headerlink" title="2.1 配置指标收集"></a>2.1 配置指标收集</h3><p>要启用指标标准收集，需要在JanusGraph的属性文件中设置以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Required to enable Metrics in JanusGraph</span><br><span class="line">metrics.enabled &#x3D; true</span><br></pre></td></tr></table></figure><p>此设置使JanusGraph在运行时使用计时器、计数器、直方图等Metrics类记录测量结果。</p><h4 id="自定义默认指标名称"><a href="#自定义默认指标名称" class="headerlink" title="自定义默认指标名称"></a>自定义默认指标名称</h4><p>默认情况下，JanusGraph为所有度量标准名称添加“ org.janusgraph”前缀。可以通过<code>metrics.prefix</code>配置属性设置此前缀。例如，将默认的“ org.janusgraph”前缀缩短为“ janusgraph”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Optional</span><br><span class="line">metrics.prefix &#x3D; janusgraph</span><br></pre></td></tr></table></figure><h4 id="特定事务指标名称"><a href="#特定事务指标名称" class="headerlink" title="特定事务指标名称"></a>特定事务指标名称</h4><p>每个JanusGraph事务都可以选择指定其自己的指标名称前缀，从而覆盖默认的指标名称前缀和 <code>metrics.prefix</code>配置属性。例如，可以将前缀更改为打开JanusGraph事务的前端应用程序的名称。</p><p>请注意，Metrics在内存中维护度量标准名称及其相关对象的ConcurrentHashMap，因此，保持不同度量标准前缀的数量较小可能是个好主意。</p><p>下面使用案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JanusGraph graph = ...;  <span class="comment">// 获取图实例连接</span></span><br><span class="line">TransactionBuilder tbuilder = graph.buildTransaction(); <span class="comment">// 开启一个事务构建器</span></span><br><span class="line">JanusGraphTransaction tx = tbuilder.groupName(<span class="string">&quot;foobar&quot;</span>).start(); <span class="comment">// 开启一个事务，并开启指标收集，Metrics前缀为foobar</span></span><br></pre></td></tr></table></figure><p>下面为<code>groupName</code>的方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> * Sets the name prefix used <span class="keyword">for</span> Metrics recorded by <span class="keyword">this</span> transaction. If</span><br><span class="line"> * metrics is enabled via &#123;@link GraphDatabaseConfiguration#BASIC_METRICS&#125;,</span><br><span class="line"> * <span class="keyword">this</span> string will be prepended to all JanusGraph metric names.</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@param</span> name Metric name prefix <span class="keyword">for</span> <span class="keyword">this</span> transaction</span><br><span class="line"> * <span class="meta">@return</span> Object containing transaction prefix name property</span><br><span class="line"> */</span><br><span class="line"><span class="function">TransactionBuilder <span class="title">groupName</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="分开指标统计"><a href="#分开指标统计" class="headerlink" title="分开指标统计"></a>分开指标统计</h4><p>JanusGraph在默认情况下组合了其各种内部存储后端句柄的指标，也就是说：会将所有的操作统一收集为一种类型指标；</p><p>存储后端交互的所有指标标准都遵循“ &lt;prefix&gt; .stores.&lt;opname&gt;”模式，无论它们是否是idStore，edgeStore的操作等；</p><p>如果想要分开每种操作类型收集的指标，配置以下参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metrics.merge-basic-metrics = false</span><br></pre></td></tr></table></figure><p> <code>metrics.merge-basic-metrics = false</code>在JanusGraph的属性文件中进行设置时，指标标准名称“stores”将被替换为对应“ idStore”，“ edgeStore”，“ vertexIndexStore”或“ edgeIndexStore”，如下述：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;.idStore.&lt;opname&gt;</span><br><span class="line">&lt;prefix&gt;.edgeStore.&lt;opname&gt;</span><br><span class="line">&lt;prefix&gt;.vertexIndexStore.&lt;opname&gt;</span><br><span class="line">&lt;prefix&gt;.edgeIndexStore.&lt;opname&gt; </span><br></pre></td></tr></table></figure><h3 id="2-2-配置指标报告"><a href="#2-2-配置指标报告" class="headerlink" title="2.2 配置指标报告"></a>2.2 配置指标报告</h3><p>要访问这些收集好的指标值，必须配置一个或多个<code>Metrics的Reporting</code>； 也就是说配置一个或多个指标的输出存储的位置；</p><p>JanusGraph 支持下述的这7种 Metrics reporters:</p><ul><li>Console</li><li>CSV</li><li>Ganglia</li><li>Graphite</li><li>JMX</li><li>Slf4j</li><li>User-provided/Custom</li></ul><p>每种reporter类型独立于其他reporter，并且可以共存。 </p><p>例如，可以将Ganglia、JMX和Slf4j Metrics报告器配置为同时运行，只需在janusgraph.properties中设置它们各自的配置键即可（并启用<code>metrics.enabled = true</code>）</p><h4 id="Console-Reporter"><a href="#Console-Reporter" class="headerlink" title="Console Reporter"></a>Console Reporter</h4><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.console.interval</td><td align="left">是</td><td align="left">将指标转储到控制台之间需要等待的毫秒数</td><td align="left">空值</td></tr></tbody></table><p>示例janusgraph.properties片段，每分钟将指标输出到控制台一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.console.interval &#x3D; 60000</span><br></pre></td></tr></table></figure><h4 id="CSV文件-Reporter"><a href="#CSV文件-Reporter" class="headerlink" title="CSV文件 Reporter"></a>CSV文件 Reporter</h4><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.csv.interval</td><td align="left">是</td><td align="left">写入CSV行之间需要等待的毫秒数</td><td align="left">空值</td></tr><tr><td align="left">metrics.csv.directory</td><td align="left">是</td><td align="left">写入CSV文件的目录（如果不存在则将创建）</td><td align="left">空值</td></tr></tbody></table><p>示例janusgraph.properties片段，每分钟将CSV文件写入一次到目录<code>./foo/bar/</code>（相对于进程的工作目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.csv.interval &#x3D; 60000</span><br><span class="line">metrics.csv.directory &#x3D; foo&#x2F;bar</span><br></pre></td></tr></table></figure><h4 id="Ganglia-Reporter"><a href="#Ganglia-Reporter" class="headerlink" title="Ganglia Reporter"></a>Ganglia Reporter</h4><p><strong>注意</strong></p><p>由于Ganglia的LGPL许可与JanusGraph的Apache 2.0许可冲突，因此配置Ganglia需要一个附加的库，该库未与JanusGraph一起打包。要使用Ganglia监视运行，请<code>org.acplt:oncrpc</code>从<a href="https://repo1.maven.org/maven2/org/acplt/oncrpc/1.0.7/">此处</a>下载 jar 并将其复制到JanusGraph<code>/lib</code>目录，然后再启动服务器。    </p><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.ganglia.hostname</td><td align="left">是</td><td align="left">将指标发送到的单播主机或多播组</td><td align="left">空值</td></tr><tr><td align="left">metrics.ganglia.interval</td><td align="left">是</td><td align="left">发送数据报之间等待的毫秒数</td><td align="left">空值</td></tr><tr><td align="left">metrics.ganglia.port</td><td align="left">否</td><td align="left">我们向其发送指标数据报的UDP端口</td><td align="left">8649</td></tr><tr><td align="left">metrics.ganglia.addressing-mode</td><td align="left">否</td><td align="left">必须为“unicast”或“multicast”</td><td align="left">unicast</td></tr><tr><td align="left">metrics.ganglia.ttl</td><td align="left">否</td><td align="left">组播数据报TTL; 忽略单播</td><td align="left">1个</td></tr><tr><td align="left">metrics.ganglia.protocol-31</td><td align="left">否</td><td align="left">布尔值 使用Ganglia协议3.1为true，使用3.0为false</td><td align="left">true</td></tr><tr><td align="left">metrics.ganglia.uuid</td><td align="left">否</td><td align="left">要报告而不是IP：主机名的主机UUID</td><td align="left">空值</td></tr><tr><td align="left">metrics.ganglia.spoof</td><td align="left">否</td><td align="left">覆盖IP：向Ganglia报告的主机名</td><td align="left">空值</td></tr></tbody></table><p>示例janusgraph.properties片段，每30秒发送一次单播UDP数据报到默认端口上的localhost：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; IP or hostname string</span><br><span class="line">metrics.ganglia.hostname &#x3D; 127.0.0.1</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.ganglia.interval &#x3D; 30000</span><br></pre></td></tr></table></figure><p>示例janusgraph.properties片段，将单播UDP数据报发送到非默认目标端口，并且还配置报告给Ganglia的IP和主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; IP or hostname string</span><br><span class="line">metrics.ganglia.hostname &#x3D; 1.2.3.4</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.ganglia.interval &#x3D; 60000</span><br><span class="line"># Optional</span><br><span class="line">metrics.ganglia.port &#x3D; 6789</span><br><span class="line">metrics.ganglia.spoof &#x3D; 10.0.0.1:zombo.com</span><br></pre></td></tr></table></figure><h4 id="Graphite-Reporter"><a href="#Graphite-Reporter" class="headerlink" title="Graphite Reporter"></a>Graphite Reporter</h4><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.graphite.hostname</td><td align="left">是</td><td align="left">将Graphite纯文本协议数据发送到的IP地址或主机名</td><td align="left">空值</td></tr><tr><td align="left">metrics.graphite.interval</td><td align="left">是</td><td align="left">将数据推送到Graphite之间需要等待的毫秒数</td><td align="left">空值</td></tr><tr><td align="left">metrics.graphite.port</td><td align="left">否</td><td align="left">Graphite纯文本协议报告发送到的端口</td><td align="left">2003</td></tr><tr><td align="left">metrics.graphite.prefix</td><td align="left">否</td><td align="left">发送到Graphite的所有度量标准名称前都带有任意字符串</td><td align="left">空值</td></tr></tbody></table><p>每分钟将指标发送到192.168.0.1上的Graphite服务器的示例janusgraph.properties片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; IP or hostname string</span><br><span class="line">metrics.graphite.hostname &#x3D; 192.168.0.1</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.graphite.interval &#x3D; 60000</span><br></pre></td></tr></table></figure><h4 id="JMX-Reporter"><a href="#JMX-Reporter" class="headerlink" title="JMX Reporter"></a>JMX Reporter</h4><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.jmx.enabled</td><td align="left">是</td><td align="left">布尔型</td><td align="left">false</td></tr><tr><td align="left">metrics.jmx.domain</td><td align="left">否</td><td align="left">指标将显示在此JMX域中</td><td align="left">Metrics’s own default</td></tr><tr><td align="left">metrics.jmx.agentid</td><td align="left">否</td><td align="left">指标将使用此JMX代理ID报告</td><td align="left">Metrics’s own default</td></tr></tbody></table><p>janusgraph.properties示例片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required</span><br><span class="line">metrics.jmx.enabled &#x3D; true</span><br><span class="line"># Optional; if omitted, then Metrics uses its default values</span><br><span class="line">metrics.jmx.domain &#x3D; foo</span><br><span class="line">metrics.jmx.agentid &#x3D; baz</span><br></pre></td></tr></table></figure><h4 id="Slf4j-Reporter"><a href="#Slf4j-Reporter" class="headerlink" title="Slf4j Reporter"></a>Slf4j Reporter</h4><table><thead><tr><th align="left">配置键</th><th align="left">是否必须？</th><th align="left">值</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left">metrics.slf4j.interval</td><td align="left">是</td><td align="left">将指标转储到记录器之间需要等待的毫秒数</td><td align="left">空值</td></tr><tr><td align="left">metrics.slf4j.logger</td><td align="left">否</td><td align="left">要使用的Slf4j记录器名称</td><td align="left">“metrics”</td></tr></tbody></table><p>示例janusgraph.properties片段每分钟将一次指标记录到名为的记录器中<code>foo</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metrics.enabled &#x3D; true</span><br><span class="line"># Required; specify logging interval in milliseconds</span><br><span class="line">metrics.slf4j.interval &#x3D; 60000</span><br><span class="line"># Optional; uses Metrics default when unset</span><br><span class="line">metrics.slf4j.logger &#x3D; foo</span><br></pre></td></tr></table></figure><h4 id="用户自定义-Reporter"><a href="#用户自定义-Reporter" class="headerlink" title="用户自定义 Reporter"></a>用户自定义 Reporter</h4><p>如果上面列出的Metrics报告程序配置选项不足以支持我们当前的业务，JanusGraph提供了一个实用方法来访问单个MetricRegistry实例，该实例保存了它的所有度量；</p><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.codahale.metrics.MetricRegistry janusgraphRegistry &#x3D; </span><br><span class="line">    org.janusgraph.util.stats.MetricManager.INSTANCE.getRegistry();</span><br></pre></td></tr></table></figure><p>以这种方式访问janusgraphRegistry的代码可以将非标准报告类型或具有外来配置的标准报告类型附加到janusgraphRegistry。</p><p>如果周围的应用程序已经有了度量报告器配置的框架，或者如果应用程序需要JanusGraph支持的报告器类型的多个不同配置的实例，这种方法也很有用。</p><p>例如，可以使用这种方法来设置多个Graphite Reporter，而JanusGraph的属性配置仅限于一个Graphite Reporter。</p><h2 id="三：实际应用"><a href="#三：实际应用" class="headerlink" title="三：实际应用"></a>三：实际应用</h2><p><strong>配置如下：</strong></p><ol><li> 开启指标收集</li><li> 使用<code>Console Reporter</code>，配置指标打印在Console中，时间间隔为1分钟</li><li> 关闭指标收集<code>merge</code>操作</li><li> 配置指标收集前缀由默认的<code>org.janusgraph</code>修改为<code>myprefix</code></li></ol><p><strong>完整具体文件配置如下：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 其他配置</span><br><span class="line">gremlin.graph=org.janusgraph.core.JanusGraphFactory</span><br><span class="line"></span><br><span class="line">storage.backend=hbase</span><br><span class="line">storage.hostname=127.0.0.1</span><br><span class="line">storage.port=2184</span><br><span class="line">storage.hbase.table=testGraph</span><br><span class="line"></span><br><span class="line">cache.db-cache=true</span><br><span class="line">cache.db-cache-clean-wait=20</span><br><span class="line">cache.db-cache-time=180000</span><br><span class="line">cache.db-cache-size=0.5</span><br><span class="line"></span><br><span class="line">index.search.backend=elasticsearch</span><br><span class="line">index.search.hostname=127.0.0.1</span><br><span class="line">index.search.index-name=search</span><br><span class="line">index.search.port=9200</span><br><span class="line">index.search.elasticsearch.http.auth.type=basic</span><br><span class="line">index.search.elasticsearch.http.auth.basic.username=test</span><br><span class="line">index.search.elasticsearch.http.auth.basic.password=test</span><br><span class="line">query.batch=true</span><br><span class="line">query.batch-property-prefetch=true</span><br><span class="line"></span><br><span class="line"># janusgraph监控相关配置</span><br><span class="line">metrics.enabled = true</span><br><span class="line">metrics.prefix = myprefix</span><br><span class="line">metrics.console.interval = 60000</span><br><span class="line">metrics.merge-basic-metrics = false</span><br></pre></td></tr></table></figure><p>我们在服务器使用<code>gremlin.sh</code>脚本启动gremlin console，并创建图实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./gremlin.sh</span><br><span class="line"></span><br><span class="line">graph=JanusGraphFactory.open(&#x27;/opt/soft/janusgraph-0.5.1-test/conf/janusgraph-hbase-es.properties&#x27;)</span><br></pre></td></tr></table></figure><p>我们就会发现，每隔一分钟就会在控制台打印出对应指标信息，因为指标信息很多，为了便于文章阅读，下述只展示出主要部分：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">12/23/20 10:37:28 AM ===========================================================</span><br><span class="line"></span><br><span class="line">-- Counters --------------------------------------------------------------------</span><br><span class="line">global.storeManager.openDatabase.calls</span><br><span class="line">             count = 20</span><br><span class="line">global.storeManager.startTransaction.calls</span><br><span class="line">             count = 461</span><br><span class="line">myprefix.caches.misses</span><br><span class="line">             count = 5</span><br><span class="line">// 此处省略部分统计</span><br><span class="line">myprefix.tx.begin</span><br><span class="line">             count = 12</span><br><span class="line">myprefix.tx.commit</span><br><span class="line">             count = 3</span><br><span class="line">myprefix.tx.rollback</span><br><span class="line">             count = 9</span><br><span class="line">org.janusgraph.caches.misses</span><br><span class="line">             count = 3</span><br><span class="line">org.janusgraph.caches.retrievals</span><br><span class="line">             count = 3</span><br><span class="line">// 此处省略部分统计</span><br><span class="line">org.janusgraph.sys.stores.getSlice.calls</span><br><span class="line">             count = 286</span><br><span class="line">org.janusgraph.sys.stores.getSlice.entries-returned</span><br><span class="line">             count = 231</span><br><span class="line">org.janusgraph.sys.stores.mutate.calls</span><br><span class="line">             count = 7</span><br><span class="line">org.janusgraph.tx.begin</span><br><span class="line">             count = 1</span><br><span class="line"></span><br><span class="line">-- Histograms ------------------------------------------------------------------</span><br><span class="line">myprefix.stores.getSlice.entries-histogram</span><br><span class="line">             count = 7</span><br><span class="line">               min = 0</span><br><span class="line">               max = 8</span><br><span class="line">              mean = 1.57</span><br><span class="line">            stddev = 2.88</span><br><span class="line">            median = 1.00</span><br><span class="line">              75% &lt;= 1.00</span><br><span class="line">              95% &lt;= 8.00</span><br><span class="line">              98% &lt;= 8.00</span><br><span class="line">              99% &lt;= 8.00</span><br><span class="line">            99.9% &lt;= 8.00</span><br><span class="line">org.janusgraph.stores.getSlice.entries-histogram // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.schema.stores.getSlice.entries-histogram // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.stores.getSlice.entries-histogram // 具体指标统计省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Timers ----------------------------------------------------------------------</span><br><span class="line">myprefix.query.graph.execute.time</span><br><span class="line">             count = 2</span><br><span class="line">         mean rate = 0.01 calls/second</span><br><span class="line">     1-minute rate = 0.01 calls/second</span><br><span class="line">     5-minute rate = 0.07 calls/second</span><br><span class="line">    15-minute rate = 0.14 calls/second</span><br><span class="line">               min = 1.19 milliseconds</span><br><span class="line">               max = 2.25 milliseconds</span><br><span class="line">              mean = 1.72 milliseconds</span><br><span class="line">            stddev = 0.75 milliseconds</span><br><span class="line">            median = 1.72 milliseconds</span><br><span class="line">              75% &lt;= 2.25 milliseconds</span><br><span class="line">              95% &lt;= 2.25 milliseconds</span><br><span class="line">              98% &lt;= 2.25 milliseconds</span><br><span class="line">              99% &lt;= 2.25 milliseconds</span><br><span class="line">            99.9% &lt;= 2.25 milliseconds</span><br><span class="line">myprefix.query.graph.getNew.time // 具体指标统计省略</span><br><span class="line">myprefix.query.graph.hasDeletions.time // 具体指标统计省略</span><br><span class="line">myprefix.query.vertex.execute.time // 具体指标统计省略</span><br><span class="line">myprefix.query.vertex.getNew.time // 具体指标统计省略</span><br><span class="line">myprefix.query.vertex.hasDeletions.time // 具体指标统计省略</span><br><span class="line">myprefix.storeManager.mutate.time // 具体指标统计省略</span><br><span class="line">myprefix.stores.getSlice.time // 具体指标统计省略</span><br><span class="line">myprefix.stores.mutate.time // 具体指标统计省略</span><br><span class="line"></span><br><span class="line">org.janusgraph.query.graph.execute.time</span><br><span class="line">             count = 2</span><br><span class="line">         mean rate = 0.00 calls/second</span><br><span class="line">     1-minute rate = 0.00 calls/second</span><br><span class="line">     5-minute rate = 0.02 calls/second</span><br><span class="line">    15-minute rate = 0.09 calls/second</span><br><span class="line">               min = 2.52 milliseconds</span><br><span class="line">               max = 221.12 milliseconds</span><br><span class="line">              mean = 111.82 milliseconds</span><br><span class="line">            stddev = 154.57 milliseconds</span><br><span class="line">            median = 111.82 milliseconds</span><br><span class="line">              75% &lt;= 221.12 milliseconds</span><br><span class="line">              95% &lt;= 221.12 milliseconds</span><br><span class="line">              98% &lt;= 221.12 milliseconds</span><br><span class="line">              99% &lt;= 221.12 milliseconds</span><br><span class="line">            99.9% &lt;= 221.12 milliseconds</span><br><span class="line">org.janusgraph.query.graph.getNew.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.query.graph.hasDeletions.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.stores.getKeys.iterator.hasNext.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.stores.getKeys.iterator.next.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.stores.getKeys.time // 具体指标统计省略 // 具体指标统计省略</span><br><span class="line">org.janusgraph.stores.getSlice.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.schema.query.graph.execute.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.schema.query.graph.getNew.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.schema.query.graph.hasDeletions.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.schema.stores.getSlice.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.storeManager.mutate.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.stores.getSlice.time // 具体指标统计省略</span><br><span class="line">org.janusgraph.sys.stores.mutate.time // 具体指标统计省略</span><br></pre></td></tr></table></figure><p><strong>观察上述指标统计数据，我们可以发现，主要分为4大部分：</strong></p><ol><li> 当前统计指标时间，年月日，时间精确到秒</li><li> 统计所有不同操作的数量<code>Counters</code></li><li> 统计数据直方图的表示<code>Histograms</code></li><li> 统计所有操作的执行时间<code>Timers</code></li></ol><p><strong>第一部分：当前统计指标时间，年月日，时间精确到秒</strong></p><p>可以作为janusgraph指标监控的横向维度和时间维度</p><p><strong>第二部分：统计所有不同操作的数量<code>Counters</code></strong></p><p>这一部分主要用于收集所有操作的总数量，包含事务相关统计、缓存命中相关统计、数据的CURD统计、后端存储不同操作调用统计等<code>48</code>个维度！</p><p>具体可以自行尝试；</p><p><strong>第三部分：统计数据直方图的表示<code>Histograms</code></strong></p><p><code>首先，什么是直方图？</code>   直方图，形状类似柱状图却有着与柱状图完全不同的含义。直方图牵涉统计学的概念，首先要对数据进行分组，然后统计每个分组内数据元的数量。 在平面直角坐标系中，横轴标出每个组的端点，纵轴表示频数，每个矩形的高代表对应的频数，称这样的统计图为频数分布直方图</p><p>此部分主要涉及对后端存储的统计；</p><p><strong>第四部分：统计所有操作的执行时间<code>Timers</code></strong></p><p>这一部分主要收集统计数据CURD操作和数据插入等操作的时间统计包含<code>23</code>种维度！</p><p>时间维度包含<code>平均值</code>、<code>最大值</code>、<code>最小值</code>、<code>时间分布</code>等<code>14</code>个时间维度；</p><h2 id="四：监控架构图"><a href="#四：监控架构图" class="headerlink" title="四：监控架构图"></a>四：监控架构图</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/66e7f776e82150e43a200d5cdcf04c09.png" alt="JanusGraph监控架构图"></p><p><strong>整体分为：</strong> 收集指标 –&gt; 解析指标数据 –&gt; 格式化存储 –&gt; 监控组件|报警组件</p><blockquote><p>有任何问题，欢迎交流沟通</p></blockquote><p>参考：JanusGraph官网</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详细介绍JanusGraph的监控机制；&lt;br&gt;大家好，我是&lt;code&gt;洋仔&lt;/code&gt;，JanusGraph图解系列文章，&lt;code&gt;实时更新&lt;/code&gt;~  &lt;/p&gt;</summary>
    
    
    
    <category term="图数据库" scheme="http://coderstudy.vip/categories/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="JanusGraph" scheme="http://coderstudy.vip/tags/JanusGraph/"/>
    
  </entry>
  
  <entry>
    <title>什么是静态代理和动态代理？</title>
    <link href="http://coderstudy.vip/article/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F.html"/>
    <id>http://coderstudy.vip/article/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F.html</id>
    <published>2021-03-03T07:25:19.204Z</published>
    <updated>2021-03-03T07:25:19.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解</p></blockquote><p><strong>首先，要明确为什么要存在<code>代理</code>呢？</strong></p><p>存在一个常见的需求：<code>怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？ </code></p><span id="more"></span><p>先不考虑什么代理不代理的，我们设计一个简单的实现方案：</p><p>新创建一个类B，类B组合类A，在类B中创建一个方法b，方法b中调用类A中的方法a，在调用前和调用后都可以添加一些自定义的附加与增强代码。 当有需求需要调用类A的方法a并且想要添加一个附加功能时，就去调用类B的方法b即可实现上述需求；</p><p>下面为了便于理解，附上伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是方法a!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">    <span class="comment">// 组合ClassA</span></span><br><span class="line">    ClassA  A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我执行啦~!&quot;</span>);</span><br><span class="line">        A.methoda();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我完成啦~!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，让我们来调用一下ClassB的methodb方法，则会产生以下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是方法a的附加功能代码，我执行啦~!</span><br><span class="line">我是方法a!</span><br><span class="line">我是方法a的附加功能代码，我完成啦~!</span><br></pre></td></tr></table></figure><p>可以发现，方法a执行了，并且在没有修改类A代码的前提下，为方法a附加了其他的功能；<br>不难吧，其实上述的代码就是一个最简单的<code>代理模式</code>了</p><p><strong>代理存在的意义</strong>：使用代理模式可以在不修改别代理对象代码的基础上，通过扩展代理类，进行一些功能的附加与增强</p><h1 id="代理种类"><a href="#代理种类" class="headerlink" title="代理种类"></a>代理种类</h1><p>代理分为<code>静态代理</code>和<code>动态代理</code>，其涉及的设计模式就是<code>代理模式</code>本尊了，代理模式一般包含几种元素，如下图：<br><img src="https://img-blog.csdnimg.cn/20200521125516667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NTRE5fX19MWVk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>主题接口(subject)：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</li><li>真实主题(RealSubject)：真正实现业务逻辑的类；</li><li>代理类(Proxy)：用来代理和封装真实主题；</li><li>客户端(Client)：使用代理类和主题接口完成一些工作。 </li></ol><p>为了更好的理解，我们将上述实现的最简易版的代理完善一下，添加接口，代理类也实现相应的被代理类的接口，实现同一个方法，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类的接口（上图中subject）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImpA</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义类A（上图中RealSubject）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">ImpA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是方法a!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类B（上图中Proxy）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span>  <span class="title">ImpA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合ClassA</span></span><br><span class="line">    ImpA  A;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写被代理类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我执行啦~!&quot;</span>);</span><br><span class="line">        A.methoda();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是方法a的附加功能代码，我完成啦~!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端类（上图中Client）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建被代理对象实例</span></span><br><span class="line">    ImpA A = <span class="keyword">new</span> ClassA();</span><br><span class="line">    <span class="comment">// 构造器注入被代理对象实例</span></span><br><span class="line">    ImpA B = <span class="keyword">new</span> ClassB(A);</span><br><span class="line">    <span class="comment">// 调用代理方法</span></span><br><span class="line">    B.methoda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><code>所谓静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</code><br>上面的代码就是实现了一个静态代理； 其实静态代理就已经能够满足上述需求了，为什么还需要动态代理呢？ 这里就涉及到静态代理的两个缺点了</p><ol><li><code>代理对象</code>的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，在程序规模稍大时静态代理代理类就会过多会造成代码混乱</li><li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。<br>基于上述两个问题，动态代理诞生了~</li></ol><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><code>动态代理是在程序运行时，通过反射获取被代理类的字节码内容用来创建代理类</code></p><p><strong>具体什么是动态代理呢？</strong><br>名词：<code>动态</code>，动态在程序中就是表达在程序运行时就根据配置自动的生成代理类并且代理类和被代理类是在运行时才确定相互之间的关系；</p><p>在JDK中包含两种动态代理的实现机制：<code>JDK Proxy</code> 和 <code>CGLib</code>；</p><p>下面我们以<code>JDK Proxy</code>为例，讲解一下动态代理和根据源码分析并简单说一下应用场景</p><h3 id="JDK-Proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h3><p><code>JDK Proxy动态代理</code>，api在包<code>java.lang.reflect</code>下，大家可能发现了，为什么在反射的包下呢？这个问题我们下面的源码分析会解决；</p><p>其核心api包含两个重要的核心接口和类：一个是 <code>InvocationHandler(Interface)</code>、另一个则是 <code>Proxy(Class)</code>，简单说就这两个简单的很，这两个是我们实现动态代理所必需的用到的，下面简单介绍一下两个类：<br><strong><code>java.lang.reflect.Proxy（Class）</code></strong> ：Proxy是 Java 动态代理机制的主类，提供一组静态方法来为一组接口动态地生成代理类及其对象。包含以下四个静态方法：</p><ul><li><code>static InvocationHandler getInvocationHandler(Object proxy)</code><br>该方法用于获取指定代理对象所关联的调用处理器</li><li><code>static Class getProxyClass(ClassLoader loader, Class[] interfaces)</code><br>该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</li><li><code>static boolean isProxyClass(Class cl)</code><br>该方法用于判断指定类对象是否是一个动态代理类</li><li><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces,InvocationHandler h)</code><br>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，包含下面的参数：<ul><li><code>loader</code> 指定代理类的ClassLoader加载器</li><li><code>interfaces</code> 指定代理类要实现的所有接口</li><li><code>h</code>: 表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</li></ul></li></ul><p>该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</p><p><strong><code>java.lang.reflect.InvocationHandler（interface）</code></strong> ： <code>InvocationHandler</code>是上述<code>newProxyInstance</code>方法的<code>InvocationHandler h</code>参数传入，负责连接代理类和委托类的中间类必须实现的接口<br>它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><p><strong>上述就是动态代理两个核心的方法，不太明白？先别急，我们先用上述实现一个动态代理，你先看一下</strong></p><p>还是以上述的案例从静态代理来改造为动态代理，实现动态代理主要就两步，假设还是存在上述的ImplA、ClassA</p><p><strong>1：创建一个<code>处理器</code>类实现InvocationHandler接口，重写invoke方法，伪代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">// 标识被代理类的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Object delegate;   </span><br><span class="line">    <span class="comment">// 构造器注入被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Object delegate)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理方法调用前的附加代码执行~ &quot;</span>);</span><br><span class="line">        <span class="comment">// 真实的被代理方法调用</span></span><br><span class="line">        method.invoke(delegate, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理方法调用后的附加代码执行~ &quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样一个<code>处理器</code>就搞定了，当我们在调用<code>被代理类</code>的方法时，就是去执行上述<code>重写的invoke方法</code>，下面创建一个ClassA的<code>代理类</code></p><p><strong>2：创建<code>代理类</code>，并调用被代理方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 创建被代理对象</span></span><br><span class="line">        ImplA A = <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 创建处理器类实现</span></span><br><span class="line">        InvocationHandler myHandler = <span class="keyword">new</span> MyHandler(A);</span><br><span class="line">        <span class="comment">// 重点！ 生成代理类， 其中proxyA就是A的代理类了</span></span><br><span class="line">        ImplA proxyA = (ImplA)Proxy.newProxyInstance(A.getClass().getClassLoader(), A.getClass().getInterfaces(), myHandler);</span><br><span class="line">        <span class="comment">// 调用代理类的代理的methoda方法， 在此处就会去调用上述myHandler的invoke方法区执行，至于为什么，先留着疑问，下面会说清楚~</span></span><br><span class="line">        proxyA.methoda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，至此一个动态代理就构建完成了，执行代码，会发现输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被代理方法调用前的附加代码执行~</span><br><span class="line">我是方法a！</span><br><span class="line">被代理方法调用后的附加代码执行~</span><br></pre></td></tr></table></figure><p>太简单了有木有，这里总结一下动态代理的优缺点：</p><p><strong>优点：</strong></p><ol><li><p>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。</p></li><li><p>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</p></li><li><p>接口增加一个方法，除了所有实现类需要实现这个方法外，动态代理类会直接自动生成对应的代理方法。</p></li></ol><p><strong>缺点：</strong><br>JDK proxy只能对有实现接口的类才能代理，也就是说没有接口实现的类，jdk proxy是无法代理的，为什么呢？下面会解答.</p><p><em>有什么解决方案吗？</em>  当然有，还有一种动态代理的方案：<code>CGLib</code>，它是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的，和jdk proxy基本思想是相似的，毕竟都是动态代理的实现方案嘛，在这篇文章就不做详解了，博主会在其他的博文单独介绍这个nb的框架</p><p><strong>上述带大家搞了一遍动态代理和静态代理的应用；在这过程中，你有没有想过，动态代理是怎么实现的呢？</strong> </p><p>下面我们就从源码的角度分析一下，解决大家的疑问。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在开始分析的时候，我希望大家带着几个<code>问题</code>去阅读，可以帮助大家更好的理解：</p><ul><li><code>问题1</code>：代理类为什么可以在运行的时候自动生成呢？如何生成的呢？</li><li><code>问题2</code>：为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</li><li><code>问题3</code>：为什么jdk proxy只支持代理有接口实现的类呢？</li></ul><p>ps ：<em>为了提升阅读体验，让大家有一个更清晰的认知，以下源码会将一些异常处理和日志打印代码删除，只保留主干代码，请知悉~</em></p><p>我们就从两个核心：<code>InvocationHandler</code>和<code>Proxy</code>来进行分析整个脉络，他们都在<code>java.lang.reflect</code>包下</p><h4 id="InvocationHandler源码"><a href="#InvocationHandler源码" class="headerlink" title="InvocationHandler源码"></a>InvocationHandler源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是InvocationHandler的源码，没什么其他的就是一个接口，里面有一个待实现方法invoke，处理类实现此接口重写invoke方法</p><h4 id="Proxy源码"><a href="#Proxy源码" class="headerlink" title="Proxy源码"></a>Proxy源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理类实例 变量</span></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">    <span class="comment">// 用于存储 已经通过动态代理获取过的代理类缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;  proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(),<span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line">    <span class="comment">// 私有无参构造，使得只能通过传入InvocationHandler参数来创建该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 保护 构造函数，入参InvocationHandler处理类</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span>  <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理类的实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 各种私有方法</span></span><br><span class="line">    <span class="keyword">private</span> ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>类的整体的架构就类似于上述，<code>InvocationHandler h</code>参数和<code>两个构造函数</code>、<code>四个上述已经介绍过的共有方法</code>，还有一系列的私有方法，getProxyClass、isProxyClass、getInvocationHandler功能就和上面介绍的一样，就不再详细介绍了</p><p><strong>我们下面来主要看一下<code>newProxyInstance</code>方法</strong><br>newProxyInstance方法，我在方法内添加上了对应的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 克隆对应的接口，用于代理类实现的接口数组</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.  源码中的介绍</span></span><br><span class="line"><span class="comment">     * 2. 查找或者生成指定的代理类， 下面会详细介绍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     * 3. 上面代码已经生成了代理类 cl，cl其中包含一个参数为传入的InvocationHandler h的构造函数， 获取该构造函数并通过该构造函数创建一个类的实例对象并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 通过《反射》获取参数为InvocationHandler的构造函数</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="comment">// 5. 判断构造函数是否为私有的，如果为私有的则需要设置私有可访问权限</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6. 通过上述获取的构造函数创建对应的 实例对象，并返回！over~</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">       <span class="comment">// 各种异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我简单的标注了一下每行代码的作用，下面我们来详细分析一下；</p><p><strong>代理类的字节码生成逻辑</strong></p><p>我们知道，在加载jvm前，java文件都已经被编译成了<code>class字节码</code>文件， 然后jvm通过<code>类加载器</code>将字节码文件加载到jvm中；</p><p>我们的代理类也是这样，不同的是动态代理的类是在程序运行时产生的，我们要做的就是如何在程序运行的时候，通过<code>被代理类</code>的字节码生成<code>代理类</code>的字节码！</p><p>我们接下来详细分析<code>newProxyInstance</code>方法：</p><p>在newProxyInstance中调用了<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code>语句生成了<code>代理类的字节码</code>，此处调用了getProxyClass0方法，传入了指定的类加载器和对应要实现的接口</p><p>那么， 我们看看<code>getProxyClass0</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxyClassCache是WeakCache弱引用缓存类，如果之前就生成过对应的代理类就从缓存中取，如果没生成过就重新生成</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxyClassCache</code>是Proxy类中的静态变量，是WeakCache类，里面封装了两个类KeyFactory、ProxyClassFactory，都是BiFunction函数式接口(如果不清楚函数式接口，请自行google)；</p><p>将其拿过来看一下<code>proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(),new ProxyClassFactory());</code>    其中调用了proxyClassCache.get(loader, interfaces)方法的实现</p><p>未避免代码过长，只粘贴了核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 这部分主要是获取对应的 函数式接口，如果不明白函数式接口，google一下吧~</span></span><br><span class="line">     Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">     Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">     Factory factory = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">// 此处为什么是while循环呢， 主要是supplier不为空的话，则执行下面的语句赋值后，再循环执行下一次则supplier不为空</span></span><br><span class="line">         <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果存在对应的函数式接口，  调用函数式接口对应的代码</span></span><br><span class="line">             <span class="comment">// 重点！！！调用函数式接口！！</span></span><br><span class="line">             V value = supplier.get();</span><br><span class="line">             <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> value;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 创建一个 专门创建代理类字节码的工厂类，实现类是ProxyClassFactory</span></span><br><span class="line">             factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">             supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">             <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 将supplier赋值factory</span></span><br><span class="line">                 supplier = factory;</span><br><span class="line">             &#125;&#125;&#125;&#125; &#125;</span><br></pre></td></tr></table></figure><p>总结一下上述方法的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[缓存中获取代理类字节码] --&gt; C&#123;是否存在&#125;</span><br><span class="line">C --&gt;|是| D[代理中获取并返回]</span><br><span class="line">C --&gt;|否| E[调用ProxyClassFactory的apply方法生成代理类字节码]</span><br></pre></td></tr></table></figure><p>接着<code>ProxyClassFactory.apply</code>方法看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">     Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">     <span class="comment">// 获取接口对应的接口class对象</span></span><br><span class="line">     <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123; &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">     <span class="comment">// 判断是否包含公有的接口对象，判断是否可以通过jdk proxy的方式进行生成代理类</span></span><br><span class="line">     <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">         <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">             accessFlags = Modifier.FINAL;</span><br><span class="line">             String name = intf.getName();</span><br><span class="line">             <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">             String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">             <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 proxyPkg = pkg;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果没有公有接口类，需要使用CGLib来实现。。。</span></span><br><span class="line">     <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">         proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 组装代理类的类名称</span></span><br><span class="line">     <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">     String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">     <span class="comment">// 重点！！ 此处生成代理类的字节码数组</span></span><br><span class="line">     <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClassproxyName, interfaces, accessFlags);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过类加载器将字节码数组加载到JVm的方法区中生成Class对象！</span></span><br><span class="line">         <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                             proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述的<code> byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</code> 为生成代理类字节码数组的方法，调用的方法中调用了<code>generateClassFile</code>方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">// 首先，默认代理的三个方法：hashCode\equals\toString</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        <span class="comment">// 获取所有的要被代理类实现的接口</span></span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">// 遍历上述获取的接口</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            <span class="comment">// 赋值： 将接口的Class对象赋值！</span></span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="comment">// 通过“反射”获取所有方法</span></span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="comment">// 将方法添加到 要被代理的方法中</span></span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取要代理方法后，开始组装字节码</span></span><br><span class="line">        var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">        var14.writeShort(<span class="number">0</span>);</span><br><span class="line">        var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">        var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">        <span class="comment">// 注意！！！  .... 此处省略了绝大部分 字节码的组装过程，只给出了几行代码展示一下字节码的组装</span></span><br><span class="line">        <span class="comment">// 最终返回组装好的字节码文件</span></span><br><span class="line">        <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>generateClassFile</code>中，你会发现里面全部是重组字节码的代码，  主要是获取<code>被代理类</code>字节码和<code>操作类InvocationHandler</code>字节码组装出<code>代理类</code>的字节码，在重组的过程因为是在<code>运行时</code>进行了代理类的创建，无法像往常一样new一个被代理类的实例获取他的方法，让代理类进行调用。</p><p>获取字节码后，接下来就要将代理类的字节码加载进JVM中了，这里调用的是一个<code>return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length)</code>  其中的<code>defineClass0</code>是一个本地native 方法，传入了<code>代理类名称、类加载器、代理类的字节码文件、文件长度参数</code>，从而将字节码加载进JVM中！  代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(ClassLoader loader, String name,</span><br><span class="line">                                                <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure><p>将代理类的字节码加载进JVM后，会在方法区内生成一个<code>Class对象</code>，标识这个代理类；</p><p><strong>代理类的实例生成逻辑</strong><br>上面，我们知道了通过字节码技术生成了代理类字节码，并通过类加载器将字节码文件加载到了JVM的方法区中生成了一个Class对象，我们如何在运行时获取这个Class对象的实例呢？ 只有获取了对象实例才可以使用不是~<br>还是回到<code>newProxyInstance</code>方法中，上面我们分析了<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs)</code>这部分逻辑，生成了Class对象<code>cl</code>，下面生辰该实例代码，过程很简单，相关逻辑我就直接在代码中注释了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数的参数类型，下面的一个语句使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =    &#123; InvocationHandler.class &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取上述获取的Class对象的带参构造函数，参数必须是上述定义的 InvocationHandler.class类型</span></span><br><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="comment">// 检查权限，如果是私有权限，设为可被访问</span></span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 通过构造函数传入对应 处理类h 参数，生成实例！</span></span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure><p>上述就是生成实例的代码，生成实例后<code>newProxyInstance</code>就返回该实例了，就可以使用了~</p><h4 id="反射：在运行时获取被代理类的字节码"><a href="#反射：在运行时获取被代理类的字节码" class="headerlink" title="反射：在运行时获取被代理类的字节码"></a>反射：在运行时获取被代理类的字节码</h4><p><strong>那如何才能在运行时获取到被代理类的构造函数、方法、属性等字节码呢？</strong>   此时“<code>反射！</code>”登场了！我们通过反射可以在运行时获取到类的所有信息，所有哦。<br><strong>定义：</strong> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>java语言的反射机制</code>。</p><p>比如，在上述所说的组装代理类字节码时，在获取被代理类的所有方法时，就调用了<code>Method[] var5 = var4.getMethods();</code>  反射中的<code>getMethods</code>方法，通过反射获取到了被代理类的所有方法，这样我们就可以在运行时获取到任何类的所有的字节码信息了! 从而可以组装出我们想要的代理类字节码！</p><p>所以说，<code>反射</code>也为<code>动态代理</code>的实现提供了<code>理论支持</code>！！因为只有在运行时能获取到对应类的信息，才可以通过信息创造出对应的我们所需要的代理类；</p><h3 id="源码分析总结"><a href="#源码分析总结" class="headerlink" title="源码分析总结"></a>源码分析总结</h3><p>总而言之，<code>动态代理</code>的理论支持是可以通过<code>反射机制</code>在<code>运行时</code>获取到类的所有信息，如果运行时获取不到被代理类的信息，那还咋生成代理类。<br><strong>动态代理的大致流程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[反射获取被代理字节码] --&gt; B[反射获取InvocationHandler实现类字节码]</span><br><span class="line">B --&gt;C[依据被代理类字节码和InvocationHandler实现类字节码 通过操作字节码组装 代理类 字节码]</span><br><span class="line">C --&gt;D[通过给定的classLoad将 代理类字节码 加载到JVM中]</span><br><span class="line">D --&gt;E[调用native方法 加载到JVM的方法区 生成Class对象]</span><br><span class="line">E --&gt;F[反射获取代理类的Class对象的构造函数]</span><br><span class="line">F --&gt;G[通过反射获取的构造函数new一个代理类的实例A]</span><br><span class="line">G --&gt;H[使用代理类实例A]</span><br></pre></td></tr></table></figure><p>通过上述流程。我们就获得了一个代理类对象了，调用代理类对应的方法，就会执行我们规定的执行逻辑，实现对被代理类的运行时动态增强和扩展！</p><p>此时，我们再拿出刚开始我们用JDK proxy实现的动态代理代码中的生成代理类的代码：<code>ImplA proxyA = (ImplA)Proxy.newProxyInstance(A.getClass().getClassLoader(), A.getClass().getInterfaces(), myHandler)</code> 每个参数的作用，是不是就很清晰了</p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>上面<code>动态代理实现流程</code>，我们可以回答上述的第一个<code>代理类为什么可以在运行的时候自动生成呢？如何生成的呢？</code> 问题了</p><p>对于第二个<code>为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</code>和第三个<code>为什么jdk proxy只支持代理有接口实现的类呢？</code>问题，我们需要反编译一下我们通过字节码技术产生的<code>代理类</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ImplA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.test.ImplA&quot;</span>).getMethod(<span class="string">&quot;methoda&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">           <span class="comment">// ..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要被加强的方法methoda</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">methoda</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 省略部分代码。。。</span></span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码包含几个关键点： </p><ol><li>方法为<code>final</code>类型，不可再被继承</li><li>代理名称为 <code>$Proxy</code>  代理类前缀 + 递增数字</li><li>继承动态代理的核心类<code>Proxy</code>， 实现了我们指定的接口<code>ImplA</code></li><li>一个带参构造方法<code>$Proxy0(InvocationHandler var1)</code> 传入InvocationHandler内部调用了父类的<code>Proxy</code>的构造函数</li><li>methoda、toString、hashCode、equals全部调用的传入的InvocationHandler参数的 <code>invoke</code>方法！！！ </li></ol><p>现在回答第二个问题<code>为什么调用代理类的相应的代理方法就可以调用到InvocationHandler实现类的invoke方法呢？</code> </p><p>显而易见，代理类内部的代理方法全部显式调用的InvocationHandler实现类的invoke方法</p><p>第三个问题<code>为什么jdk proxy只支持代理有接口实现的类呢？</code></p><p>因为代理类在使用JDK proxy方式生成代理类时，默认继承Proxy类，又因为java语言是单继承不支持多继承，那怎样才能标识我要代理什么类型的类或是代理什么方法呢？ 接口呗，java支持接口的多继承，多少个都ok~</p><p>好了，上述将动态代理的使用方式 和 实现原理统一过了一遍，也回答了几个容易疑惑的问题，下面我们简单说下动态代理在现实的java框架大家庭中的一些典型应用</p><h3 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h3><p><strong><code>spring aop</code></strong> ：  这可以说是spring框架中最典型的应用了，通过动态代理在运行时产生代理类，完成对被代理类的增强和功能附加<br><strong><code>RPC框架的实现</code></strong> ： 远程过程调用，RPC使得调用远程方法和调用本地方法一样，这是怎么搞的呢？服务方对外放出服务的接口api，调用方拿到接口api，通过动态代理的方式生成一个代理类，代理类的处理类的invoke方法可以通过websocket连接远程服务器调用对应的远程接口；  这样我们再用代理对象进行调用对应方法时时，就像调用本地方法一样了<br><strong><code>mybatis框架中</code></strong> ： mapper.xml中编写sql语句，mapper.java接口写上对应的方法签名；我们直接调用mapper.java中的方法就可以执行对应的sql语句，有没有想过为什么？  框架使用动态代理创建一个mapper.java的代理对象，代理对象的处理类invoke中执行sql，就ok了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理分为<code>静态代理</code>和<code>动态代理</code>，动态代理的两种实现方式：<code>JDK Proxy</code>和<code>CGLib</code>，动态代理的<code>核心反射机制</code>，通过反射在运行时获取被代理类字节码和处理类字节码，动态代理代理类的生成通过<code>重组字节码</code>的方式。</p><p><strong>原创不易，有收获的话，<code>关注</code>、<code>点赞</code>、<code>评论</code>三连支持，我最大的动力~</strong></p><blockquote><p>关于博文有任何问题请不吝评论，感谢</p></blockquote><blockquote><p>参考：JDK源码，<a href="https://www.jianshu.com/p/861223789d53">https://www.jianshu.com/p/861223789d53</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学一个技术，要知道技术因何而产生，才能有学下去的目标和动力，才能更好的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;首先，要明确为什么要存在&lt;code&gt;代理&lt;/code&gt;呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在一个常见的需求：&lt;code&gt;怎样在不修改类A代码的情况下，在调用类A的方法时进行一些功能的附加与增强呢？ &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://coderstudy.vip/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="代理模式" scheme="http://coderstudy.vip/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="动静态代理" scheme="http://coderstudy.vip/tags/%E5%8A%A8%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Git提交错误，回退的三种方式！</title>
    <link href="http://coderstudy.vip/article/git-revert.html"/>
    <id>http://coderstudy.vip/article/git-revert.html</id>
    <published>2021-03-03T07:24:57.011Z</published>
    <updated>2021-03-03T07:24:57.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你知道Git版本控制系统中都有哪些“后悔药”吗？ </p><p>本文通过案例讲解<code>git reset 、 git revert 、 git checkout</code>在版本控制中的作用；</p></blockquote><span id="more"></span><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>小明同学作为新人加入到一个新的项目组中做开发，在项目的迭代开发中，小明勤勤恳恳的写代码，直到有一次…</p><blockquote><p>小明：完了，完蛋了</p></blockquote><blockquote><p>洋仔：怎么了，一惊一乍的</p></blockquote><blockquote><p>小明：<strong>我把错误代码用git commit后还push到线上代码库了</strong>！  这可怎么办！</p></blockquote><blockquote><p>洋仔：莫慌，git有“后悔药”！<br><img src="http://images.coderstudy.vip/%E8%A1%A8%E6%83%85%E5%8C%85-%E6%85%8C%E4%B8%8D%E6%85%8C.jpg" alt="201909191600087229"></p></blockquote><blockquote><p>洋仔：容我给你慢慢道来。 但是我们要先知道一些git的基础知识，你才能更好的理解git命令的作用</p></blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><strong>git将项目的存储分为4部分，每部分有自己作用，</strong></p><p><strong>见下图:</strong></p><p><img src="http://images.coderstudy.vip/git.png" alt="20190919160008729"></p><ul><li><code>Workspace</code>：工作区（当前用户操作修改的区域）</li><li><code>Index / Stage</code>：暂存区 （add后的区域）</li><li><code>Repository</code>：仓库区或本地仓库（commit后的区域）</li><li><code>Remote</code>：远程仓库（push后的区域）</li></ul><p><strong>整体过程可以简述为：</strong></p><ul><li>工作区–&gt;<code>add</code>–&gt;暂存区–&gt;<code>commit</code>–&gt;本地仓库区–&gt;<code>push</code>–&gt;远程仓库区</li><li>远程仓库区–&gt;<code>fetch</code>–&gt;使用refs\remotes下对应分支文件记录远程分支末端commit_id 和 本地仓库区 –&gt;<code>merge</code>–&gt;工作区</li><li>远程仓库区–&gt;<code>pull</code>–&gt;使用refs\remotes下对应分支文件记录远程分支末端commit_id and 本地仓库区 and 工作区</li></ul><p>具体的git的组成部分和概念命令，请移步下述两个博客：</p><p><a href="https://liyangyang.blog.csdn.net/article/details/100939749">Git技术干货！工作中Git的使用实践和常用命令合集！</a></p><p><a href="https://liyangyang.blog.csdn.net/article/details/101035399">Git - 使用git不知道内部实现机制怎么行</a></p><p><strong>假设项目存在这么一个提交记录：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit commit_id4 (HEAD -&gt; master)</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:45 2020 +0800</span><br><span class="line">    第三次修改README文件</span><br><span class="line"></span><br><span class="line">commit commit_id3 (HEAD -&gt; master)</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:45 2020 +0800</span><br><span class="line">    第二次修改README文件</span><br><span class="line"></span><br><span class="line">commit commit_id2</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:19 2020 +0800</span><br><span class="line">    第一次修改README文件</span><br><span class="line"></span><br><span class="line">commit commit_id1</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:26:59 2020 +080</span><br><span class="line">    初始化项目</span><br></pre></td></tr></table></figure><p>提交顺序为：<code>commit_id1</code> –&gt; <code>commit_id2</code> –&gt; <code>commit_id3</code> –&gt; <code>commit_id4</code></p><p><strong>注意：在git中每次的commit都有一个commit id唯一标识当前的提交！</strong></p><p>下面，我们先来解决小明的这个问题，使用<code>git reset</code>即可完美解决~</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><blockquote><p>洋仔：小明，你的这个就可以用<strong>git reset</strong> 这个命令来完美的搞定，下面我们看一下如何解决</p></blockquote><p>1、获取当前提交的commit id</p><p>命令：<code>git log</code>  </p><p>获取到当前项目分支下的所有commit记录；</p><p>假设上述小明提交错误的commit id为<code>commit id：commit_id4</code>这一次提交； </p><p>他的上一次提交就是<code>commit id：commit_id3</code> ，我们要将修改回滚到<code>commit_id3</code>的时刻！</p><blockquote><p>小明：我想要把我刚才  <strong>commit的修改保留下来</strong>，我修改的代码不能给我删除掉呀！</p><p>洋仔：没问题</p></blockquote><p>2、将某个commit id前的commit清除，并<strong>保留修改的代码</strong></p><p>命令：<code>git reset &lt;commit_id&gt;</code>  当前场景下就是：<code>git reset commit_id3</code></p><p>将指定commit_id后的所有提交，都去除，并保留修改的代码在本地的区域，也就是<code>Workspace</code>中</p><blockquote><p>小明：啊哈，这样的话我就可以把错误代码修改后再提交了； 但是我已经push到线上仓库的数据怎么办呢？</p><p>洋仔：别急，有办法~</p></blockquote><p>3、修改代码完成后，将修改好的代码add到暂存区，并提交到本地仓库中</p><p>命令：<code>git add &lt;file_name&gt; </code>  and  <code>git commit</code>   当前场景下：<code>git add .</code>  and  <code>git commit</code>  </p><p>将最新修改后的代码commit</p><p>则提交后的提交记录假设如下： 可以看到，我们错误提交的<code>commit_id4</code>提交记录消失，取而代之的是我们更新代码后提交的记录<code>commit_id5</code>； 这样就完成了本地的代码修改和更新</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit commit_id5 (HEAD -&gt; master)</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:45 2020 +0800</span><br><span class="line">    第三次修改README文件-更新错误后提交</span><br><span class="line"></span><br><span class="line">commit commit_id3 (HEAD -&gt; master)</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:45 2020 +0800</span><br><span class="line">    第二次修改README文件</span><br><span class="line"></span><br><span class="line">commit commit_id2</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:28:19 2020 +0800</span><br><span class="line">    第一次修改README文件</span><br><span class="line"></span><br><span class="line">commit commit_id1</span><br><span class="line">Author: test</span><br><span class="line">Date:   Thu Aug 20 16:26:59 2020 +080</span><br><span class="line">    初始化项目</span><br></pre></td></tr></table></figure><p>4、将本地修改同步到远程仓库</p><p>命令：<code>git push origin HEAD --force</code> </p><p>将本地修改强行同步到远程仓库，使得远程仓库和本地仓库保持一致！</p><p><strong>整体流程如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset commit_id3</span><br><span class="line">修改代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;第三次修改README文件-更新错误后提交&#x27;</span><br><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure><blockquote><p>洋仔：好了，小明，你的问题完美解决了</p><p>小明：哦吼，但是我还有一个问题： 如果我想要<strong>不保留回滚commit的修改</strong>，直接删除掉修改！该怎么处理呢？</p></blockquote><blockquote><p>洋仔：简单~  我们整体看一下 <strong>git reset</strong> 命令</p></blockquote><h2 id="后悔药-git-reset"><a href="#后悔药-git-reset" class="headerlink" title="后悔药-git reset"></a>后悔药-git reset</h2><p>在进行下面的讲解是，还是先假设有这么一个提交链：</p><p><code>commit_id1 --&gt; commit_id2 --&gt; commit_id3 --&gt; commit_id4</code></p><p><strong>git reset <param> commit_id2：</strong></p><p>reset是将HEAD重新定位到<code>commit_id2</code>上，对于commit_id3 和 commit_id4 和本地当前的修改，对于不同的参数param，会有不同的处理；</p><p><strong>reset命令有三种处理模式：</strong></p><ul><li>–soft：保留commit修改，将修改存储到index中；也就是说git add后的区域</li><li>–mixed：保留commit修改，将修改存储到本地工作区域中；也就是说git add前的区域</li><li>–hard：删除commit修改，慎用！</li></ul><h3 id="git-reset-–soft"><a href="#git-reset-–soft" class="headerlink" title="git reset –soft"></a>git reset –soft</h3><p>回滚commit_id前的所有提交，不删除修改：</p><p><code>git reset --soft commit_id</code></p><p>重设head，不动index，所以效果是commit_id之后的commit修改全部在index中<br>将id3 和 id4的修改放到index区（暂存区），也就是add后文件存放的区域，本地当前的修改保留</p><h3 id="git-reset-–mixed"><a href="#git-reset-–mixed" class="headerlink" title="git reset –mixed"></a>git reset –mixed</h3><p>回滚commit_id前的所有提交，不删除修改：<br><code>git reset commit_id</code>  等同于 <code>git reset --mixed commit_id</code>   </p><p>与 下述的 git reset –hard commit_id效果不同</p><p>重设head 和 index，不重设work tree，效果就是commit_id之前的修改，全部在work tree中，为还未add的状态<br>将id3 和 id4 的所有修改放到本地工作区中，本地当前的修改保留</p><h3 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h3><p>回滚commit_id前的所有提交，将修改全部删除：<br><code>git reset --hard commit_id</code></p><p>重设head、index、work tree，也就是说将当前项目的状态恢复到commit_id的状态，其余的全部删除（包含commit_id后的提交和本地还未提交的修改）<br>慎用！！</p><h2 id="后悔药-git-revert"><a href="#后悔药-git-revert" class="headerlink" title="后悔药-git revert"></a>后悔药-git revert</h2><blockquote><p>小明：原来git reset这么强大呀！  但是我这还有个问题：</p></blockquote><p><strong>如果想要只操作修改中间的一个commit，不对其他的commit产生影响； 也就是类似于我们只修改commit_id2，而对commit_id3 和 commit_id4无影响，该怎么处理呢？</strong></p><blockquote><p>洋仔：（这么多问题，幸亏我懂，要不这次就丢大了。。）  简单！ git revert 命令！</p></blockquote><img src="http://images.coderstudy.vip/表情包-装b.jpg" alt="装b" style="zoom: 25%;" /><p><strong>适用场景：</strong> 在项目开发中，突然发现在前几次的提交中，有一次提交中包含一个bug； 当然我们可以进行一个新的修改，然后再提交一次；  但是，不优雅哈哈；  我们可以直接<strong>重做</strong>有bug的commit~ </p><p><strong>为什么不直接去再添加一个commit呢？</strong> git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。</p><p>比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西；</p><p><strong>在revert命令中常用的就两个：</strong></p><ul><li>git revert -e <commit_id>：重做指定commit的提交信息</li><li>git revert -n <commit_id>：重做执行commit的代码修改</li></ul><h3 id="git-revert-e"><a href="#git-revert-e" class="headerlink" title="git revert -e"></a>git revert -e</h3><p>重做commit_id的提交信息，生成为一个新的new_commit_id<br><code>git revert -e commit_id</code></p><h3 id="git-revert-n"><a href="#git-revert-n" class="headerlink" title="git revert -n"></a>git revert -n</h3><p>重做commit_id的提交<br><code>git revert -n commit_id</code><br>将commit_id中修改，放到index区，我们可以对他重新做修改并重新提交</p><h3 id="revert-vs-reset"><a href="#revert-vs-reset" class="headerlink" title="revert vs reset"></a>revert vs reset</h3><ul><li>git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留不动；</li><li>git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除或放回工作区等待下一次提交；</li></ul><blockquote><p>小明：还有这种操作，可以直接单独操作提交过程中的某一个commit！ 太棒了！</p></blockquote><h2 id="后悔药-git-checkout"><a href="#后悔药-git-checkout" class="headerlink" title="后悔药-git checkout"></a>后悔药-git checkout</h2><blockquote><p>小明：还有最后一个问题：</p><p>如果我在一次开发中，<strong>发现某个文件修改错误了，想要将文件恢复到刚pull代码时的状态</strong>怎么办呢？</p><p>洋仔：简单！ 看git checkout解决这个问题！</p></blockquote><p>我们知道使用<code>git checkout</code>可以</p><ul><li><p><code>git checkout &lt;branch_name&gt;</code>切换分支</p></li><li><p><code>git checkout -b &lt;branch_bame&gt;</code>创建分支等操作</p></li></ul><p>它还有<strong>回滚指定文件的修改</strong>的功能</p><p>命令：<code>git checkout -- &lt;file_name&gt;</code></p><p>上述语句的作用，就是将file_name的本地工作区的修改全部撤销，有两种情况：</p><ul><li><p>如果file_name在commit后没有add过这个文件，则撤销到版本库中的状态</p></li><li><p>如果file_name在commit后add过这个文件，则撤销到暂存区的状态，也就是add后的状态</p></li></ul><p>总之，就是让指定的文件回滚到最近的一次<code>git add</code> 或者 <code>git commit</code>时的状态！</p><blockquote><p>小明：太棒了，以后再也不怕提错代码了！ </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述，我们介绍了git reset \ git revert \ git checkout 在版本回滚、重做、撤销修改方面的作用；</p><p>可以应用到工作中对 误操作、不满足要求、不满足意愿的commit记录的重做和修改；</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你知道Git版本控制系统中都有哪些“后悔药”吗？ &lt;/p&gt;
&lt;p&gt;本文通过案例讲解&lt;code&gt;git reset 、 git revert 、 git checkout&lt;/code&gt;在版本控制中的作用；&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://coderstudy.vip/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="http://coderstudy.vip/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>中间件-正在筹备中...</title>
    <link href="http://coderstudy.vip/article/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html"/>
    <id>http://coderstudy.vip/article/%E4%B8%AD%E9%97%B4%E4%BB%B6-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html</id>
    <published>2021-03-03T07:23:23.899Z</published>
    <updated>2021-03-03T07:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章正在筹备中，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章正在筹备中，敬请期待！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="中间件" scheme="http://coderstudy.vip/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="http://coderstudy.vip/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>算法-正在筹备中...</title>
    <link href="http://coderstudy.vip/article/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html"/>
    <id>http://coderstudy.vip/article/%E7%AE%97%E6%B3%95-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html</id>
    <published>2021-03-03T07:23:19.869Z</published>
    <updated>2021-03-03T07:21:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章正在筹备中，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章正在筹备中，敬请期待！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://coderstudy.vip/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://coderstudy.vip/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>高并发-正在筹备中...</title>
    <link href="http://coderstudy.vip/article/%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html"/>
    <id>http://coderstudy.vip/article/%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html</id>
    <published>2021-03-03T07:23:15.694Z</published>
    <updated>2021-03-03T07:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章正在筹备中，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章正在筹备中，敬请期待！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="高并发" scheme="http://coderstudy.vip/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="高并发" scheme="http://coderstudy.vip/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式-正在筹备中...</title>
    <link href="http://coderstudy.vip/article/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html"/>
    <id>http://coderstudy.vip/article/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%AD%A3%E5%9C%A8%E7%AD%B9%E5%A4%87%E4%B8%AD.html</id>
    <published>2021-03-03T07:23:12.104Z</published>
    <updated>2021-03-03T07:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章正在筹备中，敬请期待！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章正在筹备中，敬请期待！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="分布式" scheme="http://coderstudy.vip/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://coderstudy.vip/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
